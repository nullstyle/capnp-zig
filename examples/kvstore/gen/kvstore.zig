// Generated by capnpc-zig
// Source: kvstore.capnp

const std = @import("std");
const capnpc = @import("capnpc-zig");
const message = capnpc.message;
const schema = capnpc.schema;
const rpc = capnpc.rpc;

pub const CAPNP_SCHEMA_MANIFEST_JSON: []const u8 = "{\"schema\":\"kvstore.capnp\",\"module\":\"kvstore\",\"serde\":[{\"id\":18187060301265983672,\"type_name\":\"BackupInfo\",\"to_json_export\":\"capnp_kvstore_backup_info_to_json\",\"from_json_export\":\"capnp_kvstore_backup_info_from_json\"},{\"id\":11171705379688105702,\"type_name\":\"CreateBackupParams\",\"to_json_export\":\"capnp_kvstore_create_backup_params_to_json\",\"from_json_export\":\"capnp_kvstore_create_backup_params_from_json\"},{\"id\":13741020670663859949,\"type_name\":\"CreateBackupResults\",\"to_json_export\":\"capnp_kvstore_create_backup_results_to_json\",\"from_json_export\":\"capnp_kvstore_create_backup_results_from_json\"},{\"id\":12392355825827701191,\"type_name\":\"Entry\",\"to_json_export\":\"capnp_kvstore_entry_to_json\",\"from_json_export\":\"capnp_kvstore_entry_from_json\"},{\"id\":17767598820233916730,\"type_name\":\"GetParams\",\"to_json_export\":\"capnp_kvstore_get_params_to_json\",\"from_json_export\":\"capnp_kvstore_get_params_from_json\"},{\"id\":13421522526614393234,\"type_name\":\"GetResults\",\"to_json_export\":\"capnp_kvstore_get_results_to_json\",\"from_json_export\":\"capnp_kvstore_get_results_from_json\"},{\"id\":11080943541536825287,\"type_name\":\"KeysChangedParams\",\"to_json_export\":\"capnp_kvstore_keys_changed_params_to_json\",\"from_json_export\":\"capnp_kvstore_keys_changed_params_from_json\"},{\"id\":13937400498430719487,\"type_name\":\"KeysChangedResults\",\"to_json_export\":\"capnp_kvstore_keys_changed_results_to_json\",\"from_json_export\":\"capnp_kvstore_keys_changed_results_from_json\"},{\"id\":18309665016469790977,\"type_name\":\"ListBackupsParams\",\"to_json_export\":\"capnp_kvstore_list_backups_params_to_json\",\"from_json_export\":\"capnp_kvstore_list_backups_params_from_json\"},{\"id\":16924525072340453138,\"type_name\":\"ListBackupsResults\",\"to_json_export\":\"capnp_kvstore_list_backups_results_to_json\",\"from_json_export\":\"capnp_kvstore_list_backups_results_from_json\"},{\"id\":15550500692302571658,\"type_name\":\"ListParams\",\"to_json_export\":\"capnp_kvstore_list_params_to_json\",\"from_json_export\":\"capnp_kvstore_list_params_from_json\"},{\"id\":14000907210868832632,\"type_name\":\"ListResults\",\"to_json_export\":\"capnp_kvstore_list_results_to_json\",\"from_json_export\":\"capnp_kvstore_list_results_from_json\"},{\"id\":10708852059958750886,\"type_name\":\"RestoreFromBackupParams\",\"to_json_export\":\"capnp_kvstore_restore_from_backup_params_to_json\",\"from_json_export\":\"capnp_kvstore_restore_from_backup_params_from_json\"},{\"id\":9648253146390380200,\"type_name\":\"RestoreFromBackupResults\",\"to_json_export\":\"capnp_kvstore_restore_from_backup_results_to_json\",\"from_json_export\":\"capnp_kvstore_restore_from_backup_results_from_json\"},{\"id\":12987402725860006244,\"type_name\":\"SetWatchedKeysParams\",\"to_json_export\":\"capnp_kvstore_set_watched_keys_params_to_json\",\"from_json_export\":\"capnp_kvstore_set_watched_keys_params_from_json\"},{\"id\":17403902116338481501,\"type_name\":\"SetWatchedKeysResults\",\"to_json_export\":\"capnp_kvstore_set_watched_keys_results_to_json\",\"from_json_export\":\"capnp_kvstore_set_watched_keys_results_from_json\"},{\"id\":14325193720652141914,\"type_name\":\"StateResetRequiredParams\",\"to_json_export\":\"capnp_kvstore_state_reset_required_params_to_json\",\"from_json_export\":\"capnp_kvstore_state_reset_required_params_from_json\"},{\"id\":17818812260360060587,\"type_name\":\"StateResetRequiredResults\",\"to_json_export\":\"capnp_kvstore_state_reset_required_results_to_json\",\"from_json_export\":\"capnp_kvstore_state_reset_required_results_from_json\"},{\"id\":16657142347263246436,\"type_name\":\"SubscribeParams\",\"to_json_export\":\"capnp_kvstore_subscribe_params_to_json\",\"from_json_export\":\"capnp_kvstore_subscribe_params_from_json\"},{\"id\":11733688047753984483,\"type_name\":\"SubscribeResults\",\"to_json_export\":\"capnp_kvstore_subscribe_results_to_json\",\"from_json_export\":\"capnp_kvstore_subscribe_results_from_json\"},{\"id\":11680591861407114620,\"type_name\":\"WriteBatchParams\",\"to_json_export\":\"capnp_kvstore_write_batch_params_to_json\",\"from_json_export\":\"capnp_kvstore_write_batch_params_from_json\"},{\"id\":14079650963604611870,\"type_name\":\"WriteBatchResults\",\"to_json_export\":\"capnp_kvstore_write_batch_results_to_json\",\"from_json_export\":\"capnp_kvstore_write_batch_results_from_json\"},{\"id\":10201330576906684636,\"type_name\":\"WriteOp\",\"to_json_export\":\"capnp_kvstore_write_op_to_json\",\"from_json_export\":\"capnp_kvstore_write_op_from_json\"},{\"id\":15149054147824698128,\"type_name\":\"WriteOpResult\",\"to_json_export\":\"capnp_kvstore_write_op_result_to_json\",\"from_json_export\":\"capnp_kvstore_write_op_result_from_json\"}]}";
pub fn capnpSchemaManifestJson() []const u8 {
    return CAPNP_SCHEMA_MANIFEST_JSON;
}

pub const Entry = struct {
    const EnumListReader = message.typed_list_helpers.EnumListReader;
    const EnumListBuilder = message.typed_list_helpers.EnumListBuilder;
    const StructListReader = message.typed_list_helpers.StructListReader;
    const StructListBuilder = message.typed_list_helpers.StructListBuilder;
    const DataListReader = message.typed_list_helpers.DataListReader;
    const DataListBuilder = message.typed_list_helpers.DataListBuilder;
    const CapabilityListReader = message.typed_list_helpers.CapabilityListReader;
    const CapabilityListBuilder = message.typed_list_helpers.CapabilityListBuilder;

    pub const Reader = struct {
        _reader: message.StructReader,

        pub fn init(msg: *const message.Message) !Reader {
            const root = try msg.getRootStruct();
            return .{ ._reader = root };
        }

        pub fn wrap(reader: message.StructReader) Reader {
            return .{ ._reader = reader };
        }

        pub fn getKey(self: Reader) ![]const u8 {
            if (self._reader.isPointerNull(0)) return "";
            return try self._reader.readText(0);
        }

        pub fn getValue(self: Reader) ![]const u8 {
            if (self._reader.isPointerNull(1)) return &[_]u8{};
            return try self._reader.readData(1);
        }

        pub fn getVersion(self: Reader) !u64 {
            const raw = self._reader.readU64(0);
            const value = raw ^ @as(u64, 0);
            return value;
        }

    };

    pub const Builder = struct {
        _builder: message.StructBuilder,

        pub fn init(msg: *message.MessageBuilder) !Builder {
            const builder = try msg.allocateStruct(1, 2);
            return .{ ._builder = builder };
        }

        pub fn wrap(builder: message.StructBuilder) Builder {
            return .{ ._builder = builder };
        }

        pub fn setKey(self: *Builder, value: []const u8) !void {
            try self._builder.writeText(0, value);
        }

        pub fn setValue(self: *Builder, value: []const u8) !void {
            try self._builder.writeData(1, value);
        }

        pub fn setVersion(self: *Builder, value: u64) !void {
            const stored = @as(u64, @bitCast(value)) ^ @as(u64, 0);
            self._builder.writeU64(0, stored);
        }

    };
};

pub const WriteOp = struct {
    const EnumListReader = message.typed_list_helpers.EnumListReader;
    const EnumListBuilder = message.typed_list_helpers.EnumListBuilder;
    const StructListReader = message.typed_list_helpers.StructListReader;
    const StructListBuilder = message.typed_list_helpers.StructListBuilder;
    const DataListReader = message.typed_list_helpers.DataListReader;
    const DataListBuilder = message.typed_list_helpers.DataListBuilder;
    const CapabilityListReader = message.typed_list_helpers.CapabilityListReader;
    const CapabilityListBuilder = message.typed_list_helpers.CapabilityListBuilder;

    pub const WhichTag = enum(u16) {
        put = 0,
        delete = 1,
    };

    pub const Reader = struct {
        _reader: message.StructReader,

        pub fn init(msg: *const message.Message) !Reader {
            const root = try msg.getRootStruct();
            return .{ ._reader = root };
        }

        pub fn wrap(reader: message.StructReader) Reader {
            return .{ ._reader = reader };
        }

        pub fn which(self: Reader) error{InvalidEnumValue}!WhichTag {
            return std.meta.intToEnum(WhichTag, self._reader.readU16(0)) catch return error.InvalidEnumValue;
        }

        pub fn getKey(self: Reader) ![]const u8 {
            if (self._reader.isPointerNull(0)) return "";
            return try self._reader.readText(0);
        }

        pub fn getPut(self: Reader) ![]const u8 {
            if (self._reader.isPointerNull(1)) return &[_]u8{};
            return try self._reader.readData(1);
        }

        pub fn getDelete(self: Reader) !void {
            _ = self;
            return {};
        }

    };

    pub const Builder = struct {
        _builder: message.StructBuilder,

        pub fn init(msg: *message.MessageBuilder) !Builder {
            const builder = try msg.allocateStruct(1, 2);
            return .{ ._builder = builder };
        }

        pub fn wrap(builder: message.StructBuilder) Builder {
            return .{ ._builder = builder };
        }

        pub fn setKey(self: *Builder, value: []const u8) !void {
            try self._builder.writeText(0, value);
        }

        pub fn setPut(self: *Builder, value: []const u8) !void {
            self._builder.writeU16(0, 0);
            try self._builder.writeData(1, value);
        }

        pub fn setDelete(self: *Builder, value: void) !void {
            self._builder.writeU16(0, 1);
            _ = value;
        }

    };
};

pub const WriteOpResult = struct {
    const EnumListReader = message.typed_list_helpers.EnumListReader;
    const EnumListBuilder = message.typed_list_helpers.EnumListBuilder;
    const StructListReader = message.typed_list_helpers.StructListReader;
    const StructListBuilder = message.typed_list_helpers.StructListBuilder;
    const DataListReader = message.typed_list_helpers.DataListReader;
    const DataListBuilder = message.typed_list_helpers.DataListBuilder;
    const CapabilityListReader = message.typed_list_helpers.CapabilityListReader;
    const CapabilityListBuilder = message.typed_list_helpers.CapabilityListBuilder;

    pub const WhichTag = enum(u16) {
        put = 0,
        delete = 1,
    };

    pub const Reader = struct {
        _reader: message.StructReader,

        pub fn init(msg: *const message.Message) !Reader {
            const root = try msg.getRootStruct();
            return .{ ._reader = root };
        }

        pub fn wrap(reader: message.StructReader) Reader {
            return .{ ._reader = reader };
        }

        pub fn which(self: Reader) error{InvalidEnumValue}!WhichTag {
            return std.meta.intToEnum(WhichTag, self._reader.readU16(0)) catch return error.InvalidEnumValue;
        }

        pub fn getKey(self: Reader) ![]const u8 {
            if (self._reader.isPointerNull(0)) return "";
            return try self._reader.readText(0);
        }

        pub fn getPut(self: Reader) !Entry.Reader {
            const value = try self._reader.readStruct(1);
            return Entry.Reader{ ._reader = value };
        }

        pub fn getDelete(self: Reader) !bool {
            return self._reader.readBool(2, 0) != false;
        }

    };

    pub const Builder = struct {
        _builder: message.StructBuilder,

        pub fn init(msg: *message.MessageBuilder) !Builder {
            const builder = try msg.allocateStruct(1, 2);
            return .{ ._builder = builder };
        }

        pub fn wrap(builder: message.StructBuilder) Builder {
            return .{ ._builder = builder };
        }

        pub fn setKey(self: *Builder, value: []const u8) !void {
            try self._builder.writeText(0, value);
        }

        pub fn initPut(self: *Builder) !Entry.Builder {
            self._builder.writeU16(0, 0);
            const builder = try self._builder.initStruct(1, 1, 2);
            return Entry.Builder{ ._builder = builder };
        }

        pub fn setDelete(self: *Builder, value: bool) !void {
            self._builder.writeU16(0, 1);
            self._builder.writeBool(2, 0, value != false);
        }

    };
};

pub const BackupInfo = struct {
    const EnumListReader = message.typed_list_helpers.EnumListReader;
    const EnumListBuilder = message.typed_list_helpers.EnumListBuilder;
    const StructListReader = message.typed_list_helpers.StructListReader;
    const StructListBuilder = message.typed_list_helpers.StructListBuilder;
    const DataListReader = message.typed_list_helpers.DataListReader;
    const DataListBuilder = message.typed_list_helpers.DataListBuilder;
    const CapabilityListReader = message.typed_list_helpers.CapabilityListReader;
    const CapabilityListBuilder = message.typed_list_helpers.CapabilityListBuilder;

    pub const Reader = struct {
        _reader: message.StructReader,

        pub fn init(msg: *const message.Message) !Reader {
            const root = try msg.getRootStruct();
            return .{ ._reader = root };
        }

        pub fn wrap(reader: message.StructReader) Reader {
            return .{ ._reader = reader };
        }

        pub fn getBackupId(self: Reader) !u32 {
            const raw = self._reader.readU32(0);
            const value = raw ^ @as(u32, 0);
            return value;
        }

        pub fn getTimestamp(self: Reader) !i64 {
            const raw = self._reader.readU64(8);
            const value = raw ^ @as(u64, 0);
            return @bitCast(value);
        }

        pub fn getSize(self: Reader) !u64 {
            const raw = self._reader.readU64(16);
            const value = raw ^ @as(u64, 0);
            return value;
        }

        pub fn getNumFiles(self: Reader) !u32 {
            const raw = self._reader.readU32(4);
            const value = raw ^ @as(u32, 0);
            return value;
        }

    };

    pub const Builder = struct {
        _builder: message.StructBuilder,

        pub fn init(msg: *message.MessageBuilder) !Builder {
            const builder = try msg.allocateStruct(3, 0);
            return .{ ._builder = builder };
        }

        pub fn wrap(builder: message.StructBuilder) Builder {
            return .{ ._builder = builder };
        }

        pub fn setBackupId(self: *Builder, value: u32) !void {
            const stored = @as(u32, @bitCast(value)) ^ @as(u32, 0);
            self._builder.writeU32(0, stored);
        }

        pub fn setTimestamp(self: *Builder, value: i64) !void {
            const stored = @as(u64, @bitCast(value)) ^ @as(u64, 0);
            self._builder.writeU64(8, stored);
        }

        pub fn setSize(self: *Builder, value: u64) !void {
            const stored = @as(u64, @bitCast(value)) ^ @as(u64, 0);
            self._builder.writeU64(16, stored);
        }

        pub fn setNumFiles(self: *Builder, value: u32) !void {
            const stored = @as(u32, @bitCast(value)) ^ @as(u32, 0);
            self._builder.writeU32(4, stored);
        }

    };
};

pub const KvClientNotifier = struct {
    pub const interface_id: u64 = 0x86eb32e5c8fdeed1;
    pub const Method = enum(u16) {
        KeysChanged = 0,
        StateResetRequired = 1,
    };

    pub const KeysChanged = struct {
        pub const ordinal: u16 = 0;
        pub const is_streaming: bool = false;
        pub const Params = KeysChangedParams;
        pub const Results = KeysChangedResults;
        pub const BuildFn = *const fn (ctx: *anyopaque, params: *Params.Builder) anyerror!void;
        pub const Handler = *const fn (ctx: *anyopaque, peer: *rpc.peer.Peer, params: Params.Reader, results: *Results.Builder, caps: *const rpc.cap_table.InboundCapTable) anyerror!void;
        pub const DeferredHandler = *const fn (ctx: *anyopaque, peer: *rpc.peer.Peer, params: Params.Reader, caps: *const rpc.cap_table.InboundCapTable, sender: ReturnSender) anyerror!void;
        pub const Response = union(enum) {
            results: Results.Reader,
            exception: rpc.protocol.Exception,
            canceled,
            results_sent_elsewhere,
            take_from_other_question: u32,
            accept_from_third_party,
        };
        pub const Callback = *const fn (ctx: *anyopaque, peer: *rpc.peer.Peer, response: Response, caps: *const rpc.cap_table.InboundCapTable) anyerror!void;

        const CallContext = struct {
            user_ctx: *anyopaque,
            build: ?BuildFn,
            callback: Callback,
        };

        const DirectReturnContext = struct {
            handler: Handler,
            ctx: *anyopaque,
            peer: *rpc.peer.Peer,
            params: Params.Reader,
            caps: *const rpc.cap_table.InboundCapTable,
        };

        pub const ReturnSender = struct {
            peer: *rpc.peer.Peer,
            question_id: u32,

            pub fn sendResults(self: ReturnSender, ctx: *anyopaque, build: *const fn (ctx: *anyopaque, ret: *rpc.protocol.ReturnBuilder) anyerror!void) !void {
                try self.peer.sendReturnResults(self.question_id, ctx, build);
            }

            pub fn sendException(self: ReturnSender, reason: []const u8) !void {
                try self.peer.sendReturnException(self.question_id, reason);
            }
        };

        fn callBuild(ctx_ptr: *anyopaque, call: *rpc.protocol.CallBuilder) anyerror!void {
            const ctx: *CallContext = @ptrCast(@alignCast(ctx_ptr));
            var payload = try call.payloadTyped();
            var params_any = try payload.initContent();
            const params_builder = try params_any.initStruct(0, 1);
            var params = Params.Builder.wrap(params_builder);
            if (ctx.build) |build_fn| {
                try build_fn(ctx.user_ctx, &params);
            }
            _ = try call.initCapTableTyped(0);
        }

        fn callReturn(ctx_ptr: *anyopaque, peer: *rpc.peer.Peer, ret: rpc.protocol.Return, caps: *const rpc.cap_table.InboundCapTable) anyerror!void {
            const ctx: *CallContext = @ptrCast(@alignCast(ctx_ptr));
            defer peer.allocator.destroy(ctx);
            var response: Response = undefined;
            switch (ret.tag) {
                .results => {
                    const payload = ret.results orelse return error.MissingReturnPayload;
                    const struct_reader = try payload.content.getStruct();
                    const results = Results.Reader.wrap(struct_reader);
                    response = .{ .results = results };
                },
                .exception => {
                    const ex = ret.exception orelse return error.MissingException;
                    response = .{ .exception = ex };
                },
                .canceled => response = .canceled,
                .resultsSentElsewhere => response = .results_sent_elsewhere,
                .takeFromOtherQuestion => {
                    const qid = ret.take_from_other_question orelse return error.MissingQuestionId;
                    response = .{ .take_from_other_question = qid };
                },
                .awaitFromThirdParty => response = .accept_from_third_party,
            }
            try ctx.callback(ctx.user_ctx, peer, response, caps);
        }

        pub fn handleCallDirect(handler: Handler, deferred_handler: ?DeferredHandler, ctx: *anyopaque, peer: *rpc.peer.Peer, call: rpc.protocol.Call, caps: *const rpc.cap_table.InboundCapTable) anyerror!void {
            const params_struct = try call.params.content.getStruct();
            const params = Params.Reader.wrap(params_struct);
            if (deferred_handler) |deferred_fn| {
                const sender = ReturnSender{ .peer = peer, .question_id = call.question_id };
                try deferred_fn(ctx, peer, params, caps, sender);
            } else {
                var dctx = DirectReturnContext{
                    .handler = handler,
                    .ctx = ctx,
                    .peer = peer,
                    .params = params,
                    .caps = caps,
                };
                try peer.sendReturnResults(call.question_id, &dctx, buildReturnDirect);
            }
        }

        fn handleCall(server: *Server, peer: *rpc.peer.Peer, call: rpc.protocol.Call, caps: *const rpc.cap_table.InboundCapTable) anyerror!void {
            try handleCallDirect(server.vtable.keysChanged, server.vtable.keysChanged_deferred, server.ctx, peer, call, caps);
        }

        fn buildReturnDirect(ctx_ptr: *anyopaque, ret: *rpc.protocol.ReturnBuilder) anyerror!void {
            const dctx: *DirectReturnContext = @ptrCast(@alignCast(ctx_ptr));
            var payload = try ret.payloadTyped();
            var results_any = try payload.initContent();
            const results_builder = try results_any.initStruct(0, 0);
            var results = Results.Builder.wrap(results_builder);
            try dctx.handler(dctx.ctx, dctx.peer, dctx.params, &results, dctx.caps);
            _ = try ret.initCapTableTyped(0);
        }
    };

    pub const StateResetRequired = struct {
        pub const ordinal: u16 = 1;
        pub const is_streaming: bool = false;
        pub const Params = StateResetRequiredParams;
        pub const Results = StateResetRequiredResults;
        pub const BuildFn = *const fn (ctx: *anyopaque, params: *Params.Builder) anyerror!void;
        pub const Handler = *const fn (ctx: *anyopaque, peer: *rpc.peer.Peer, params: Params.Reader, results: *Results.Builder, caps: *const rpc.cap_table.InboundCapTable) anyerror!void;
        pub const DeferredHandler = *const fn (ctx: *anyopaque, peer: *rpc.peer.Peer, params: Params.Reader, caps: *const rpc.cap_table.InboundCapTable, sender: ReturnSender) anyerror!void;
        pub const Response = union(enum) {
            results: Results.Reader,
            exception: rpc.protocol.Exception,
            canceled,
            results_sent_elsewhere,
            take_from_other_question: u32,
            accept_from_third_party,
        };
        pub const Callback = *const fn (ctx: *anyopaque, peer: *rpc.peer.Peer, response: Response, caps: *const rpc.cap_table.InboundCapTable) anyerror!void;

        const CallContext = struct {
            user_ctx: *anyopaque,
            build: ?BuildFn,
            callback: Callback,
        };

        const DirectReturnContext = struct {
            handler: Handler,
            ctx: *anyopaque,
            peer: *rpc.peer.Peer,
            params: Params.Reader,
            caps: *const rpc.cap_table.InboundCapTable,
        };

        pub const ReturnSender = struct {
            peer: *rpc.peer.Peer,
            question_id: u32,

            pub fn sendResults(self: ReturnSender, ctx: *anyopaque, build: *const fn (ctx: *anyopaque, ret: *rpc.protocol.ReturnBuilder) anyerror!void) !void {
                try self.peer.sendReturnResults(self.question_id, ctx, build);
            }

            pub fn sendException(self: ReturnSender, reason: []const u8) !void {
                try self.peer.sendReturnException(self.question_id, reason);
            }
        };

        fn callBuild(ctx_ptr: *anyopaque, call: *rpc.protocol.CallBuilder) anyerror!void {
            const ctx: *CallContext = @ptrCast(@alignCast(ctx_ptr));
            var payload = try call.payloadTyped();
            var params_any = try payload.initContent();
            const params_builder = try params_any.initStruct(2, 0);
            var params = Params.Builder.wrap(params_builder);
            if (ctx.build) |build_fn| {
                try build_fn(ctx.user_ctx, &params);
            }
            _ = try call.initCapTableTyped(0);
        }

        fn callReturn(ctx_ptr: *anyopaque, peer: *rpc.peer.Peer, ret: rpc.protocol.Return, caps: *const rpc.cap_table.InboundCapTable) anyerror!void {
            const ctx: *CallContext = @ptrCast(@alignCast(ctx_ptr));
            defer peer.allocator.destroy(ctx);
            var response: Response = undefined;
            switch (ret.tag) {
                .results => {
                    const payload = ret.results orelse return error.MissingReturnPayload;
                    const struct_reader = try payload.content.getStruct();
                    const results = Results.Reader.wrap(struct_reader);
                    response = .{ .results = results };
                },
                .exception => {
                    const ex = ret.exception orelse return error.MissingException;
                    response = .{ .exception = ex };
                },
                .canceled => response = .canceled,
                .resultsSentElsewhere => response = .results_sent_elsewhere,
                .takeFromOtherQuestion => {
                    const qid = ret.take_from_other_question orelse return error.MissingQuestionId;
                    response = .{ .take_from_other_question = qid };
                },
                .awaitFromThirdParty => response = .accept_from_third_party,
            }
            try ctx.callback(ctx.user_ctx, peer, response, caps);
        }

        pub fn handleCallDirect(handler: Handler, deferred_handler: ?DeferredHandler, ctx: *anyopaque, peer: *rpc.peer.Peer, call: rpc.protocol.Call, caps: *const rpc.cap_table.InboundCapTable) anyerror!void {
            const params_struct = try call.params.content.getStruct();
            const params = Params.Reader.wrap(params_struct);
            if (deferred_handler) |deferred_fn| {
                const sender = ReturnSender{ .peer = peer, .question_id = call.question_id };
                try deferred_fn(ctx, peer, params, caps, sender);
            } else {
                var dctx = DirectReturnContext{
                    .handler = handler,
                    .ctx = ctx,
                    .peer = peer,
                    .params = params,
                    .caps = caps,
                };
                try peer.sendReturnResults(call.question_id, &dctx, buildReturnDirect);
            }
        }

        fn handleCall(server: *Server, peer: *rpc.peer.Peer, call: rpc.protocol.Call, caps: *const rpc.cap_table.InboundCapTable) anyerror!void {
            try handleCallDirect(server.vtable.stateResetRequired, server.vtable.stateResetRequired_deferred, server.ctx, peer, call, caps);
        }

        fn buildReturnDirect(ctx_ptr: *anyopaque, ret: *rpc.protocol.ReturnBuilder) anyerror!void {
            const dctx: *DirectReturnContext = @ptrCast(@alignCast(ctx_ptr));
            var payload = try ret.payloadTyped();
            var results_any = try payload.initContent();
            const results_builder = try results_any.initStruct(0, 0);
            var results = Results.Builder.wrap(results_builder);
            try dctx.handler(dctx.ctx, dctx.peer, dctx.params, &results, dctx.caps);
            _ = try ret.initCapTableTyped(0);
        }
    };

    pub const Client = struct {
        peer: *rpc.peer.Peer,
        cap_id: u32,

        pub fn init(peer: *rpc.peer.Peer, cap_id: u32) Client {
            return .{ .peer = peer, .cap_id = cap_id };
        }

        pub fn callKeysChanged(self: *Client, user_ctx: *anyopaque, build: ?KeysChanged.BuildFn, on_return: KeysChanged.Callback) !u32 {
            const ctx = try self.peer.allocator.create(KeysChanged.CallContext);
            ctx.* = .{ .user_ctx = user_ctx, .build = build, .callback = on_return };
            return self.peer.sendCall(self.cap_id, interface_id, KeysChanged.ordinal, ctx, KeysChanged.callBuild, KeysChanged.callReturn);
        }

        pub fn callStateResetRequired(self: *Client, user_ctx: *anyopaque, build: ?StateResetRequired.BuildFn, on_return: StateResetRequired.Callback) !u32 {
            const ctx = try self.peer.allocator.create(StateResetRequired.CallContext);
            ctx.* = .{ .user_ctx = user_ctx, .build = build, .callback = on_return };
            return self.peer.sendCall(self.cap_id, interface_id, StateResetRequired.ordinal, ctx, StateResetRequired.callBuild, StateResetRequired.callReturn);
        }

        pub fn fromBootstrap(peer: *rpc.peer.Peer, user_ctx: *anyopaque, callback: BootstrapCallback) !u32 {
            return bootstrap(peer, user_ctx, callback);
        }

    };

    pub const PipelinedClient = struct {
        peer: *rpc.peer.Peer,
        question_id: u32,
        pointer_index: u16,

        pub fn callKeysChanged(self: *PipelinedClient, user_ctx: *anyopaque, build: ?KeysChanged.BuildFn, on_return: KeysChanged.Callback) !u32 {
            const ctx = try self.peer.allocator.create(KeysChanged.CallContext);
            ctx.* = .{ .user_ctx = user_ctx, .build = build, .callback = on_return };
            return self.peer.sendCallPromisedWithOps(self.question_id, &[_]rpc.protocol.PromisedAnswerOp{.{ .tag = .getPointerField, .pointer_index = self.pointer_index }}, interface_id, KeysChanged.ordinal, ctx, KeysChanged.callBuild, KeysChanged.callReturn);
        }

        pub fn callStateResetRequired(self: *PipelinedClient, user_ctx: *anyopaque, build: ?StateResetRequired.BuildFn, on_return: StateResetRequired.Callback) !u32 {
            const ctx = try self.peer.allocator.create(StateResetRequired.CallContext);
            ctx.* = .{ .user_ctx = user_ctx, .build = build, .callback = on_return };
            return self.peer.sendCallPromisedWithOps(self.question_id, &[_]rpc.protocol.PromisedAnswerOp{.{ .tag = .getPointerField, .pointer_index = self.pointer_index }}, interface_id, StateResetRequired.ordinal, ctx, StateResetRequired.callBuild, StateResetRequired.callReturn);
        }

    };

    pub const BootstrapResponse = union(enum) {
        client: Client,
        exception: rpc.protocol.Exception,
        canceled,
        results_sent_elsewhere,
        take_from_other_question: u32,
        accept_from_third_party,
    };
    pub const BootstrapCallback = *const fn (ctx: *anyopaque, peer: *rpc.peer.Peer, response: BootstrapResponse) anyerror!void;

    const BootstrapContext = struct {
        user_ctx: *anyopaque,
        callback: BootstrapCallback,
    };

    fn bootstrapReturn(ctx_ptr: *anyopaque, peer: *rpc.peer.Peer, ret: rpc.protocol.Return, caps: *const rpc.cap_table.InboundCapTable) anyerror!void {
        const ctx: *BootstrapContext = @ptrCast(@alignCast(ctx_ptr));
        defer peer.allocator.destroy(ctx);
        var response: BootstrapResponse = undefined;
        switch (ret.tag) {
            .results => {
                const payload = ret.results orelse return error.MissingReturnPayload;
                const cap = try payload.content.getCapability();
                var mutable_caps = caps.*;
                try mutable_caps.retainCapability(cap);
                const resolved = try caps.resolveCapability(cap);
                switch (resolved) {
                    .imported => |imported| response = .{ .client = Client.init(peer, imported.id) },
                    else => return error.UnexpectedBootstrapCapability,
                }
            },
            .exception => {
                const ex = ret.exception orelse return error.MissingException;
                response = .{ .exception = ex };
            },
            .canceled => response = .canceled,
            .resultsSentElsewhere => response = .results_sent_elsewhere,
            .takeFromOtherQuestion => {
                const qid = ret.take_from_other_question orelse return error.MissingQuestionId;
                response = .{ .take_from_other_question = qid };
            },
            .awaitFromThirdParty => response = .accept_from_third_party,
        }
        try ctx.callback(ctx.user_ctx, peer, response);
    }

    pub fn bootstrap(peer: *rpc.peer.Peer, user_ctx: *anyopaque, callback: BootstrapCallback) !u32 {
        const ctx = try peer.allocator.create(BootstrapContext);
        ctx.* = .{ .user_ctx = user_ctx, .callback = callback };
        return peer.sendBootstrap(ctx, bootstrapReturn);
    }

    pub const Server = struct {
        ctx: *anyopaque,
        vtable: VTable,
    };

    pub const VTable = struct {
        keysChanged: KeysChanged.Handler,
        keysChanged_deferred: ?KeysChanged.DeferredHandler = null,
        stateResetRequired: StateResetRequired.Handler,
        stateResetRequired_deferred: ?StateResetRequired.DeferredHandler = null,
    };

    pub fn exportServer(peer: *rpc.peer.Peer, server: *Server) !u32 {
        return peer.addExport(.{ .ctx = server, .on_call = onCall });
    }

    pub fn setBootstrap(peer: *rpc.peer.Peer, server: *Server) !u32 {
        return peer.setBootstrap(.{ .ctx = server, .on_call = onCall });
    }

    fn onCall(ctx: *anyopaque, peer: *rpc.peer.Peer, call: rpc.protocol.Call, caps: *const rpc.cap_table.InboundCapTable) anyerror!void {
        const server: *Server = @ptrCast(@alignCast(ctx));
        switch (call.method_id) {
            KeysChanged.ordinal => try KeysChanged.handleCall(server, peer, call, caps),
            StateResetRequired.ordinal => try StateResetRequired.handleCall(server, peer, call, caps),
            else => try peer.sendReturnException(call.question_id, "unknown method"),
        }
    }
};

pub const KeysChangedParams = struct {
    const EnumListReader = message.typed_list_helpers.EnumListReader;
    const EnumListBuilder = message.typed_list_helpers.EnumListBuilder;
    const StructListReader = message.typed_list_helpers.StructListReader;
    const StructListBuilder = message.typed_list_helpers.StructListBuilder;
    const DataListReader = message.typed_list_helpers.DataListReader;
    const DataListBuilder = message.typed_list_helpers.DataListBuilder;
    const CapabilityListReader = message.typed_list_helpers.CapabilityListReader;
    const CapabilityListBuilder = message.typed_list_helpers.CapabilityListBuilder;

    pub const Reader = struct {
        _reader: message.StructReader,

        pub fn init(msg: *const message.Message) !Reader {
            const root = try msg.getRootStruct();
            return .{ ._reader = root };
        }

        pub fn wrap(reader: message.StructReader) Reader {
            return .{ ._reader = reader };
        }

        pub fn getChanges(self: Reader) !StructListReader(WriteOpResult) {
            const raw = try self._reader.readStructList(0);
            return StructListReader(WriteOpResult){ ._list = raw };
        }

    };

    pub const Builder = struct {
        _builder: message.StructBuilder,

        pub fn init(msg: *message.MessageBuilder) !Builder {
            const builder = try msg.allocateStruct(0, 1);
            return .{ ._builder = builder };
        }

        pub fn wrap(builder: message.StructBuilder) Builder {
            return .{ ._builder = builder };
        }

        pub fn initChanges(self: *Builder, element_count: u32) !StructListBuilder(WriteOpResult) {
            const raw = try self._builder.writeStructList(0, element_count, 1, 2);
            return StructListBuilder(WriteOpResult){ ._list = raw };
        }

    };
};

pub const KeysChangedResults = struct {
    const EnumListReader = message.typed_list_helpers.EnumListReader;
    const EnumListBuilder = message.typed_list_helpers.EnumListBuilder;
    const StructListReader = message.typed_list_helpers.StructListReader;
    const StructListBuilder = message.typed_list_helpers.StructListBuilder;
    const DataListReader = message.typed_list_helpers.DataListReader;
    const DataListBuilder = message.typed_list_helpers.DataListBuilder;
    const CapabilityListReader = message.typed_list_helpers.CapabilityListReader;
    const CapabilityListBuilder = message.typed_list_helpers.CapabilityListBuilder;

    pub const Reader = struct {
        _reader: message.StructReader,

        pub fn init(msg: *const message.Message) !Reader {
            const root = try msg.getRootStruct();
            return .{ ._reader = root };
        }

        pub fn wrap(reader: message.StructReader) Reader {
            return .{ ._reader = reader };
        }

    };

    pub const Builder = struct {
        _builder: message.StructBuilder,

        pub fn init(msg: *message.MessageBuilder) !Builder {
            const builder = try msg.allocateStruct(0, 0);
            return .{ ._builder = builder };
        }

        pub fn wrap(builder: message.StructBuilder) Builder {
            return .{ ._builder = builder };
        }

    };
};

pub const StateResetRequiredParams = struct {
    const EnumListReader = message.typed_list_helpers.EnumListReader;
    const EnumListBuilder = message.typed_list_helpers.EnumListBuilder;
    const StructListReader = message.typed_list_helpers.StructListReader;
    const StructListBuilder = message.typed_list_helpers.StructListBuilder;
    const DataListReader = message.typed_list_helpers.DataListReader;
    const DataListBuilder = message.typed_list_helpers.DataListBuilder;
    const CapabilityListReader = message.typed_list_helpers.CapabilityListReader;
    const CapabilityListBuilder = message.typed_list_helpers.CapabilityListBuilder;

    pub const Reader = struct {
        _reader: message.StructReader,

        pub fn init(msg: *const message.Message) !Reader {
            const root = try msg.getRootStruct();
            return .{ ._reader = root };
        }

        pub fn wrap(reader: message.StructReader) Reader {
            return .{ ._reader = reader };
        }

        pub fn getRestoredBackupId(self: Reader) !u32 {
            const raw = self._reader.readU32(0);
            const value = raw ^ @as(u32, 0);
            return value;
        }

        pub fn getNextVersion(self: Reader) !u64 {
            const raw = self._reader.readU64(8);
            const value = raw ^ @as(u64, 0);
            return value;
        }

    };

    pub const Builder = struct {
        _builder: message.StructBuilder,

        pub fn init(msg: *message.MessageBuilder) !Builder {
            const builder = try msg.allocateStruct(2, 0);
            return .{ ._builder = builder };
        }

        pub fn wrap(builder: message.StructBuilder) Builder {
            return .{ ._builder = builder };
        }

        pub fn setRestoredBackupId(self: *Builder, value: u32) !void {
            const stored = @as(u32, @bitCast(value)) ^ @as(u32, 0);
            self._builder.writeU32(0, stored);
        }

        pub fn setNextVersion(self: *Builder, value: u64) !void {
            const stored = @as(u64, @bitCast(value)) ^ @as(u64, 0);
            self._builder.writeU64(8, stored);
        }

    };
};

pub const StateResetRequiredResults = struct {
    const EnumListReader = message.typed_list_helpers.EnumListReader;
    const EnumListBuilder = message.typed_list_helpers.EnumListBuilder;
    const StructListReader = message.typed_list_helpers.StructListReader;
    const StructListBuilder = message.typed_list_helpers.StructListBuilder;
    const DataListReader = message.typed_list_helpers.DataListReader;
    const DataListBuilder = message.typed_list_helpers.DataListBuilder;
    const CapabilityListReader = message.typed_list_helpers.CapabilityListReader;
    const CapabilityListBuilder = message.typed_list_helpers.CapabilityListBuilder;

    pub const Reader = struct {
        _reader: message.StructReader,

        pub fn init(msg: *const message.Message) !Reader {
            const root = try msg.getRootStruct();
            return .{ ._reader = root };
        }

        pub fn wrap(reader: message.StructReader) Reader {
            return .{ ._reader = reader };
        }

    };

    pub const Builder = struct {
        _builder: message.StructBuilder,

        pub fn init(msg: *message.MessageBuilder) !Builder {
            const builder = try msg.allocateStruct(0, 0);
            return .{ ._builder = builder };
        }

        pub fn wrap(builder: message.StructBuilder) Builder {
            return .{ ._builder = builder };
        }

    };
};

pub const KvStore = struct {
    pub const interface_id: u64 = 0xdabb8fabf7a284bf;
    pub const Method = enum(u16) {
        Get = 0,
        WriteBatch = 1,
        List = 2,
        Subscribe = 3,
        SetWatchedKeys = 4,
        CreateBackup = 5,
        ListBackups = 6,
        RestoreFromBackup = 7,
    };

    pub const Get = struct {
        pub const ordinal: u16 = 0;
        pub const is_streaming: bool = false;
        pub const Params = GetParams;
        pub const Results = GetResults;
        pub const BuildFn = *const fn (ctx: *anyopaque, params: *Params.Builder) anyerror!void;
        pub const Handler = *const fn (ctx: *anyopaque, peer: *rpc.peer.Peer, params: Params.Reader, results: *Results.Builder, caps: *const rpc.cap_table.InboundCapTable) anyerror!void;
        pub const DeferredHandler = *const fn (ctx: *anyopaque, peer: *rpc.peer.Peer, params: Params.Reader, caps: *const rpc.cap_table.InboundCapTable, sender: ReturnSender) anyerror!void;
        pub const Response = union(enum) {
            results: Results.Reader,
            exception: rpc.protocol.Exception,
            canceled,
            results_sent_elsewhere,
            take_from_other_question: u32,
            accept_from_third_party,
        };
        pub const Callback = *const fn (ctx: *anyopaque, peer: *rpc.peer.Peer, response: Response, caps: *const rpc.cap_table.InboundCapTable) anyerror!void;

        const CallContext = struct {
            user_ctx: *anyopaque,
            build: ?BuildFn,
            callback: Callback,
        };

        const DirectReturnContext = struct {
            handler: Handler,
            ctx: *anyopaque,
            peer: *rpc.peer.Peer,
            params: Params.Reader,
            caps: *const rpc.cap_table.InboundCapTable,
        };

        pub const ReturnSender = struct {
            peer: *rpc.peer.Peer,
            question_id: u32,

            pub fn sendResults(self: ReturnSender, ctx: *anyopaque, build: *const fn (ctx: *anyopaque, ret: *rpc.protocol.ReturnBuilder) anyerror!void) !void {
                try self.peer.sendReturnResults(self.question_id, ctx, build);
            }

            pub fn sendException(self: ReturnSender, reason: []const u8) !void {
                try self.peer.sendReturnException(self.question_id, reason);
            }
        };

        fn callBuild(ctx_ptr: *anyopaque, call: *rpc.protocol.CallBuilder) anyerror!void {
            const ctx: *CallContext = @ptrCast(@alignCast(ctx_ptr));
            var payload = try call.payloadTyped();
            var params_any = try payload.initContent();
            const params_builder = try params_any.initStruct(0, 1);
            var params = Params.Builder.wrap(params_builder);
            if (ctx.build) |build_fn| {
                try build_fn(ctx.user_ctx, &params);
            }
            _ = try call.initCapTableTyped(0);
        }

        fn callReturn(ctx_ptr: *anyopaque, peer: *rpc.peer.Peer, ret: rpc.protocol.Return, caps: *const rpc.cap_table.InboundCapTable) anyerror!void {
            const ctx: *CallContext = @ptrCast(@alignCast(ctx_ptr));
            defer peer.allocator.destroy(ctx);
            var response: Response = undefined;
            switch (ret.tag) {
                .results => {
                    const payload = ret.results orelse return error.MissingReturnPayload;
                    const struct_reader = try payload.content.getStruct();
                    const results = Results.Reader.wrap(struct_reader);
                    response = .{ .results = results };
                },
                .exception => {
                    const ex = ret.exception orelse return error.MissingException;
                    response = .{ .exception = ex };
                },
                .canceled => response = .canceled,
                .resultsSentElsewhere => response = .results_sent_elsewhere,
                .takeFromOtherQuestion => {
                    const qid = ret.take_from_other_question orelse return error.MissingQuestionId;
                    response = .{ .take_from_other_question = qid };
                },
                .awaitFromThirdParty => response = .accept_from_third_party,
            }
            try ctx.callback(ctx.user_ctx, peer, response, caps);
        }

        pub fn handleCallDirect(handler: Handler, deferred_handler: ?DeferredHandler, ctx: *anyopaque, peer: *rpc.peer.Peer, call: rpc.protocol.Call, caps: *const rpc.cap_table.InboundCapTable) anyerror!void {
            const params_struct = try call.params.content.getStruct();
            const params = Params.Reader.wrap(params_struct);
            if (deferred_handler) |deferred_fn| {
                const sender = ReturnSender{ .peer = peer, .question_id = call.question_id };
                try deferred_fn(ctx, peer, params, caps, sender);
            } else {
                var dctx = DirectReturnContext{
                    .handler = handler,
                    .ctx = ctx,
                    .peer = peer,
                    .params = params,
                    .caps = caps,
                };
                try peer.sendReturnResults(call.question_id, &dctx, buildReturnDirect);
            }
        }

        fn handleCall(server: *Server, peer: *rpc.peer.Peer, call: rpc.protocol.Call, caps: *const rpc.cap_table.InboundCapTable) anyerror!void {
            try handleCallDirect(server.vtable.get, server.vtable.get_deferred, server.ctx, peer, call, caps);
        }

        fn buildReturnDirect(ctx_ptr: *anyopaque, ret: *rpc.protocol.ReturnBuilder) anyerror!void {
            const dctx: *DirectReturnContext = @ptrCast(@alignCast(ctx_ptr));
            var payload = try ret.payloadTyped();
            var results_any = try payload.initContent();
            const results_builder = try results_any.initStruct(1, 1);
            var results = Results.Builder.wrap(results_builder);
            try dctx.handler(dctx.ctx, dctx.peer, dctx.params, &results, dctx.caps);
            _ = try ret.initCapTableTyped(0);
        }
    };

    pub const WriteBatch = struct {
        pub const ordinal: u16 = 1;
        pub const is_streaming: bool = false;
        pub const Params = WriteBatchParams;
        pub const Results = WriteBatchResults;
        pub const BuildFn = *const fn (ctx: *anyopaque, params: *Params.Builder) anyerror!void;
        pub const Handler = *const fn (ctx: *anyopaque, peer: *rpc.peer.Peer, params: Params.Reader, results: *Results.Builder, caps: *const rpc.cap_table.InboundCapTable) anyerror!void;
        pub const DeferredHandler = *const fn (ctx: *anyopaque, peer: *rpc.peer.Peer, params: Params.Reader, caps: *const rpc.cap_table.InboundCapTable, sender: ReturnSender) anyerror!void;
        pub const Response = union(enum) {
            results: Results.Reader,
            exception: rpc.protocol.Exception,
            canceled,
            results_sent_elsewhere,
            take_from_other_question: u32,
            accept_from_third_party,
        };
        pub const Callback = *const fn (ctx: *anyopaque, peer: *rpc.peer.Peer, response: Response, caps: *const rpc.cap_table.InboundCapTable) anyerror!void;

        const CallContext = struct {
            user_ctx: *anyopaque,
            build: ?BuildFn,
            callback: Callback,
        };

        const DirectReturnContext = struct {
            handler: Handler,
            ctx: *anyopaque,
            peer: *rpc.peer.Peer,
            params: Params.Reader,
            caps: *const rpc.cap_table.InboundCapTable,
        };

        pub const ReturnSender = struct {
            peer: *rpc.peer.Peer,
            question_id: u32,

            pub fn sendResults(self: ReturnSender, ctx: *anyopaque, build: *const fn (ctx: *anyopaque, ret: *rpc.protocol.ReturnBuilder) anyerror!void) !void {
                try self.peer.sendReturnResults(self.question_id, ctx, build);
            }

            pub fn sendException(self: ReturnSender, reason: []const u8) !void {
                try self.peer.sendReturnException(self.question_id, reason);
            }
        };

        fn callBuild(ctx_ptr: *anyopaque, call: *rpc.protocol.CallBuilder) anyerror!void {
            const ctx: *CallContext = @ptrCast(@alignCast(ctx_ptr));
            var payload = try call.payloadTyped();
            var params_any = try payload.initContent();
            const params_builder = try params_any.initStruct(0, 1);
            var params = Params.Builder.wrap(params_builder);
            if (ctx.build) |build_fn| {
                try build_fn(ctx.user_ctx, &params);
            }
            _ = try call.initCapTableTyped(0);
        }

        fn callReturn(ctx_ptr: *anyopaque, peer: *rpc.peer.Peer, ret: rpc.protocol.Return, caps: *const rpc.cap_table.InboundCapTable) anyerror!void {
            const ctx: *CallContext = @ptrCast(@alignCast(ctx_ptr));
            defer peer.allocator.destroy(ctx);
            var response: Response = undefined;
            switch (ret.tag) {
                .results => {
                    const payload = ret.results orelse return error.MissingReturnPayload;
                    const struct_reader = try payload.content.getStruct();
                    const results = Results.Reader.wrap(struct_reader);
                    response = .{ .results = results };
                },
                .exception => {
                    const ex = ret.exception orelse return error.MissingException;
                    response = .{ .exception = ex };
                },
                .canceled => response = .canceled,
                .resultsSentElsewhere => response = .results_sent_elsewhere,
                .takeFromOtherQuestion => {
                    const qid = ret.take_from_other_question orelse return error.MissingQuestionId;
                    response = .{ .take_from_other_question = qid };
                },
                .awaitFromThirdParty => response = .accept_from_third_party,
            }
            try ctx.callback(ctx.user_ctx, peer, response, caps);
        }

        pub fn handleCallDirect(handler: Handler, deferred_handler: ?DeferredHandler, ctx: *anyopaque, peer: *rpc.peer.Peer, call: rpc.protocol.Call, caps: *const rpc.cap_table.InboundCapTable) anyerror!void {
            const params_struct = try call.params.content.getStruct();
            const params = Params.Reader.wrap(params_struct);
            if (deferred_handler) |deferred_fn| {
                const sender = ReturnSender{ .peer = peer, .question_id = call.question_id };
                try deferred_fn(ctx, peer, params, caps, sender);
            } else {
                var dctx = DirectReturnContext{
                    .handler = handler,
                    .ctx = ctx,
                    .peer = peer,
                    .params = params,
                    .caps = caps,
                };
                try peer.sendReturnResults(call.question_id, &dctx, buildReturnDirect);
            }
        }

        fn handleCall(server: *Server, peer: *rpc.peer.Peer, call: rpc.protocol.Call, caps: *const rpc.cap_table.InboundCapTable) anyerror!void {
            try handleCallDirect(server.vtable.writeBatch, server.vtable.writeBatch_deferred, server.ctx, peer, call, caps);
        }

        fn buildReturnDirect(ctx_ptr: *anyopaque, ret: *rpc.protocol.ReturnBuilder) anyerror!void {
            const dctx: *DirectReturnContext = @ptrCast(@alignCast(ctx_ptr));
            var payload = try ret.payloadTyped();
            var results_any = try payload.initContent();
            const results_builder = try results_any.initStruct(2, 1);
            var results = Results.Builder.wrap(results_builder);
            try dctx.handler(dctx.ctx, dctx.peer, dctx.params, &results, dctx.caps);
            _ = try ret.initCapTableTyped(0);
        }
    };

    pub const List = struct {
        pub const ordinal: u16 = 2;
        pub const is_streaming: bool = false;
        pub const Params = ListParams;
        pub const Results = ListResults;
        pub const BuildFn = *const fn (ctx: *anyopaque, params: *Params.Builder) anyerror!void;
        pub const Handler = *const fn (ctx: *anyopaque, peer: *rpc.peer.Peer, params: Params.Reader, results: *Results.Builder, caps: *const rpc.cap_table.InboundCapTable) anyerror!void;
        pub const DeferredHandler = *const fn (ctx: *anyopaque, peer: *rpc.peer.Peer, params: Params.Reader, caps: *const rpc.cap_table.InboundCapTable, sender: ReturnSender) anyerror!void;
        pub const Response = union(enum) {
            results: Results.Reader,
            exception: rpc.protocol.Exception,
            canceled,
            results_sent_elsewhere,
            take_from_other_question: u32,
            accept_from_third_party,
        };
        pub const Callback = *const fn (ctx: *anyopaque, peer: *rpc.peer.Peer, response: Response, caps: *const rpc.cap_table.InboundCapTable) anyerror!void;

        const CallContext = struct {
            user_ctx: *anyopaque,
            build: ?BuildFn,
            callback: Callback,
        };

        const DirectReturnContext = struct {
            handler: Handler,
            ctx: *anyopaque,
            peer: *rpc.peer.Peer,
            params: Params.Reader,
            caps: *const rpc.cap_table.InboundCapTable,
        };

        pub const ReturnSender = struct {
            peer: *rpc.peer.Peer,
            question_id: u32,

            pub fn sendResults(self: ReturnSender, ctx: *anyopaque, build: *const fn (ctx: *anyopaque, ret: *rpc.protocol.ReturnBuilder) anyerror!void) !void {
                try self.peer.sendReturnResults(self.question_id, ctx, build);
            }

            pub fn sendException(self: ReturnSender, reason: []const u8) !void {
                try self.peer.sendReturnException(self.question_id, reason);
            }
        };

        fn callBuild(ctx_ptr: *anyopaque, call: *rpc.protocol.CallBuilder) anyerror!void {
            const ctx: *CallContext = @ptrCast(@alignCast(ctx_ptr));
            var payload = try call.payloadTyped();
            var params_any = try payload.initContent();
            const params_builder = try params_any.initStruct(1, 1);
            var params = Params.Builder.wrap(params_builder);
            if (ctx.build) |build_fn| {
                try build_fn(ctx.user_ctx, &params);
            }
            _ = try call.initCapTableTyped(0);
        }

        fn callReturn(ctx_ptr: *anyopaque, peer: *rpc.peer.Peer, ret: rpc.protocol.Return, caps: *const rpc.cap_table.InboundCapTable) anyerror!void {
            const ctx: *CallContext = @ptrCast(@alignCast(ctx_ptr));
            defer peer.allocator.destroy(ctx);
            var response: Response = undefined;
            switch (ret.tag) {
                .results => {
                    const payload = ret.results orelse return error.MissingReturnPayload;
                    const struct_reader = try payload.content.getStruct();
                    const results = Results.Reader.wrap(struct_reader);
                    response = .{ .results = results };
                },
                .exception => {
                    const ex = ret.exception orelse return error.MissingException;
                    response = .{ .exception = ex };
                },
                .canceled => response = .canceled,
                .resultsSentElsewhere => response = .results_sent_elsewhere,
                .takeFromOtherQuestion => {
                    const qid = ret.take_from_other_question orelse return error.MissingQuestionId;
                    response = .{ .take_from_other_question = qid };
                },
                .awaitFromThirdParty => response = .accept_from_third_party,
            }
            try ctx.callback(ctx.user_ctx, peer, response, caps);
        }

        pub fn handleCallDirect(handler: Handler, deferred_handler: ?DeferredHandler, ctx: *anyopaque, peer: *rpc.peer.Peer, call: rpc.protocol.Call, caps: *const rpc.cap_table.InboundCapTable) anyerror!void {
            const params_struct = try call.params.content.getStruct();
            const params = Params.Reader.wrap(params_struct);
            if (deferred_handler) |deferred_fn| {
                const sender = ReturnSender{ .peer = peer, .question_id = call.question_id };
                try deferred_fn(ctx, peer, params, caps, sender);
            } else {
                var dctx = DirectReturnContext{
                    .handler = handler,
                    .ctx = ctx,
                    .peer = peer,
                    .params = params,
                    .caps = caps,
                };
                try peer.sendReturnResults(call.question_id, &dctx, buildReturnDirect);
            }
        }

        fn handleCall(server: *Server, peer: *rpc.peer.Peer, call: rpc.protocol.Call, caps: *const rpc.cap_table.InboundCapTable) anyerror!void {
            try handleCallDirect(server.vtable.list, server.vtable.list_deferred, server.ctx, peer, call, caps);
        }

        fn buildReturnDirect(ctx_ptr: *anyopaque, ret: *rpc.protocol.ReturnBuilder) anyerror!void {
            const dctx: *DirectReturnContext = @ptrCast(@alignCast(ctx_ptr));
            var payload = try ret.payloadTyped();
            var results_any = try payload.initContent();
            const results_builder = try results_any.initStruct(0, 1);
            var results = Results.Builder.wrap(results_builder);
            try dctx.handler(dctx.ctx, dctx.peer, dctx.params, &results, dctx.caps);
            _ = try ret.initCapTableTyped(0);
        }
    };

    pub const Subscribe = struct {
        pub const ordinal: u16 = 3;
        pub const is_streaming: bool = false;
        pub const Params = SubscribeParams;
        pub const Results = SubscribeResults;
        pub const BuildFn = *const fn (ctx: *anyopaque, params: *Params.Builder) anyerror!void;
        pub const Handler = *const fn (ctx: *anyopaque, peer: *rpc.peer.Peer, params: Params.Reader, results: *Results.Builder, caps: *const rpc.cap_table.InboundCapTable) anyerror!void;
        pub const DeferredHandler = *const fn (ctx: *anyopaque, peer: *rpc.peer.Peer, params: Params.Reader, caps: *const rpc.cap_table.InboundCapTable, sender: ReturnSender) anyerror!void;
        pub const Response = union(enum) {
            results: Results.Reader,
            exception: rpc.protocol.Exception,
            canceled,
            results_sent_elsewhere,
            take_from_other_question: u32,
            accept_from_third_party,
        };
        pub const Callback = *const fn (ctx: *anyopaque, peer: *rpc.peer.Peer, response: Response, caps: *const rpc.cap_table.InboundCapTable) anyerror!void;

        const CallContext = struct {
            user_ctx: *anyopaque,
            build: ?BuildFn,
            callback: Callback,
        };

        const DirectReturnContext = struct {
            handler: Handler,
            ctx: *anyopaque,
            peer: *rpc.peer.Peer,
            params: Params.Reader,
            caps: *const rpc.cap_table.InboundCapTable,
        };

        pub const ReturnSender = struct {
            peer: *rpc.peer.Peer,
            question_id: u32,

            pub fn sendResults(self: ReturnSender, ctx: *anyopaque, build: *const fn (ctx: *anyopaque, ret: *rpc.protocol.ReturnBuilder) anyerror!void) !void {
                try self.peer.sendReturnResults(self.question_id, ctx, build);
            }

            pub fn sendException(self: ReturnSender, reason: []const u8) !void {
                try self.peer.sendReturnException(self.question_id, reason);
            }
        };

        fn callBuild(ctx_ptr: *anyopaque, call: *rpc.protocol.CallBuilder) anyerror!void {
            const ctx: *CallContext = @ptrCast(@alignCast(ctx_ptr));
            var payload = try call.payloadTyped();
            var params_any = try payload.initContent();
            const params_builder = try params_any.initStruct(0, 1);
            var params = Params.Builder.wrap(params_builder);
            if (ctx.build) |build_fn| {
                try build_fn(ctx.user_ctx, &params);
            }
            _ = try call.initCapTableTyped(0);
        }

        fn callReturn(ctx_ptr: *anyopaque, peer: *rpc.peer.Peer, ret: rpc.protocol.Return, caps: *const rpc.cap_table.InboundCapTable) anyerror!void {
            const ctx: *CallContext = @ptrCast(@alignCast(ctx_ptr));
            defer peer.allocator.destroy(ctx);
            var response: Response = undefined;
            switch (ret.tag) {
                .results => {
                    const payload = ret.results orelse return error.MissingReturnPayload;
                    const struct_reader = try payload.content.getStruct();
                    const results = Results.Reader.wrap(struct_reader);
                    response = .{ .results = results };
                },
                .exception => {
                    const ex = ret.exception orelse return error.MissingException;
                    response = .{ .exception = ex };
                },
                .canceled => response = .canceled,
                .resultsSentElsewhere => response = .results_sent_elsewhere,
                .takeFromOtherQuestion => {
                    const qid = ret.take_from_other_question orelse return error.MissingQuestionId;
                    response = .{ .take_from_other_question = qid };
                },
                .awaitFromThirdParty => response = .accept_from_third_party,
            }
            try ctx.callback(ctx.user_ctx, peer, response, caps);
        }

        pub fn handleCallDirect(handler: Handler, deferred_handler: ?DeferredHandler, ctx: *anyopaque, peer: *rpc.peer.Peer, call: rpc.protocol.Call, caps: *const rpc.cap_table.InboundCapTable) anyerror!void {
            const params_struct = try call.params.content.getStruct();
            const params = Params.Reader.wrap(params_struct);
            if (deferred_handler) |deferred_fn| {
                const sender = ReturnSender{ .peer = peer, .question_id = call.question_id };
                try deferred_fn(ctx, peer, params, caps, sender);
            } else {
                var dctx = DirectReturnContext{
                    .handler = handler,
                    .ctx = ctx,
                    .peer = peer,
                    .params = params,
                    .caps = caps,
                };
                try peer.sendReturnResults(call.question_id, &dctx, buildReturnDirect);
            }
        }

        fn handleCall(server: *Server, peer: *rpc.peer.Peer, call: rpc.protocol.Call, caps: *const rpc.cap_table.InboundCapTable) anyerror!void {
            try handleCallDirect(server.vtable.subscribe, server.vtable.subscribe_deferred, server.ctx, peer, call, caps);
        }

        fn buildReturnDirect(ctx_ptr: *anyopaque, ret: *rpc.protocol.ReturnBuilder) anyerror!void {
            const dctx: *DirectReturnContext = @ptrCast(@alignCast(ctx_ptr));
            var payload = try ret.payloadTyped();
            var results_any = try payload.initContent();
            const results_builder = try results_any.initStruct(0, 0);
            var results = Results.Builder.wrap(results_builder);
            try dctx.handler(dctx.ctx, dctx.peer, dctx.params, &results, dctx.caps);
            _ = try ret.initCapTableTyped(0);
        }
    };

    pub const SetWatchedKeys = struct {
        pub const ordinal: u16 = 4;
        pub const is_streaming: bool = false;
        pub const Params = SetWatchedKeysParams;
        pub const Results = SetWatchedKeysResults;
        pub const BuildFn = *const fn (ctx: *anyopaque, params: *Params.Builder) anyerror!void;
        pub const Handler = *const fn (ctx: *anyopaque, peer: *rpc.peer.Peer, params: Params.Reader, results: *Results.Builder, caps: *const rpc.cap_table.InboundCapTable) anyerror!void;
        pub const DeferredHandler = *const fn (ctx: *anyopaque, peer: *rpc.peer.Peer, params: Params.Reader, caps: *const rpc.cap_table.InboundCapTable, sender: ReturnSender) anyerror!void;
        pub const Response = union(enum) {
            results: Results.Reader,
            exception: rpc.protocol.Exception,
            canceled,
            results_sent_elsewhere,
            take_from_other_question: u32,
            accept_from_third_party,
        };
        pub const Callback = *const fn (ctx: *anyopaque, peer: *rpc.peer.Peer, response: Response, caps: *const rpc.cap_table.InboundCapTable) anyerror!void;

        const CallContext = struct {
            user_ctx: *anyopaque,
            build: ?BuildFn,
            callback: Callback,
        };

        const DirectReturnContext = struct {
            handler: Handler,
            ctx: *anyopaque,
            peer: *rpc.peer.Peer,
            params: Params.Reader,
            caps: *const rpc.cap_table.InboundCapTable,
        };

        pub const ReturnSender = struct {
            peer: *rpc.peer.Peer,
            question_id: u32,

            pub fn sendResults(self: ReturnSender, ctx: *anyopaque, build: *const fn (ctx: *anyopaque, ret: *rpc.protocol.ReturnBuilder) anyerror!void) !void {
                try self.peer.sendReturnResults(self.question_id, ctx, build);
            }

            pub fn sendException(self: ReturnSender, reason: []const u8) !void {
                try self.peer.sendReturnException(self.question_id, reason);
            }
        };

        fn callBuild(ctx_ptr: *anyopaque, call: *rpc.protocol.CallBuilder) anyerror!void {
            const ctx: *CallContext = @ptrCast(@alignCast(ctx_ptr));
            var payload = try call.payloadTyped();
            var params_any = try payload.initContent();
            const params_builder = try params_any.initStruct(0, 1);
            var params = Params.Builder.wrap(params_builder);
            if (ctx.build) |build_fn| {
                try build_fn(ctx.user_ctx, &params);
            }
            _ = try call.initCapTableTyped(0);
        }

        fn callReturn(ctx_ptr: *anyopaque, peer: *rpc.peer.Peer, ret: rpc.protocol.Return, caps: *const rpc.cap_table.InboundCapTable) anyerror!void {
            const ctx: *CallContext = @ptrCast(@alignCast(ctx_ptr));
            defer peer.allocator.destroy(ctx);
            var response: Response = undefined;
            switch (ret.tag) {
                .results => {
                    const payload = ret.results orelse return error.MissingReturnPayload;
                    const struct_reader = try payload.content.getStruct();
                    const results = Results.Reader.wrap(struct_reader);
                    response = .{ .results = results };
                },
                .exception => {
                    const ex = ret.exception orelse return error.MissingException;
                    response = .{ .exception = ex };
                },
                .canceled => response = .canceled,
                .resultsSentElsewhere => response = .results_sent_elsewhere,
                .takeFromOtherQuestion => {
                    const qid = ret.take_from_other_question orelse return error.MissingQuestionId;
                    response = .{ .take_from_other_question = qid };
                },
                .awaitFromThirdParty => response = .accept_from_third_party,
            }
            try ctx.callback(ctx.user_ctx, peer, response, caps);
        }

        pub fn handleCallDirect(handler: Handler, deferred_handler: ?DeferredHandler, ctx: *anyopaque, peer: *rpc.peer.Peer, call: rpc.protocol.Call, caps: *const rpc.cap_table.InboundCapTable) anyerror!void {
            const params_struct = try call.params.content.getStruct();
            const params = Params.Reader.wrap(params_struct);
            if (deferred_handler) |deferred_fn| {
                const sender = ReturnSender{ .peer = peer, .question_id = call.question_id };
                try deferred_fn(ctx, peer, params, caps, sender);
            } else {
                var dctx = DirectReturnContext{
                    .handler = handler,
                    .ctx = ctx,
                    .peer = peer,
                    .params = params,
                    .caps = caps,
                };
                try peer.sendReturnResults(call.question_id, &dctx, buildReturnDirect);
            }
        }

        fn handleCall(server: *Server, peer: *rpc.peer.Peer, call: rpc.protocol.Call, caps: *const rpc.cap_table.InboundCapTable) anyerror!void {
            try handleCallDirect(server.vtable.setWatchedKeys, server.vtable.setWatchedKeys_deferred, server.ctx, peer, call, caps);
        }

        fn buildReturnDirect(ctx_ptr: *anyopaque, ret: *rpc.protocol.ReturnBuilder) anyerror!void {
            const dctx: *DirectReturnContext = @ptrCast(@alignCast(ctx_ptr));
            var payload = try ret.payloadTyped();
            var results_any = try payload.initContent();
            const results_builder = try results_any.initStruct(0, 0);
            var results = Results.Builder.wrap(results_builder);
            try dctx.handler(dctx.ctx, dctx.peer, dctx.params, &results, dctx.caps);
            _ = try ret.initCapTableTyped(0);
        }
    };

    pub const CreateBackup = struct {
        pub const ordinal: u16 = 5;
        pub const is_streaming: bool = false;
        pub const Params = CreateBackupParams;
        pub const Results = CreateBackupResults;
        pub const BuildFn = *const fn (ctx: *anyopaque, params: *Params.Builder) anyerror!void;
        pub const Handler = *const fn (ctx: *anyopaque, peer: *rpc.peer.Peer, params: Params.Reader, results: *Results.Builder, caps: *const rpc.cap_table.InboundCapTable) anyerror!void;
        pub const DeferredHandler = *const fn (ctx: *anyopaque, peer: *rpc.peer.Peer, params: Params.Reader, caps: *const rpc.cap_table.InboundCapTable, sender: ReturnSender) anyerror!void;
        pub const Response = union(enum) {
            results: Results.Reader,
            exception: rpc.protocol.Exception,
            canceled,
            results_sent_elsewhere,
            take_from_other_question: u32,
            accept_from_third_party,
        };
        pub const Callback = *const fn (ctx: *anyopaque, peer: *rpc.peer.Peer, response: Response, caps: *const rpc.cap_table.InboundCapTable) anyerror!void;

        const CallContext = struct {
            user_ctx: *anyopaque,
            build: ?BuildFn,
            callback: Callback,
        };

        const DirectReturnContext = struct {
            handler: Handler,
            ctx: *anyopaque,
            peer: *rpc.peer.Peer,
            params: Params.Reader,
            caps: *const rpc.cap_table.InboundCapTable,
        };

        pub const ReturnSender = struct {
            peer: *rpc.peer.Peer,
            question_id: u32,

            pub fn sendResults(self: ReturnSender, ctx: *anyopaque, build: *const fn (ctx: *anyopaque, ret: *rpc.protocol.ReturnBuilder) anyerror!void) !void {
                try self.peer.sendReturnResults(self.question_id, ctx, build);
            }

            pub fn sendException(self: ReturnSender, reason: []const u8) !void {
                try self.peer.sendReturnException(self.question_id, reason);
            }
        };

        fn callBuild(ctx_ptr: *anyopaque, call: *rpc.protocol.CallBuilder) anyerror!void {
            const ctx: *CallContext = @ptrCast(@alignCast(ctx_ptr));
            var payload = try call.payloadTyped();
            var params_any = try payload.initContent();
            const params_builder = try params_any.initStruct(1, 0);
            var params = Params.Builder.wrap(params_builder);
            if (ctx.build) |build_fn| {
                try build_fn(ctx.user_ctx, &params);
            }
            _ = try call.initCapTableTyped(0);
        }

        fn callReturn(ctx_ptr: *anyopaque, peer: *rpc.peer.Peer, ret: rpc.protocol.Return, caps: *const rpc.cap_table.InboundCapTable) anyerror!void {
            const ctx: *CallContext = @ptrCast(@alignCast(ctx_ptr));
            defer peer.allocator.destroy(ctx);
            var response: Response = undefined;
            switch (ret.tag) {
                .results => {
                    const payload = ret.results orelse return error.MissingReturnPayload;
                    const struct_reader = try payload.content.getStruct();
                    const results = Results.Reader.wrap(struct_reader);
                    response = .{ .results = results };
                },
                .exception => {
                    const ex = ret.exception orelse return error.MissingException;
                    response = .{ .exception = ex };
                },
                .canceled => response = .canceled,
                .resultsSentElsewhere => response = .results_sent_elsewhere,
                .takeFromOtherQuestion => {
                    const qid = ret.take_from_other_question orelse return error.MissingQuestionId;
                    response = .{ .take_from_other_question = qid };
                },
                .awaitFromThirdParty => response = .accept_from_third_party,
            }
            try ctx.callback(ctx.user_ctx, peer, response, caps);
        }

        pub fn handleCallDirect(handler: Handler, deferred_handler: ?DeferredHandler, ctx: *anyopaque, peer: *rpc.peer.Peer, call: rpc.protocol.Call, caps: *const rpc.cap_table.InboundCapTable) anyerror!void {
            const params_struct = try call.params.content.getStruct();
            const params = Params.Reader.wrap(params_struct);
            if (deferred_handler) |deferred_fn| {
                const sender = ReturnSender{ .peer = peer, .question_id = call.question_id };
                try deferred_fn(ctx, peer, params, caps, sender);
            } else {
                var dctx = DirectReturnContext{
                    .handler = handler,
                    .ctx = ctx,
                    .peer = peer,
                    .params = params,
                    .caps = caps,
                };
                try peer.sendReturnResults(call.question_id, &dctx, buildReturnDirect);
            }
        }

        fn handleCall(server: *Server, peer: *rpc.peer.Peer, call: rpc.protocol.Call, caps: *const rpc.cap_table.InboundCapTable) anyerror!void {
            try handleCallDirect(server.vtable.createBackup, server.vtable.createBackup_deferred, server.ctx, peer, call, caps);
        }

        fn buildReturnDirect(ctx_ptr: *anyopaque, ret: *rpc.protocol.ReturnBuilder) anyerror!void {
            const dctx: *DirectReturnContext = @ptrCast(@alignCast(ctx_ptr));
            var payload = try ret.payloadTyped();
            var results_any = try payload.initContent();
            const results_builder = try results_any.initStruct(1, 1);
            var results = Results.Builder.wrap(results_builder);
            try dctx.handler(dctx.ctx, dctx.peer, dctx.params, &results, dctx.caps);
            _ = try ret.initCapTableTyped(0);
        }
    };

    pub const ListBackups = struct {
        pub const ordinal: u16 = 6;
        pub const is_streaming: bool = false;
        pub const Params = ListBackupsParams;
        pub const Results = ListBackupsResults;
        pub const BuildFn = *const fn (ctx: *anyopaque, params: *Params.Builder) anyerror!void;
        pub const Handler = *const fn (ctx: *anyopaque, peer: *rpc.peer.Peer, params: Params.Reader, results: *Results.Builder, caps: *const rpc.cap_table.InboundCapTable) anyerror!void;
        pub const DeferredHandler = *const fn (ctx: *anyopaque, peer: *rpc.peer.Peer, params: Params.Reader, caps: *const rpc.cap_table.InboundCapTable, sender: ReturnSender) anyerror!void;
        pub const Response = union(enum) {
            results: Results.Reader,
            exception: rpc.protocol.Exception,
            canceled,
            results_sent_elsewhere,
            take_from_other_question: u32,
            accept_from_third_party,
        };
        pub const Callback = *const fn (ctx: *anyopaque, peer: *rpc.peer.Peer, response: Response, caps: *const rpc.cap_table.InboundCapTable) anyerror!void;

        const CallContext = struct {
            user_ctx: *anyopaque,
            build: ?BuildFn,
            callback: Callback,
        };

        const DirectReturnContext = struct {
            handler: Handler,
            ctx: *anyopaque,
            peer: *rpc.peer.Peer,
            params: Params.Reader,
            caps: *const rpc.cap_table.InboundCapTable,
        };

        pub const ReturnSender = struct {
            peer: *rpc.peer.Peer,
            question_id: u32,

            pub fn sendResults(self: ReturnSender, ctx: *anyopaque, build: *const fn (ctx: *anyopaque, ret: *rpc.protocol.ReturnBuilder) anyerror!void) !void {
                try self.peer.sendReturnResults(self.question_id, ctx, build);
            }

            pub fn sendException(self: ReturnSender, reason: []const u8) !void {
                try self.peer.sendReturnException(self.question_id, reason);
            }
        };

        fn callBuild(ctx_ptr: *anyopaque, call: *rpc.protocol.CallBuilder) anyerror!void {
            const ctx: *CallContext = @ptrCast(@alignCast(ctx_ptr));
            var payload = try call.payloadTyped();
            var params_any = try payload.initContent();
            const params_builder = try params_any.initStruct(0, 0);
            var params = Params.Builder.wrap(params_builder);
            if (ctx.build) |build_fn| {
                try build_fn(ctx.user_ctx, &params);
            }
            _ = try call.initCapTableTyped(0);
        }

        fn callReturn(ctx_ptr: *anyopaque, peer: *rpc.peer.Peer, ret: rpc.protocol.Return, caps: *const rpc.cap_table.InboundCapTable) anyerror!void {
            const ctx: *CallContext = @ptrCast(@alignCast(ctx_ptr));
            defer peer.allocator.destroy(ctx);
            var response: Response = undefined;
            switch (ret.tag) {
                .results => {
                    const payload = ret.results orelse return error.MissingReturnPayload;
                    const struct_reader = try payload.content.getStruct();
                    const results = Results.Reader.wrap(struct_reader);
                    response = .{ .results = results };
                },
                .exception => {
                    const ex = ret.exception orelse return error.MissingException;
                    response = .{ .exception = ex };
                },
                .canceled => response = .canceled,
                .resultsSentElsewhere => response = .results_sent_elsewhere,
                .takeFromOtherQuestion => {
                    const qid = ret.take_from_other_question orelse return error.MissingQuestionId;
                    response = .{ .take_from_other_question = qid };
                },
                .awaitFromThirdParty => response = .accept_from_third_party,
            }
            try ctx.callback(ctx.user_ctx, peer, response, caps);
        }

        pub fn handleCallDirect(handler: Handler, deferred_handler: ?DeferredHandler, ctx: *anyopaque, peer: *rpc.peer.Peer, call: rpc.protocol.Call, caps: *const rpc.cap_table.InboundCapTable) anyerror!void {
            const params_struct = try call.params.content.getStruct();
            const params = Params.Reader.wrap(params_struct);
            if (deferred_handler) |deferred_fn| {
                const sender = ReturnSender{ .peer = peer, .question_id = call.question_id };
                try deferred_fn(ctx, peer, params, caps, sender);
            } else {
                var dctx = DirectReturnContext{
                    .handler = handler,
                    .ctx = ctx,
                    .peer = peer,
                    .params = params,
                    .caps = caps,
                };
                try peer.sendReturnResults(call.question_id, &dctx, buildReturnDirect);
            }
        }

        fn handleCall(server: *Server, peer: *rpc.peer.Peer, call: rpc.protocol.Call, caps: *const rpc.cap_table.InboundCapTable) anyerror!void {
            try handleCallDirect(server.vtable.listBackups, server.vtable.listBackups_deferred, server.ctx, peer, call, caps);
        }

        fn buildReturnDirect(ctx_ptr: *anyopaque, ret: *rpc.protocol.ReturnBuilder) anyerror!void {
            const dctx: *DirectReturnContext = @ptrCast(@alignCast(ctx_ptr));
            var payload = try ret.payloadTyped();
            var results_any = try payload.initContent();
            const results_builder = try results_any.initStruct(0, 1);
            var results = Results.Builder.wrap(results_builder);
            try dctx.handler(dctx.ctx, dctx.peer, dctx.params, &results, dctx.caps);
            _ = try ret.initCapTableTyped(0);
        }
    };

    pub const RestoreFromBackup = struct {
        pub const ordinal: u16 = 7;
        pub const is_streaming: bool = false;
        pub const Params = RestoreFromBackupParams;
        pub const Results = RestoreFromBackupResults;
        pub const BuildFn = *const fn (ctx: *anyopaque, params: *Params.Builder) anyerror!void;
        pub const Handler = *const fn (ctx: *anyopaque, peer: *rpc.peer.Peer, params: Params.Reader, results: *Results.Builder, caps: *const rpc.cap_table.InboundCapTable) anyerror!void;
        pub const DeferredHandler = *const fn (ctx: *anyopaque, peer: *rpc.peer.Peer, params: Params.Reader, caps: *const rpc.cap_table.InboundCapTable, sender: ReturnSender) anyerror!void;
        pub const Response = union(enum) {
            results: Results.Reader,
            exception: rpc.protocol.Exception,
            canceled,
            results_sent_elsewhere,
            take_from_other_question: u32,
            accept_from_third_party,
        };
        pub const Callback = *const fn (ctx: *anyopaque, peer: *rpc.peer.Peer, response: Response, caps: *const rpc.cap_table.InboundCapTable) anyerror!void;

        const CallContext = struct {
            user_ctx: *anyopaque,
            build: ?BuildFn,
            callback: Callback,
        };

        const DirectReturnContext = struct {
            handler: Handler,
            ctx: *anyopaque,
            peer: *rpc.peer.Peer,
            params: Params.Reader,
            caps: *const rpc.cap_table.InboundCapTable,
        };

        pub const ReturnSender = struct {
            peer: *rpc.peer.Peer,
            question_id: u32,

            pub fn sendResults(self: ReturnSender, ctx: *anyopaque, build: *const fn (ctx: *anyopaque, ret: *rpc.protocol.ReturnBuilder) anyerror!void) !void {
                try self.peer.sendReturnResults(self.question_id, ctx, build);
            }

            pub fn sendException(self: ReturnSender, reason: []const u8) !void {
                try self.peer.sendReturnException(self.question_id, reason);
            }
        };

        fn callBuild(ctx_ptr: *anyopaque, call: *rpc.protocol.CallBuilder) anyerror!void {
            const ctx: *CallContext = @ptrCast(@alignCast(ctx_ptr));
            var payload = try call.payloadTyped();
            var params_any = try payload.initContent();
            const params_builder = try params_any.initStruct(1, 0);
            var params = Params.Builder.wrap(params_builder);
            if (ctx.build) |build_fn| {
                try build_fn(ctx.user_ctx, &params);
            }
            _ = try call.initCapTableTyped(0);
        }

        fn callReturn(ctx_ptr: *anyopaque, peer: *rpc.peer.Peer, ret: rpc.protocol.Return, caps: *const rpc.cap_table.InboundCapTable) anyerror!void {
            const ctx: *CallContext = @ptrCast(@alignCast(ctx_ptr));
            defer peer.allocator.destroy(ctx);
            var response: Response = undefined;
            switch (ret.tag) {
                .results => {
                    const payload = ret.results orelse return error.MissingReturnPayload;
                    const struct_reader = try payload.content.getStruct();
                    const results = Results.Reader.wrap(struct_reader);
                    response = .{ .results = results };
                },
                .exception => {
                    const ex = ret.exception orelse return error.MissingException;
                    response = .{ .exception = ex };
                },
                .canceled => response = .canceled,
                .resultsSentElsewhere => response = .results_sent_elsewhere,
                .takeFromOtherQuestion => {
                    const qid = ret.take_from_other_question orelse return error.MissingQuestionId;
                    response = .{ .take_from_other_question = qid };
                },
                .awaitFromThirdParty => response = .accept_from_third_party,
            }
            try ctx.callback(ctx.user_ctx, peer, response, caps);
        }

        pub fn handleCallDirect(handler: Handler, deferred_handler: ?DeferredHandler, ctx: *anyopaque, peer: *rpc.peer.Peer, call: rpc.protocol.Call, caps: *const rpc.cap_table.InboundCapTable) anyerror!void {
            const params_struct = try call.params.content.getStruct();
            const params = Params.Reader.wrap(params_struct);
            if (deferred_handler) |deferred_fn| {
                const sender = ReturnSender{ .peer = peer, .question_id = call.question_id };
                try deferred_fn(ctx, peer, params, caps, sender);
            } else {
                var dctx = DirectReturnContext{
                    .handler = handler,
                    .ctx = ctx,
                    .peer = peer,
                    .params = params,
                    .caps = caps,
                };
                try peer.sendReturnResults(call.question_id, &dctx, buildReturnDirect);
            }
        }

        fn handleCall(server: *Server, peer: *rpc.peer.Peer, call: rpc.protocol.Call, caps: *const rpc.cap_table.InboundCapTable) anyerror!void {
            try handleCallDirect(server.vtable.restoreFromBackup, server.vtable.restoreFromBackup_deferred, server.ctx, peer, call, caps);
        }

        fn buildReturnDirect(ctx_ptr: *anyopaque, ret: *rpc.protocol.ReturnBuilder) anyerror!void {
            const dctx: *DirectReturnContext = @ptrCast(@alignCast(ctx_ptr));
            var payload = try ret.payloadTyped();
            var results_any = try payload.initContent();
            const results_builder = try results_any.initStruct(2, 0);
            var results = Results.Builder.wrap(results_builder);
            try dctx.handler(dctx.ctx, dctx.peer, dctx.params, &results, dctx.caps);
            _ = try ret.initCapTableTyped(0);
        }
    };

    pub const Client = struct {
        peer: *rpc.peer.Peer,
        cap_id: u32,

        pub fn init(peer: *rpc.peer.Peer, cap_id: u32) Client {
            return .{ .peer = peer, .cap_id = cap_id };
        }

        pub fn callGet(self: *Client, user_ctx: *anyopaque, build: ?Get.BuildFn, on_return: Get.Callback) !u32 {
            const ctx = try self.peer.allocator.create(Get.CallContext);
            ctx.* = .{ .user_ctx = user_ctx, .build = build, .callback = on_return };
            return self.peer.sendCall(self.cap_id, interface_id, Get.ordinal, ctx, Get.callBuild, Get.callReturn);
        }

        pub fn callWriteBatch(self: *Client, user_ctx: *anyopaque, build: ?WriteBatch.BuildFn, on_return: WriteBatch.Callback) !u32 {
            const ctx = try self.peer.allocator.create(WriteBatch.CallContext);
            ctx.* = .{ .user_ctx = user_ctx, .build = build, .callback = on_return };
            return self.peer.sendCall(self.cap_id, interface_id, WriteBatch.ordinal, ctx, WriteBatch.callBuild, WriteBatch.callReturn);
        }

        pub fn callList(self: *Client, user_ctx: *anyopaque, build: ?List.BuildFn, on_return: List.Callback) !u32 {
            const ctx = try self.peer.allocator.create(List.CallContext);
            ctx.* = .{ .user_ctx = user_ctx, .build = build, .callback = on_return };
            return self.peer.sendCall(self.cap_id, interface_id, List.ordinal, ctx, List.callBuild, List.callReturn);
        }

        pub fn callSubscribe(self: *Client, user_ctx: *anyopaque, build: ?Subscribe.BuildFn, on_return: Subscribe.Callback) !u32 {
            const ctx = try self.peer.allocator.create(Subscribe.CallContext);
            ctx.* = .{ .user_ctx = user_ctx, .build = build, .callback = on_return };
            return self.peer.sendCall(self.cap_id, interface_id, Subscribe.ordinal, ctx, Subscribe.callBuild, Subscribe.callReturn);
        }

        pub fn callSetWatchedKeys(self: *Client, user_ctx: *anyopaque, build: ?SetWatchedKeys.BuildFn, on_return: SetWatchedKeys.Callback) !u32 {
            const ctx = try self.peer.allocator.create(SetWatchedKeys.CallContext);
            ctx.* = .{ .user_ctx = user_ctx, .build = build, .callback = on_return };
            return self.peer.sendCall(self.cap_id, interface_id, SetWatchedKeys.ordinal, ctx, SetWatchedKeys.callBuild, SetWatchedKeys.callReturn);
        }

        pub fn callCreateBackup(self: *Client, user_ctx: *anyopaque, build: ?CreateBackup.BuildFn, on_return: CreateBackup.Callback) !u32 {
            const ctx = try self.peer.allocator.create(CreateBackup.CallContext);
            ctx.* = .{ .user_ctx = user_ctx, .build = build, .callback = on_return };
            return self.peer.sendCall(self.cap_id, interface_id, CreateBackup.ordinal, ctx, CreateBackup.callBuild, CreateBackup.callReturn);
        }

        pub fn callListBackups(self: *Client, user_ctx: *anyopaque, build: ?ListBackups.BuildFn, on_return: ListBackups.Callback) !u32 {
            const ctx = try self.peer.allocator.create(ListBackups.CallContext);
            ctx.* = .{ .user_ctx = user_ctx, .build = build, .callback = on_return };
            return self.peer.sendCall(self.cap_id, interface_id, ListBackups.ordinal, ctx, ListBackups.callBuild, ListBackups.callReturn);
        }

        pub fn callRestoreFromBackup(self: *Client, user_ctx: *anyopaque, build: ?RestoreFromBackup.BuildFn, on_return: RestoreFromBackup.Callback) !u32 {
            const ctx = try self.peer.allocator.create(RestoreFromBackup.CallContext);
            ctx.* = .{ .user_ctx = user_ctx, .build = build, .callback = on_return };
            return self.peer.sendCall(self.cap_id, interface_id, RestoreFromBackup.ordinal, ctx, RestoreFromBackup.callBuild, RestoreFromBackup.callReturn);
        }

        pub fn fromBootstrap(peer: *rpc.peer.Peer, user_ctx: *anyopaque, callback: BootstrapCallback) !u32 {
            return bootstrap(peer, user_ctx, callback);
        }

    };

    pub const PipelinedClient = struct {
        peer: *rpc.peer.Peer,
        question_id: u32,
        pointer_index: u16,

        pub fn callGet(self: *PipelinedClient, user_ctx: *anyopaque, build: ?Get.BuildFn, on_return: Get.Callback) !u32 {
            const ctx = try self.peer.allocator.create(Get.CallContext);
            ctx.* = .{ .user_ctx = user_ctx, .build = build, .callback = on_return };
            return self.peer.sendCallPromisedWithOps(self.question_id, &[_]rpc.protocol.PromisedAnswerOp{.{ .tag = .getPointerField, .pointer_index = self.pointer_index }}, interface_id, Get.ordinal, ctx, Get.callBuild, Get.callReturn);
        }

        pub fn callWriteBatch(self: *PipelinedClient, user_ctx: *anyopaque, build: ?WriteBatch.BuildFn, on_return: WriteBatch.Callback) !u32 {
            const ctx = try self.peer.allocator.create(WriteBatch.CallContext);
            ctx.* = .{ .user_ctx = user_ctx, .build = build, .callback = on_return };
            return self.peer.sendCallPromisedWithOps(self.question_id, &[_]rpc.protocol.PromisedAnswerOp{.{ .tag = .getPointerField, .pointer_index = self.pointer_index }}, interface_id, WriteBatch.ordinal, ctx, WriteBatch.callBuild, WriteBatch.callReturn);
        }

        pub fn callList(self: *PipelinedClient, user_ctx: *anyopaque, build: ?List.BuildFn, on_return: List.Callback) !u32 {
            const ctx = try self.peer.allocator.create(List.CallContext);
            ctx.* = .{ .user_ctx = user_ctx, .build = build, .callback = on_return };
            return self.peer.sendCallPromisedWithOps(self.question_id, &[_]rpc.protocol.PromisedAnswerOp{.{ .tag = .getPointerField, .pointer_index = self.pointer_index }}, interface_id, List.ordinal, ctx, List.callBuild, List.callReturn);
        }

        pub fn callSubscribe(self: *PipelinedClient, user_ctx: *anyopaque, build: ?Subscribe.BuildFn, on_return: Subscribe.Callback) !u32 {
            const ctx = try self.peer.allocator.create(Subscribe.CallContext);
            ctx.* = .{ .user_ctx = user_ctx, .build = build, .callback = on_return };
            return self.peer.sendCallPromisedWithOps(self.question_id, &[_]rpc.protocol.PromisedAnswerOp{.{ .tag = .getPointerField, .pointer_index = self.pointer_index }}, interface_id, Subscribe.ordinal, ctx, Subscribe.callBuild, Subscribe.callReturn);
        }

        pub fn callSetWatchedKeys(self: *PipelinedClient, user_ctx: *anyopaque, build: ?SetWatchedKeys.BuildFn, on_return: SetWatchedKeys.Callback) !u32 {
            const ctx = try self.peer.allocator.create(SetWatchedKeys.CallContext);
            ctx.* = .{ .user_ctx = user_ctx, .build = build, .callback = on_return };
            return self.peer.sendCallPromisedWithOps(self.question_id, &[_]rpc.protocol.PromisedAnswerOp{.{ .tag = .getPointerField, .pointer_index = self.pointer_index }}, interface_id, SetWatchedKeys.ordinal, ctx, SetWatchedKeys.callBuild, SetWatchedKeys.callReturn);
        }

        pub fn callCreateBackup(self: *PipelinedClient, user_ctx: *anyopaque, build: ?CreateBackup.BuildFn, on_return: CreateBackup.Callback) !u32 {
            const ctx = try self.peer.allocator.create(CreateBackup.CallContext);
            ctx.* = .{ .user_ctx = user_ctx, .build = build, .callback = on_return };
            return self.peer.sendCallPromisedWithOps(self.question_id, &[_]rpc.protocol.PromisedAnswerOp{.{ .tag = .getPointerField, .pointer_index = self.pointer_index }}, interface_id, CreateBackup.ordinal, ctx, CreateBackup.callBuild, CreateBackup.callReturn);
        }

        pub fn callListBackups(self: *PipelinedClient, user_ctx: *anyopaque, build: ?ListBackups.BuildFn, on_return: ListBackups.Callback) !u32 {
            const ctx = try self.peer.allocator.create(ListBackups.CallContext);
            ctx.* = .{ .user_ctx = user_ctx, .build = build, .callback = on_return };
            return self.peer.sendCallPromisedWithOps(self.question_id, &[_]rpc.protocol.PromisedAnswerOp{.{ .tag = .getPointerField, .pointer_index = self.pointer_index }}, interface_id, ListBackups.ordinal, ctx, ListBackups.callBuild, ListBackups.callReturn);
        }

        pub fn callRestoreFromBackup(self: *PipelinedClient, user_ctx: *anyopaque, build: ?RestoreFromBackup.BuildFn, on_return: RestoreFromBackup.Callback) !u32 {
            const ctx = try self.peer.allocator.create(RestoreFromBackup.CallContext);
            ctx.* = .{ .user_ctx = user_ctx, .build = build, .callback = on_return };
            return self.peer.sendCallPromisedWithOps(self.question_id, &[_]rpc.protocol.PromisedAnswerOp{.{ .tag = .getPointerField, .pointer_index = self.pointer_index }}, interface_id, RestoreFromBackup.ordinal, ctx, RestoreFromBackup.callBuild, RestoreFromBackup.callReturn);
        }

    };

    pub const BootstrapResponse = union(enum) {
        client: Client,
        exception: rpc.protocol.Exception,
        canceled,
        results_sent_elsewhere,
        take_from_other_question: u32,
        accept_from_third_party,
    };
    pub const BootstrapCallback = *const fn (ctx: *anyopaque, peer: *rpc.peer.Peer, response: BootstrapResponse) anyerror!void;

    const BootstrapContext = struct {
        user_ctx: *anyopaque,
        callback: BootstrapCallback,
    };

    fn bootstrapReturn(ctx_ptr: *anyopaque, peer: *rpc.peer.Peer, ret: rpc.protocol.Return, caps: *const rpc.cap_table.InboundCapTable) anyerror!void {
        const ctx: *BootstrapContext = @ptrCast(@alignCast(ctx_ptr));
        defer peer.allocator.destroy(ctx);
        var response: BootstrapResponse = undefined;
        switch (ret.tag) {
            .results => {
                const payload = ret.results orelse return error.MissingReturnPayload;
                const cap = try payload.content.getCapability();
                var mutable_caps = caps.*;
                try mutable_caps.retainCapability(cap);
                const resolved = try caps.resolveCapability(cap);
                switch (resolved) {
                    .imported => |imported| response = .{ .client = Client.init(peer, imported.id) },
                    else => return error.UnexpectedBootstrapCapability,
                }
            },
            .exception => {
                const ex = ret.exception orelse return error.MissingException;
                response = .{ .exception = ex };
            },
            .canceled => response = .canceled,
            .resultsSentElsewhere => response = .results_sent_elsewhere,
            .takeFromOtherQuestion => {
                const qid = ret.take_from_other_question orelse return error.MissingQuestionId;
                response = .{ .take_from_other_question = qid };
            },
            .awaitFromThirdParty => response = .accept_from_third_party,
        }
        try ctx.callback(ctx.user_ctx, peer, response);
    }

    pub fn bootstrap(peer: *rpc.peer.Peer, user_ctx: *anyopaque, callback: BootstrapCallback) !u32 {
        const ctx = try peer.allocator.create(BootstrapContext);
        ctx.* = .{ .user_ctx = user_ctx, .callback = callback };
        return peer.sendBootstrap(ctx, bootstrapReturn);
    }

    pub const Server = struct {
        ctx: *anyopaque,
        vtable: VTable,
    };

    pub const VTable = struct {
        get: Get.Handler,
        get_deferred: ?Get.DeferredHandler = null,
        writeBatch: WriteBatch.Handler,
        writeBatch_deferred: ?WriteBatch.DeferredHandler = null,
        list: List.Handler,
        list_deferred: ?List.DeferredHandler = null,
        subscribe: Subscribe.Handler,
        subscribe_deferred: ?Subscribe.DeferredHandler = null,
        setWatchedKeys: SetWatchedKeys.Handler,
        setWatchedKeys_deferred: ?SetWatchedKeys.DeferredHandler = null,
        createBackup: CreateBackup.Handler,
        createBackup_deferred: ?CreateBackup.DeferredHandler = null,
        listBackups: ListBackups.Handler,
        listBackups_deferred: ?ListBackups.DeferredHandler = null,
        restoreFromBackup: RestoreFromBackup.Handler,
        restoreFromBackup_deferred: ?RestoreFromBackup.DeferredHandler = null,
    };

    pub fn exportServer(peer: *rpc.peer.Peer, server: *Server) !u32 {
        return peer.addExport(.{ .ctx = server, .on_call = onCall });
    }

    pub fn setBootstrap(peer: *rpc.peer.Peer, server: *Server) !u32 {
        return peer.setBootstrap(.{ .ctx = server, .on_call = onCall });
    }

    fn onCall(ctx: *anyopaque, peer: *rpc.peer.Peer, call: rpc.protocol.Call, caps: *const rpc.cap_table.InboundCapTable) anyerror!void {
        const server: *Server = @ptrCast(@alignCast(ctx));
        switch (call.method_id) {
            Get.ordinal => try Get.handleCall(server, peer, call, caps),
            WriteBatch.ordinal => try WriteBatch.handleCall(server, peer, call, caps),
            List.ordinal => try List.handleCall(server, peer, call, caps),
            Subscribe.ordinal => try Subscribe.handleCall(server, peer, call, caps),
            SetWatchedKeys.ordinal => try SetWatchedKeys.handleCall(server, peer, call, caps),
            CreateBackup.ordinal => try CreateBackup.handleCall(server, peer, call, caps),
            ListBackups.ordinal => try ListBackups.handleCall(server, peer, call, caps),
            RestoreFromBackup.ordinal => try RestoreFromBackup.handleCall(server, peer, call, caps),
            else => try peer.sendReturnException(call.question_id, "unknown method"),
        }
    }
};

pub const GetParams = struct {
    const EnumListReader = message.typed_list_helpers.EnumListReader;
    const EnumListBuilder = message.typed_list_helpers.EnumListBuilder;
    const StructListReader = message.typed_list_helpers.StructListReader;
    const StructListBuilder = message.typed_list_helpers.StructListBuilder;
    const DataListReader = message.typed_list_helpers.DataListReader;
    const DataListBuilder = message.typed_list_helpers.DataListBuilder;
    const CapabilityListReader = message.typed_list_helpers.CapabilityListReader;
    const CapabilityListBuilder = message.typed_list_helpers.CapabilityListBuilder;

    pub const Reader = struct {
        _reader: message.StructReader,

        pub fn init(msg: *const message.Message) !Reader {
            const root = try msg.getRootStruct();
            return .{ ._reader = root };
        }

        pub fn wrap(reader: message.StructReader) Reader {
            return .{ ._reader = reader };
        }

        pub fn getKey(self: Reader) ![]const u8 {
            if (self._reader.isPointerNull(0)) return "";
            return try self._reader.readText(0);
        }

    };

    pub const Builder = struct {
        _builder: message.StructBuilder,

        pub fn init(msg: *message.MessageBuilder) !Builder {
            const builder = try msg.allocateStruct(0, 1);
            return .{ ._builder = builder };
        }

        pub fn wrap(builder: message.StructBuilder) Builder {
            return .{ ._builder = builder };
        }

        pub fn setKey(self: *Builder, value: []const u8) !void {
            try self._builder.writeText(0, value);
        }

    };
};

pub const GetResults = struct {
    const EnumListReader = message.typed_list_helpers.EnumListReader;
    const EnumListBuilder = message.typed_list_helpers.EnumListBuilder;
    const StructListReader = message.typed_list_helpers.StructListReader;
    const StructListBuilder = message.typed_list_helpers.StructListBuilder;
    const DataListReader = message.typed_list_helpers.DataListReader;
    const DataListBuilder = message.typed_list_helpers.DataListBuilder;
    const CapabilityListReader = message.typed_list_helpers.CapabilityListReader;
    const CapabilityListBuilder = message.typed_list_helpers.CapabilityListBuilder;

    pub const Reader = struct {
        _reader: message.StructReader,

        pub fn init(msg: *const message.Message) !Reader {
            const root = try msg.getRootStruct();
            return .{ ._reader = root };
        }

        pub fn wrap(reader: message.StructReader) Reader {
            return .{ ._reader = reader };
        }

        pub fn getEntry(self: Reader) !Entry.Reader {
            const value = try self._reader.readStruct(0);
            return Entry.Reader{ ._reader = value };
        }

        pub fn getFound(self: Reader) !bool {
            return self._reader.readBool(0, 0) != false;
        }

    };

    pub const Builder = struct {
        _builder: message.StructBuilder,

        pub fn init(msg: *message.MessageBuilder) !Builder {
            const builder = try msg.allocateStruct(1, 1);
            return .{ ._builder = builder };
        }

        pub fn wrap(builder: message.StructBuilder) Builder {
            return .{ ._builder = builder };
        }

        pub fn initEntry(self: *Builder) !Entry.Builder {
            const builder = try self._builder.initStruct(0, 1, 2);
            return Entry.Builder{ ._builder = builder };
        }

        pub fn setFound(self: *Builder, value: bool) !void {
            self._builder.writeBool(0, 0, value != false);
        }

    };
};

pub const WriteBatchParams = struct {
    const EnumListReader = message.typed_list_helpers.EnumListReader;
    const EnumListBuilder = message.typed_list_helpers.EnumListBuilder;
    const StructListReader = message.typed_list_helpers.StructListReader;
    const StructListBuilder = message.typed_list_helpers.StructListBuilder;
    const DataListReader = message.typed_list_helpers.DataListReader;
    const DataListBuilder = message.typed_list_helpers.DataListBuilder;
    const CapabilityListReader = message.typed_list_helpers.CapabilityListReader;
    const CapabilityListBuilder = message.typed_list_helpers.CapabilityListBuilder;

    pub const Reader = struct {
        _reader: message.StructReader,

        pub fn init(msg: *const message.Message) !Reader {
            const root = try msg.getRootStruct();
            return .{ ._reader = root };
        }

        pub fn wrap(reader: message.StructReader) Reader {
            return .{ ._reader = reader };
        }

        pub fn getOps(self: Reader) !StructListReader(WriteOp) {
            const raw = try self._reader.readStructList(0);
            return StructListReader(WriteOp){ ._list = raw };
        }

    };

    pub const Builder = struct {
        _builder: message.StructBuilder,

        pub fn init(msg: *message.MessageBuilder) !Builder {
            const builder = try msg.allocateStruct(0, 1);
            return .{ ._builder = builder };
        }

        pub fn wrap(builder: message.StructBuilder) Builder {
            return .{ ._builder = builder };
        }

        pub fn initOps(self: *Builder, element_count: u32) !StructListBuilder(WriteOp) {
            const raw = try self._builder.writeStructList(0, element_count, 1, 2);
            return StructListBuilder(WriteOp){ ._list = raw };
        }

    };
};

pub const WriteBatchResults = struct {
    const EnumListReader = message.typed_list_helpers.EnumListReader;
    const EnumListBuilder = message.typed_list_helpers.EnumListBuilder;
    const StructListReader = message.typed_list_helpers.StructListReader;
    const StructListBuilder = message.typed_list_helpers.StructListBuilder;
    const DataListReader = message.typed_list_helpers.DataListReader;
    const DataListBuilder = message.typed_list_helpers.DataListBuilder;
    const CapabilityListReader = message.typed_list_helpers.CapabilityListReader;
    const CapabilityListBuilder = message.typed_list_helpers.CapabilityListBuilder;

    pub const Reader = struct {
        _reader: message.StructReader,

        pub fn init(msg: *const message.Message) !Reader {
            const root = try msg.getRootStruct();
            return .{ ._reader = root };
        }

        pub fn wrap(reader: message.StructReader) Reader {
            return .{ ._reader = reader };
        }

        pub fn getResults(self: Reader) !StructListReader(WriteOpResult) {
            const raw = try self._reader.readStructList(0);
            return StructListReader(WriteOpResult){ ._list = raw };
        }

        pub fn getApplied(self: Reader) !u32 {
            const raw = self._reader.readU32(0);
            const value = raw ^ @as(u32, 0);
            return value;
        }

        pub fn getNextVersion(self: Reader) !u64 {
            const raw = self._reader.readU64(8);
            const value = raw ^ @as(u64, 0);
            return value;
        }

    };

    pub const Builder = struct {
        _builder: message.StructBuilder,

        pub fn init(msg: *message.MessageBuilder) !Builder {
            const builder = try msg.allocateStruct(2, 1);
            return .{ ._builder = builder };
        }

        pub fn wrap(builder: message.StructBuilder) Builder {
            return .{ ._builder = builder };
        }

        pub fn initResults(self: *Builder, element_count: u32) !StructListBuilder(WriteOpResult) {
            const raw = try self._builder.writeStructList(0, element_count, 1, 2);
            return StructListBuilder(WriteOpResult){ ._list = raw };
        }

        pub fn setApplied(self: *Builder, value: u32) !void {
            const stored = @as(u32, @bitCast(value)) ^ @as(u32, 0);
            self._builder.writeU32(0, stored);
        }

        pub fn setNextVersion(self: *Builder, value: u64) !void {
            const stored = @as(u64, @bitCast(value)) ^ @as(u64, 0);
            self._builder.writeU64(8, stored);
        }

    };
};

pub const ListParams = struct {
    const EnumListReader = message.typed_list_helpers.EnumListReader;
    const EnumListBuilder = message.typed_list_helpers.EnumListBuilder;
    const StructListReader = message.typed_list_helpers.StructListReader;
    const StructListBuilder = message.typed_list_helpers.StructListBuilder;
    const DataListReader = message.typed_list_helpers.DataListReader;
    const DataListBuilder = message.typed_list_helpers.DataListBuilder;
    const CapabilityListReader = message.typed_list_helpers.CapabilityListReader;
    const CapabilityListBuilder = message.typed_list_helpers.CapabilityListBuilder;

    pub const Reader = struct {
        _reader: message.StructReader,

        pub fn init(msg: *const message.Message) !Reader {
            const root = try msg.getRootStruct();
            return .{ ._reader = root };
        }

        pub fn wrap(reader: message.StructReader) Reader {
            return .{ ._reader = reader };
        }

        pub fn getPrefix(self: Reader) ![]const u8 {
            if (self._reader.isPointerNull(0)) return "";
            return try self._reader.readText(0);
        }

        pub fn getLimit(self: Reader) !u32 {
            const raw = self._reader.readU32(0);
            const value = raw ^ @as(u32, 0);
            return value;
        }

    };

    pub const Builder = struct {
        _builder: message.StructBuilder,

        pub fn init(msg: *message.MessageBuilder) !Builder {
            const builder = try msg.allocateStruct(1, 1);
            return .{ ._builder = builder };
        }

        pub fn wrap(builder: message.StructBuilder) Builder {
            return .{ ._builder = builder };
        }

        pub fn setPrefix(self: *Builder, value: []const u8) !void {
            try self._builder.writeText(0, value);
        }

        pub fn setLimit(self: *Builder, value: u32) !void {
            const stored = @as(u32, @bitCast(value)) ^ @as(u32, 0);
            self._builder.writeU32(0, stored);
        }

    };
};

pub const ListResults = struct {
    const EnumListReader = message.typed_list_helpers.EnumListReader;
    const EnumListBuilder = message.typed_list_helpers.EnumListBuilder;
    const StructListReader = message.typed_list_helpers.StructListReader;
    const StructListBuilder = message.typed_list_helpers.StructListBuilder;
    const DataListReader = message.typed_list_helpers.DataListReader;
    const DataListBuilder = message.typed_list_helpers.DataListBuilder;
    const CapabilityListReader = message.typed_list_helpers.CapabilityListReader;
    const CapabilityListBuilder = message.typed_list_helpers.CapabilityListBuilder;

    pub const Reader = struct {
        _reader: message.StructReader,

        pub fn init(msg: *const message.Message) !Reader {
            const root = try msg.getRootStruct();
            return .{ ._reader = root };
        }

        pub fn wrap(reader: message.StructReader) Reader {
            return .{ ._reader = reader };
        }

        pub fn getEntries(self: Reader) !StructListReader(Entry) {
            const raw = try self._reader.readStructList(0);
            return StructListReader(Entry){ ._list = raw };
        }

    };

    pub const Builder = struct {
        _builder: message.StructBuilder,

        pub fn init(msg: *message.MessageBuilder) !Builder {
            const builder = try msg.allocateStruct(0, 1);
            return .{ ._builder = builder };
        }

        pub fn wrap(builder: message.StructBuilder) Builder {
            return .{ ._builder = builder };
        }

        pub fn initEntries(self: *Builder, element_count: u32) !StructListBuilder(Entry) {
            const raw = try self._builder.writeStructList(0, element_count, 1, 2);
            return StructListBuilder(Entry){ ._list = raw };
        }

    };
};

pub const SubscribeParams = struct {
    const EnumListReader = message.typed_list_helpers.EnumListReader;
    const EnumListBuilder = message.typed_list_helpers.EnumListBuilder;
    const StructListReader = message.typed_list_helpers.StructListReader;
    const StructListBuilder = message.typed_list_helpers.StructListBuilder;
    const DataListReader = message.typed_list_helpers.DataListReader;
    const DataListBuilder = message.typed_list_helpers.DataListBuilder;
    const CapabilityListReader = message.typed_list_helpers.CapabilityListReader;
    const CapabilityListBuilder = message.typed_list_helpers.CapabilityListBuilder;

    pub const Reader = struct {
        _reader: message.StructReader,

        pub fn init(msg: *const message.Message) !Reader {
            const root = try msg.getRootStruct();
            return .{ ._reader = root };
        }

        pub fn wrap(reader: message.StructReader) Reader {
            return .{ ._reader = reader };
        }

        pub fn getNotifier(self: Reader) !message.Capability {
            return try self._reader.readCapability(0);
        }

        pub fn resolveNotifier(self: Reader, peer: *rpc.peer.Peer, caps: *const rpc.cap_table.InboundCapTable) !KvClientNotifier.Client {
            const cap = try self._reader.readCapability(0);
            var mutable_caps = caps.*;
            try mutable_caps.retainCapability(cap);
            const resolved = try caps.resolveCapability(cap);
            switch (resolved) {
                .imported => |imported| return KvClientNotifier.Client.init(peer, imported.id),
                else => return error.UnexpectedCapabilityType,
            }
        }

    };

    pub const Builder = struct {
        _builder: message.StructBuilder,

        pub fn init(msg: *message.MessageBuilder) !Builder {
            const builder = try msg.allocateStruct(0, 1);
            return .{ ._builder = builder };
        }

        pub fn wrap(builder: message.StructBuilder) Builder {
            return .{ ._builder = builder };
        }

        pub fn initNotifier(self: *Builder) !message.AnyPointerBuilder {
            return try self._builder.getAnyPointer(0);
        }

        pub fn clearNotifier(self: *Builder) !void {
            var any = try self._builder.getAnyPointer(0);
            try any.setNull();
        }

        pub fn setNotifierCapability(self: *Builder, cap: message.Capability) !void {
            var any = try self._builder.getAnyPointer(0);
            try any.setCapability(cap);
        }

        pub fn setNotifierServer(self: *Builder, peer: *rpc.peer.Peer, server: *KvClientNotifier.Server) !void {
            const cap_id = try KvClientNotifier.exportServer(peer, server);
            var any = try self._builder.getAnyPointer(0);
            try any.setCapability(.{ .id = cap_id });
        }

        pub fn setNotifierClient(self: *Builder, client: KvClientNotifier.Client) !void {
            var any = try self._builder.getAnyPointer(0);
            try any.setCapability(.{ .id = client.cap_id });
        }

    };
};

pub const SubscribeResults = struct {
    const EnumListReader = message.typed_list_helpers.EnumListReader;
    const EnumListBuilder = message.typed_list_helpers.EnumListBuilder;
    const StructListReader = message.typed_list_helpers.StructListReader;
    const StructListBuilder = message.typed_list_helpers.StructListBuilder;
    const DataListReader = message.typed_list_helpers.DataListReader;
    const DataListBuilder = message.typed_list_helpers.DataListBuilder;
    const CapabilityListReader = message.typed_list_helpers.CapabilityListReader;
    const CapabilityListBuilder = message.typed_list_helpers.CapabilityListBuilder;

    pub const Reader = struct {
        _reader: message.StructReader,

        pub fn init(msg: *const message.Message) !Reader {
            const root = try msg.getRootStruct();
            return .{ ._reader = root };
        }

        pub fn wrap(reader: message.StructReader) Reader {
            return .{ ._reader = reader };
        }

    };

    pub const Builder = struct {
        _builder: message.StructBuilder,

        pub fn init(msg: *message.MessageBuilder) !Builder {
            const builder = try msg.allocateStruct(0, 0);
            return .{ ._builder = builder };
        }

        pub fn wrap(builder: message.StructBuilder) Builder {
            return .{ ._builder = builder };
        }

    };
};

pub const SetWatchedKeysParams = struct {
    const EnumListReader = message.typed_list_helpers.EnumListReader;
    const EnumListBuilder = message.typed_list_helpers.EnumListBuilder;
    const StructListReader = message.typed_list_helpers.StructListReader;
    const StructListBuilder = message.typed_list_helpers.StructListBuilder;
    const DataListReader = message.typed_list_helpers.DataListReader;
    const DataListBuilder = message.typed_list_helpers.DataListBuilder;
    const CapabilityListReader = message.typed_list_helpers.CapabilityListReader;
    const CapabilityListBuilder = message.typed_list_helpers.CapabilityListBuilder;

    pub const Reader = struct {
        _reader: message.StructReader,

        pub fn init(msg: *const message.Message) !Reader {
            const root = try msg.getRootStruct();
            return .{ ._reader = root };
        }

        pub fn wrap(reader: message.StructReader) Reader {
            return .{ ._reader = reader };
        }

        pub fn getKeys(self: Reader) !message.TextListReader {
            return try self._reader.readTextList(0);
        }

    };

    pub const Builder = struct {
        _builder: message.StructBuilder,

        pub fn init(msg: *message.MessageBuilder) !Builder {
            const builder = try msg.allocateStruct(0, 1);
            return .{ ._builder = builder };
        }

        pub fn wrap(builder: message.StructBuilder) Builder {
            return .{ ._builder = builder };
        }

        pub fn initKeys(self: *Builder, element_count: u32) !message.TextListBuilder {
            return try self._builder.writeTextList(0, element_count);
        }

    };
};

pub const SetWatchedKeysResults = struct {
    const EnumListReader = message.typed_list_helpers.EnumListReader;
    const EnumListBuilder = message.typed_list_helpers.EnumListBuilder;
    const StructListReader = message.typed_list_helpers.StructListReader;
    const StructListBuilder = message.typed_list_helpers.StructListBuilder;
    const DataListReader = message.typed_list_helpers.DataListReader;
    const DataListBuilder = message.typed_list_helpers.DataListBuilder;
    const CapabilityListReader = message.typed_list_helpers.CapabilityListReader;
    const CapabilityListBuilder = message.typed_list_helpers.CapabilityListBuilder;

    pub const Reader = struct {
        _reader: message.StructReader,

        pub fn init(msg: *const message.Message) !Reader {
            const root = try msg.getRootStruct();
            return .{ ._reader = root };
        }

        pub fn wrap(reader: message.StructReader) Reader {
            return .{ ._reader = reader };
        }

    };

    pub const Builder = struct {
        _builder: message.StructBuilder,

        pub fn init(msg: *message.MessageBuilder) !Builder {
            const builder = try msg.allocateStruct(0, 0);
            return .{ ._builder = builder };
        }

        pub fn wrap(builder: message.StructBuilder) Builder {
            return .{ ._builder = builder };
        }

    };
};

pub const CreateBackupParams = struct {
    const EnumListReader = message.typed_list_helpers.EnumListReader;
    const EnumListBuilder = message.typed_list_helpers.EnumListBuilder;
    const StructListReader = message.typed_list_helpers.StructListReader;
    const StructListBuilder = message.typed_list_helpers.StructListBuilder;
    const DataListReader = message.typed_list_helpers.DataListReader;
    const DataListBuilder = message.typed_list_helpers.DataListBuilder;
    const CapabilityListReader = message.typed_list_helpers.CapabilityListReader;
    const CapabilityListBuilder = message.typed_list_helpers.CapabilityListBuilder;

    pub const Reader = struct {
        _reader: message.StructReader,

        pub fn init(msg: *const message.Message) !Reader {
            const root = try msg.getRootStruct();
            return .{ ._reader = root };
        }

        pub fn wrap(reader: message.StructReader) Reader {
            return .{ ._reader = reader };
        }

        pub fn getFlushBeforeBackup(self: Reader) !bool {
            return self._reader.readBool(0, 0) != false;
        }

    };

    pub const Builder = struct {
        _builder: message.StructBuilder,

        pub fn init(msg: *message.MessageBuilder) !Builder {
            const builder = try msg.allocateStruct(1, 0);
            return .{ ._builder = builder };
        }

        pub fn wrap(builder: message.StructBuilder) Builder {
            return .{ ._builder = builder };
        }

        pub fn setFlushBeforeBackup(self: *Builder, value: bool) !void {
            self._builder.writeBool(0, 0, value != false);
        }

    };
};

pub const CreateBackupResults = struct {
    const EnumListReader = message.typed_list_helpers.EnumListReader;
    const EnumListBuilder = message.typed_list_helpers.EnumListBuilder;
    const StructListReader = message.typed_list_helpers.StructListReader;
    const StructListBuilder = message.typed_list_helpers.StructListBuilder;
    const DataListReader = message.typed_list_helpers.DataListReader;
    const DataListBuilder = message.typed_list_helpers.DataListBuilder;
    const CapabilityListReader = message.typed_list_helpers.CapabilityListReader;
    const CapabilityListBuilder = message.typed_list_helpers.CapabilityListBuilder;

    pub const Reader = struct {
        _reader: message.StructReader,

        pub fn init(msg: *const message.Message) !Reader {
            const root = try msg.getRootStruct();
            return .{ ._reader = root };
        }

        pub fn wrap(reader: message.StructReader) Reader {
            return .{ ._reader = reader };
        }

        pub fn getBackup(self: Reader) !BackupInfo.Reader {
            const value = try self._reader.readStruct(0);
            return BackupInfo.Reader{ ._reader = value };
        }

        pub fn getBackupCount(self: Reader) !u32 {
            const raw = self._reader.readU32(0);
            const value = raw ^ @as(u32, 0);
            return value;
        }

    };

    pub const Builder = struct {
        _builder: message.StructBuilder,

        pub fn init(msg: *message.MessageBuilder) !Builder {
            const builder = try msg.allocateStruct(1, 1);
            return .{ ._builder = builder };
        }

        pub fn wrap(builder: message.StructBuilder) Builder {
            return .{ ._builder = builder };
        }

        pub fn initBackup(self: *Builder) !BackupInfo.Builder {
            const builder = try self._builder.initStruct(0, 3, 0);
            return BackupInfo.Builder{ ._builder = builder };
        }

        pub fn setBackupCount(self: *Builder, value: u32) !void {
            const stored = @as(u32, @bitCast(value)) ^ @as(u32, 0);
            self._builder.writeU32(0, stored);
        }

    };
};

pub const ListBackupsParams = struct {
    const EnumListReader = message.typed_list_helpers.EnumListReader;
    const EnumListBuilder = message.typed_list_helpers.EnumListBuilder;
    const StructListReader = message.typed_list_helpers.StructListReader;
    const StructListBuilder = message.typed_list_helpers.StructListBuilder;
    const DataListReader = message.typed_list_helpers.DataListReader;
    const DataListBuilder = message.typed_list_helpers.DataListBuilder;
    const CapabilityListReader = message.typed_list_helpers.CapabilityListReader;
    const CapabilityListBuilder = message.typed_list_helpers.CapabilityListBuilder;

    pub const Reader = struct {
        _reader: message.StructReader,

        pub fn init(msg: *const message.Message) !Reader {
            const root = try msg.getRootStruct();
            return .{ ._reader = root };
        }

        pub fn wrap(reader: message.StructReader) Reader {
            return .{ ._reader = reader };
        }

    };

    pub const Builder = struct {
        _builder: message.StructBuilder,

        pub fn init(msg: *message.MessageBuilder) !Builder {
            const builder = try msg.allocateStruct(0, 0);
            return .{ ._builder = builder };
        }

        pub fn wrap(builder: message.StructBuilder) Builder {
            return .{ ._builder = builder };
        }

    };
};

pub const ListBackupsResults = struct {
    const EnumListReader = message.typed_list_helpers.EnumListReader;
    const EnumListBuilder = message.typed_list_helpers.EnumListBuilder;
    const StructListReader = message.typed_list_helpers.StructListReader;
    const StructListBuilder = message.typed_list_helpers.StructListBuilder;
    const DataListReader = message.typed_list_helpers.DataListReader;
    const DataListBuilder = message.typed_list_helpers.DataListBuilder;
    const CapabilityListReader = message.typed_list_helpers.CapabilityListReader;
    const CapabilityListBuilder = message.typed_list_helpers.CapabilityListBuilder;

    pub const Reader = struct {
        _reader: message.StructReader,

        pub fn init(msg: *const message.Message) !Reader {
            const root = try msg.getRootStruct();
            return .{ ._reader = root };
        }

        pub fn wrap(reader: message.StructReader) Reader {
            return .{ ._reader = reader };
        }

        pub fn getBackups(self: Reader) !StructListReader(BackupInfo) {
            const raw = try self._reader.readStructList(0);
            return StructListReader(BackupInfo){ ._list = raw };
        }

    };

    pub const Builder = struct {
        _builder: message.StructBuilder,

        pub fn init(msg: *message.MessageBuilder) !Builder {
            const builder = try msg.allocateStruct(0, 1);
            return .{ ._builder = builder };
        }

        pub fn wrap(builder: message.StructBuilder) Builder {
            return .{ ._builder = builder };
        }

        pub fn initBackups(self: *Builder, element_count: u32) !StructListBuilder(BackupInfo) {
            const raw = try self._builder.writeStructList(0, element_count, 3, 0);
            return StructListBuilder(BackupInfo){ ._list = raw };
        }

    };
};

pub const RestoreFromBackupParams = struct {
    const EnumListReader = message.typed_list_helpers.EnumListReader;
    const EnumListBuilder = message.typed_list_helpers.EnumListBuilder;
    const StructListReader = message.typed_list_helpers.StructListReader;
    const StructListBuilder = message.typed_list_helpers.StructListBuilder;
    const DataListReader = message.typed_list_helpers.DataListReader;
    const DataListBuilder = message.typed_list_helpers.DataListBuilder;
    const CapabilityListReader = message.typed_list_helpers.CapabilityListReader;
    const CapabilityListBuilder = message.typed_list_helpers.CapabilityListBuilder;

    pub const Reader = struct {
        _reader: message.StructReader,

        pub fn init(msg: *const message.Message) !Reader {
            const root = try msg.getRootStruct();
            return .{ ._reader = root };
        }

        pub fn wrap(reader: message.StructReader) Reader {
            return .{ ._reader = reader };
        }

        pub fn getBackupId(self: Reader) !u32 {
            const raw = self._reader.readU32(0);
            const value = raw ^ @as(u32, 0);
            return value;
        }

        pub fn getKeepLogFiles(self: Reader) !bool {
            return self._reader.readBool(4, 0) != false;
        }

    };

    pub const Builder = struct {
        _builder: message.StructBuilder,

        pub fn init(msg: *message.MessageBuilder) !Builder {
            const builder = try msg.allocateStruct(1, 0);
            return .{ ._builder = builder };
        }

        pub fn wrap(builder: message.StructBuilder) Builder {
            return .{ ._builder = builder };
        }

        pub fn setBackupId(self: *Builder, value: u32) !void {
            const stored = @as(u32, @bitCast(value)) ^ @as(u32, 0);
            self._builder.writeU32(0, stored);
        }

        pub fn setKeepLogFiles(self: *Builder, value: bool) !void {
            self._builder.writeBool(4, 0, value != false);
        }

    };
};

pub const RestoreFromBackupResults = struct {
    const EnumListReader = message.typed_list_helpers.EnumListReader;
    const EnumListBuilder = message.typed_list_helpers.EnumListBuilder;
    const StructListReader = message.typed_list_helpers.StructListReader;
    const StructListBuilder = message.typed_list_helpers.StructListBuilder;
    const DataListReader = message.typed_list_helpers.DataListReader;
    const DataListBuilder = message.typed_list_helpers.DataListBuilder;
    const CapabilityListReader = message.typed_list_helpers.CapabilityListReader;
    const CapabilityListBuilder = message.typed_list_helpers.CapabilityListBuilder;

    pub const Reader = struct {
        _reader: message.StructReader,

        pub fn init(msg: *const message.Message) !Reader {
            const root = try msg.getRootStruct();
            return .{ ._reader = root };
        }

        pub fn wrap(reader: message.StructReader) Reader {
            return .{ ._reader = reader };
        }

        pub fn getRestoredBackupId(self: Reader) !u32 {
            const raw = self._reader.readU32(0);
            const value = raw ^ @as(u32, 0);
            return value;
        }

        pub fn getNextVersion(self: Reader) !u64 {
            const raw = self._reader.readU64(8);
            const value = raw ^ @as(u64, 0);
            return value;
        }

    };

    pub const Builder = struct {
        _builder: message.StructBuilder,

        pub fn init(msg: *message.MessageBuilder) !Builder {
            const builder = try msg.allocateStruct(2, 0);
            return .{ ._builder = builder };
        }

        pub fn wrap(builder: message.StructBuilder) Builder {
            return .{ ._builder = builder };
        }

        pub fn setRestoredBackupId(self: *Builder, value: u32) !void {
            const stored = @as(u32, @bitCast(value)) ^ @as(u32, 0);
            self._builder.writeU32(0, stored);
        }

        pub fn setNextVersion(self: *Builder, value: u64) !void {
            const stored = @as(u64, @bitCast(value)) ^ @as(u64, 0);
            self._builder.writeU64(8, stored);
        }

    };
};

