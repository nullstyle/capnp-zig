// Generated by capnpc-zig
// Source: chat.capnp

const std = @import("std");
const capnpc = @import("capnpc-zig");
const message = capnpc.message;
const schema = capnpc.schema;
const rpc = capnpc.rpc;
const game_types = @import("game_types.zig");

pub const PlayerId = game_types.PlayerId;
pub const PlayerInfo = game_types.PlayerInfo;
pub const Timestamp = game_types.Timestamp;
pub const StatusCode = game_types.StatusCode;
pub const Faction = game_types.Faction;

pub const RoomId = struct {
    fn EnumListReader(comptime EnumType: type) type {
        return struct {
            _list: message.U16ListReader,

            pub fn len(self: @This()) u32 {
                return self._list.len();
            }

            pub fn get(self: @This(), index: u32) !EnumType {
                return @enumFromInt(try self._list.get(index));
            }

            pub fn raw(self: @This()) message.U16ListReader {
                return self._list;
            }
        };
    }

    fn EnumListBuilder(comptime EnumType: type) type {
        return struct {
            _list: message.U16ListBuilder,

            pub fn len(self: @This()) u32 {
                return self._list.len();
            }

            pub fn set(self: @This(), index: u32, value: EnumType) !void {
                try self._list.set(index, @intFromEnum(value));
            }

            pub fn raw(self: @This()) message.U16ListBuilder {
                return self._list;
            }
        };
    }

    fn StructListReader(comptime StructType: type) type {
        return struct {
            _list: message.StructListReader,

            pub fn len(self: @This()) u32 {
                return self._list.len();
            }

            pub fn get(self: @This(), index: u32) !StructType.Reader {
                const item = try self._list.get(index);
                return StructType.Reader.wrap(item);
            }

            pub fn raw(self: @This()) message.StructListReader {
                return self._list;
            }
        };
    }

    fn StructListBuilder(comptime StructType: type) type {
        return struct {
            _list: message.StructListBuilder,

            pub fn len(self: @This()) u32 {
                return self._list.len();
            }

            pub fn get(self: @This(), index: u32) !StructType.Builder {
                const item = try self._list.get(index);
                return StructType.Builder.wrap(item);
            }

            pub fn raw(self: @This()) message.StructListBuilder {
                return self._list;
            }
        };
    }

    const DataListReader = struct {
        _list: message.PointerListReader,

        pub fn len(self: @This()) u32 {
            return self._list.len();
        }

        pub fn get(self: @This(), index: u32) ![]const u8 {
            return try self._list.getData(index);
        }

        pub fn raw(self: @This()) message.PointerListReader {
            return self._list;
        }
    };

    const DataListBuilder = struct {
        _list: message.PointerListBuilder,

        pub fn len(self: @This()) u32 {
            return self._list.len();
        }

        pub fn set(self: @This(), index: u32, value: []const u8) !void {
            try self._list.setData(index, value);
        }

        pub fn setNull(self: @This(), index: u32) !void {
            try self._list.setNull(index);
        }

        pub fn raw(self: @This()) message.PointerListBuilder {
            return self._list;
        }
    };

    const CapabilityListReader = struct {
        _list: message.PointerListReader,

        pub fn len(self: @This()) u32 {
            return self._list.len();
        }

        pub fn get(self: @This(), index: u32) !message.Capability {
            return try self._list.getCapability(index);
        }

        pub fn raw(self: @This()) message.PointerListReader {
            return self._list;
        }
    };

    const CapabilityListBuilder = struct {
        _list: message.PointerListBuilder,

        pub fn len(self: @This()) u32 {
            return self._list.len();
        }

        pub fn set(self: @This(), index: u32, cap: message.Capability) !void {
            try self._list.setCapability(index, cap);
        }

        pub fn setNull(self: @This(), index: u32) !void {
            try self._list.setNull(index);
        }

        pub fn raw(self: @This()) message.PointerListBuilder {
            return self._list;
        }
    };

    pub const Reader = struct {
        _reader: message.StructReader,

        pub fn init(msg: *const message.Message) !Reader {
            const root = try msg.getRootStruct();
            return .{ ._reader = root };
        }

        pub fn wrap(reader: message.StructReader) Reader {
            return .{ ._reader = reader };
        }

        pub fn getId(self: Reader) !u64 {
            const raw = self._reader.readU64(0);
            const value = raw ^ @as(u64, 0);
            return value;
        }
    };

    pub const Builder = struct {
        _builder: message.StructBuilder,

        pub fn init(msg: *message.MessageBuilder) !Builder {
            const builder = try msg.allocateStruct(1, 0);
            return .{ ._builder = builder };
        }

        pub fn wrap(builder: message.StructBuilder) Builder {
            return .{ ._builder = builder };
        }

        pub fn setId(self: *Builder, value: u64) !void {
            const stored = @as(u64, @bitCast(value)) ^ @as(u64, 0);
            self._builder.writeU64(0, stored);
        }
    };
};

pub const ChatMessage = struct {
    fn EnumListReader(comptime EnumType: type) type {
        return struct {
            _list: message.U16ListReader,

            pub fn len(self: @This()) u32 {
                return self._list.len();
            }

            pub fn get(self: @This(), index: u32) !EnumType {
                return @enumFromInt(try self._list.get(index));
            }

            pub fn raw(self: @This()) message.U16ListReader {
                return self._list;
            }
        };
    }

    fn EnumListBuilder(comptime EnumType: type) type {
        return struct {
            _list: message.U16ListBuilder,

            pub fn len(self: @This()) u32 {
                return self._list.len();
            }

            pub fn set(self: @This(), index: u32, value: EnumType) !void {
                try self._list.set(index, @intFromEnum(value));
            }

            pub fn raw(self: @This()) message.U16ListBuilder {
                return self._list;
            }
        };
    }

    fn StructListReader(comptime StructType: type) type {
        return struct {
            _list: message.StructListReader,

            pub fn len(self: @This()) u32 {
                return self._list.len();
            }

            pub fn get(self: @This(), index: u32) !StructType.Reader {
                const item = try self._list.get(index);
                return StructType.Reader.wrap(item);
            }

            pub fn raw(self: @This()) message.StructListReader {
                return self._list;
            }
        };
    }

    fn StructListBuilder(comptime StructType: type) type {
        return struct {
            _list: message.StructListBuilder,

            pub fn len(self: @This()) u32 {
                return self._list.len();
            }

            pub fn get(self: @This(), index: u32) !StructType.Builder {
                const item = try self._list.get(index);
                return StructType.Builder.wrap(item);
            }

            pub fn raw(self: @This()) message.StructListBuilder {
                return self._list;
            }
        };
    }

    const DataListReader = struct {
        _list: message.PointerListReader,

        pub fn len(self: @This()) u32 {
            return self._list.len();
        }

        pub fn get(self: @This(), index: u32) ![]const u8 {
            return try self._list.getData(index);
        }

        pub fn raw(self: @This()) message.PointerListReader {
            return self._list;
        }
    };

    const DataListBuilder = struct {
        _list: message.PointerListBuilder,

        pub fn len(self: @This()) u32 {
            return self._list.len();
        }

        pub fn set(self: @This(), index: u32, value: []const u8) !void {
            try self._list.setData(index, value);
        }

        pub fn setNull(self: @This(), index: u32) !void {
            try self._list.setNull(index);
        }

        pub fn raw(self: @This()) message.PointerListBuilder {
            return self._list;
        }
    };

    const CapabilityListReader = struct {
        _list: message.PointerListReader,

        pub fn len(self: @This()) u32 {
            return self._list.len();
        }

        pub fn get(self: @This(), index: u32) !message.Capability {
            return try self._list.getCapability(index);
        }

        pub fn raw(self: @This()) message.PointerListReader {
            return self._list;
        }
    };

    const CapabilityListBuilder = struct {
        _list: message.PointerListBuilder,

        pub fn len(self: @This()) u32 {
            return self._list.len();
        }

        pub fn set(self: @This(), index: u32, cap: message.Capability) !void {
            try self._list.setCapability(index, cap);
        }

        pub fn setNull(self: @This(), index: u32) !void {
            try self._list.setNull(index);
        }

        pub fn raw(self: @This()) message.PointerListBuilder {
            return self._list;
        }
    };

    pub const Reader = struct {
        _reader: message.StructReader,

        pub fn init(msg: *const message.Message) !Reader {
            const root = try msg.getRootStruct();
            return .{ ._reader = root };
        }

        pub fn wrap(reader: message.StructReader) Reader {
            return .{ ._reader = reader };
        }

        pub fn getSender(self: Reader) !PlayerInfo.Reader {
            const value = try self._reader.readStruct(0);
            return PlayerInfo.Reader{ ._reader = value };
        }

        pub fn getContent(self: Reader) ![]const u8 {
            if (self._reader.isPointerNull(1)) return "";
            return try self._reader.readText(1);
        }

        pub fn getTimestamp(self: Reader) !Timestamp.Reader {
            const value = try self._reader.readStruct(2);
            return Timestamp.Reader{ ._reader = value };
        }
    };

    pub const Builder = struct {
        _builder: message.StructBuilder,

        pub fn init(msg: *message.MessageBuilder) !Builder {
            const builder = try msg.allocateStruct(1, 4);
            return .{ ._builder = builder };
        }

        pub fn wrap(builder: message.StructBuilder) Builder {
            return .{ ._builder = builder };
        }

        pub fn initSender(self: *Builder) !PlayerInfo.Builder {
            const builder = try self._builder.initStruct(0, 1, 2);
            return PlayerInfo.Builder{ ._builder = builder };
        }

        pub fn setContent(self: *Builder, value: []const u8) !void {
            try self._builder.writeText(1, value);
        }

        pub fn initTimestamp(self: *Builder) !Timestamp.Builder {
            const builder = try self._builder.initStruct(2, 1, 0);
            return Timestamp.Builder{ ._builder = builder };
        }
    };
};

pub const RoomInfo = struct {
    fn EnumListReader(comptime EnumType: type) type {
        return struct {
            _list: message.U16ListReader,

            pub fn len(self: @This()) u32 {
                return self._list.len();
            }

            pub fn get(self: @This(), index: u32) !EnumType {
                return @enumFromInt(try self._list.get(index));
            }

            pub fn raw(self: @This()) message.U16ListReader {
                return self._list;
            }
        };
    }

    fn EnumListBuilder(comptime EnumType: type) type {
        return struct {
            _list: message.U16ListBuilder,

            pub fn len(self: @This()) u32 {
                return self._list.len();
            }

            pub fn set(self: @This(), index: u32, value: EnumType) !void {
                try self._list.set(index, @intFromEnum(value));
            }

            pub fn raw(self: @This()) message.U16ListBuilder {
                return self._list;
            }
        };
    }

    fn StructListReader(comptime StructType: type) type {
        return struct {
            _list: message.StructListReader,

            pub fn len(self: @This()) u32 {
                return self._list.len();
            }

            pub fn get(self: @This(), index: u32) !StructType.Reader {
                const item = try self._list.get(index);
                return StructType.Reader.wrap(item);
            }

            pub fn raw(self: @This()) message.StructListReader {
                return self._list;
            }
        };
    }

    fn StructListBuilder(comptime StructType: type) type {
        return struct {
            _list: message.StructListBuilder,

            pub fn len(self: @This()) u32 {
                return self._list.len();
            }

            pub fn get(self: @This(), index: u32) !StructType.Builder {
                const item = try self._list.get(index);
                return StructType.Builder.wrap(item);
            }

            pub fn raw(self: @This()) message.StructListBuilder {
                return self._list;
            }
        };
    }

    const DataListReader = struct {
        _list: message.PointerListReader,

        pub fn len(self: @This()) u32 {
            return self._list.len();
        }

        pub fn get(self: @This(), index: u32) ![]const u8 {
            return try self._list.getData(index);
        }

        pub fn raw(self: @This()) message.PointerListReader {
            return self._list;
        }
    };

    const DataListBuilder = struct {
        _list: message.PointerListBuilder,

        pub fn len(self: @This()) u32 {
            return self._list.len();
        }

        pub fn set(self: @This(), index: u32, value: []const u8) !void {
            try self._list.setData(index, value);
        }

        pub fn setNull(self: @This(), index: u32) !void {
            try self._list.setNull(index);
        }

        pub fn raw(self: @This()) message.PointerListBuilder {
            return self._list;
        }
    };

    const CapabilityListReader = struct {
        _list: message.PointerListReader,

        pub fn len(self: @This()) u32 {
            return self._list.len();
        }

        pub fn get(self: @This(), index: u32) !message.Capability {
            return try self._list.getCapability(index);
        }

        pub fn raw(self: @This()) message.PointerListReader {
            return self._list;
        }
    };

    const CapabilityListBuilder = struct {
        _list: message.PointerListBuilder,

        pub fn len(self: @This()) u32 {
            return self._list.len();
        }

        pub fn set(self: @This(), index: u32, cap: message.Capability) !void {
            try self._list.setCapability(index, cap);
        }

        pub fn setNull(self: @This(), index: u32) !void {
            try self._list.setNull(index);
        }

        pub fn raw(self: @This()) message.PointerListBuilder {
            return self._list;
        }
    };

    pub const Reader = struct {
        _reader: message.StructReader,

        pub fn init(msg: *const message.Message) !Reader {
            const root = try msg.getRootStruct();
            return .{ ._reader = root };
        }

        pub fn wrap(reader: message.StructReader) Reader {
            return .{ ._reader = reader };
        }

        pub fn getId(self: Reader) !RoomId.Reader {
            const value = try self._reader.readStruct(0);
            return RoomId.Reader{ ._reader = value };
        }

        pub fn getName(self: Reader) ![]const u8 {
            if (self._reader.isPointerNull(1)) return "";
            return try self._reader.readText(1);
        }

        pub fn getMemberCount(self: Reader) !u32 {
            const raw = self._reader.readU32(0);
            const value = raw ^ @as(u32, 0);
            return value;
        }

        pub fn getTopic(self: Reader) ![]const u8 {
            if (self._reader.isPointerNull(2)) return "";
            return try self._reader.readText(2);
        }
    };

    pub const Builder = struct {
        _builder: message.StructBuilder,

        pub fn init(msg: *message.MessageBuilder) !Builder {
            const builder = try msg.allocateStruct(1, 3);
            return .{ ._builder = builder };
        }

        pub fn wrap(builder: message.StructBuilder) Builder {
            return .{ ._builder = builder };
        }

        pub fn initId(self: *Builder) !RoomId.Builder {
            const builder = try self._builder.initStruct(0, 1, 0);
            return RoomId.Builder{ ._builder = builder };
        }

        pub fn setName(self: *Builder, value: []const u8) !void {
            try self._builder.writeText(1, value);
        }

        pub fn setMemberCount(self: *Builder, value: u32) !void {
            const stored = @as(u32, @bitCast(value)) ^ @as(u32, 0);
            self._builder.writeU32(0, stored);
        }

        pub fn setTopic(self: *Builder, value: []const u8) !void {
            try self._builder.writeText(2, value);
        }
    };
};

pub const ChatRoom = struct {
    pub const interface_id: u64 = 0x92e90bb78b1d47a7;
    pub const Method = enum(u16) {
        SendMessage = 0,
        SendEmote = 1,
        GetHistory = 2,
        GetInfo = 3,
        Leave = 4,
    };

    pub const SendMessage = struct {
        pub const ordinal: u16 = 0;
        pub const Params = SendMessageParams;
        pub const Results = SendMessageResults;
        pub const BuildFn = *const fn (ctx: *anyopaque, params: *Params.Builder) anyerror!void;
        pub const Handler = *const fn (ctx: *anyopaque, peer: *rpc.peer.Peer, params: Params.Reader, results: *Results.Builder, caps: *const rpc.cap_table.InboundCapTable) anyerror!void;
        pub const Response = union(enum) {
            results: Results.Reader,
            exception: rpc.protocol.Exception,
            canceled,
            results_sent_elsewhere,
            take_from_other_question: u32,
            accept_from_third_party,
        };
        pub const Callback = *const fn (ctx: *anyopaque, peer: *rpc.peer.Peer, response: Response, caps: *const rpc.cap_table.InboundCapTable) anyerror!void;

        const CallContext = struct {
            user_ctx: *anyopaque,
            build: ?BuildFn,
            callback: Callback,
        };

        const ReturnContext = struct {
            server: *Server,
            peer: *rpc.peer.Peer,
            params: Params.Reader,
            caps: *const rpc.cap_table.InboundCapTable,
        };

        fn callBuild(ctx_ptr: *anyopaque, call: *rpc.protocol.CallBuilder) anyerror!void {
            const ctx: *CallContext = @ptrCast(@alignCast(ctx_ptr));
            var params_builder_payload = try call.payloadTyped();
            var params_builder_any = try params_builder_payload.initContent();
            const params_builder = try params_builder_any.initStruct(0, 1);

            var params = Params.Builder.wrap(params_builder);
            if (ctx.build) |build_fn| {
                try build_fn(ctx.user_ctx, &params);
            }
            _ = try call.initCapTableTyped(0);
        }

        fn callReturn(ctx_ptr: *anyopaque, peer: *rpc.peer.Peer, ret: rpc.protocol.Return, caps: *const rpc.cap_table.InboundCapTable) anyerror!void {
            const ctx: *CallContext = @ptrCast(@alignCast(ctx_ptr));
            defer peer.allocator.destroy(ctx);
            var response: Response = undefined;
            switch (ret.tag) {
                .results => {
                    const payload = ret.results orelse return error.MissingReturnPayload;
                    const struct_reader = try payload.content.getStruct();
                    const results = Results.Reader.wrap(struct_reader);
                    response = .{ .results = results };
                },
                .exception => {
                    const ex = ret.exception orelse return error.MissingException;
                    response = .{ .exception = ex };
                },
                .canceled => response = .canceled,
                .resultsSentElsewhere => response = .resultsSentElsewhere,
                .take_from_other_question => {
                    const qid = ret.take_from_other_question orelse return error.MissingQuestionId;
                    response = .{ .take_from_other_question = qid };
                },
                .accept_from_third_party => response = .accept_from_third_party,
            }
            try ctx.callback(ctx.user_ctx, peer, response, caps);
        }

        fn handleCall(server: *Server, peer: *rpc.peer.Peer, call: rpc.protocol.Call, caps: *const rpc.cap_table.InboundCapTable) anyerror!void {
            const params_struct = try call.params.content.getStruct();
            const params = Params.Reader.wrap(params_struct);
            var ctx = ReturnContext{
                .server = server,
                .peer = peer,
                .params = params,
                .caps = caps,
            };
            try peer.sendReturnResults(call.question_id, &ctx, buildReturn);
        }

        fn buildReturn(ctx_ptr: *anyopaque, ret: *rpc.protocol.ReturnBuilder) anyerror!void {
            const ctx: *ReturnContext = @ptrCast(@alignCast(ctx_ptr));
            var results_builder_payload = try ret.payloadTyped();
            var results_builder_any = try results_builder_payload.initContent();
            const results_builder = try results_builder_any.initStruct(1, 1);

            var results = Results.Builder.wrap(results_builder);
            try ctx.server.vtable.sendMessage(ctx.server.ctx, ctx.peer, ctx.params, &results, ctx.caps);
            _ = try ret.initCapTableTyped(0);
        }
    };

    pub const SendEmote = struct {
        pub const ordinal: u16 = 1;
        pub const Params = SendEmoteParams;
        pub const Results = SendEmoteResults;
        pub const BuildFn = *const fn (ctx: *anyopaque, params: *Params.Builder) anyerror!void;
        pub const Handler = *const fn (ctx: *anyopaque, peer: *rpc.peer.Peer, params: Params.Reader, results: *Results.Builder, caps: *const rpc.cap_table.InboundCapTable) anyerror!void;
        pub const Response = union(enum) {
            results: Results.Reader,
            exception: rpc.protocol.Exception,
            canceled,
            results_sent_elsewhere,
            take_from_other_question: u32,
            accept_from_third_party,
        };
        pub const Callback = *const fn (ctx: *anyopaque, peer: *rpc.peer.Peer, response: Response, caps: *const rpc.cap_table.InboundCapTable) anyerror!void;

        const CallContext = struct {
            user_ctx: *anyopaque,
            build: ?BuildFn,
            callback: Callback,
        };

        const ReturnContext = struct {
            server: *Server,
            peer: *rpc.peer.Peer,
            params: Params.Reader,
            caps: *const rpc.cap_table.InboundCapTable,
        };

        fn callBuild(ctx_ptr: *anyopaque, call: *rpc.protocol.CallBuilder) anyerror!void {
            const ctx: *CallContext = @ptrCast(@alignCast(ctx_ptr));
            var params_builder_payload = try call.payloadTyped();
            var params_builder_any = try params_builder_payload.initContent();
            const params_builder = try params_builder_any.initStruct(0, 1);

            var params = Params.Builder.wrap(params_builder);
            if (ctx.build) |build_fn| {
                try build_fn(ctx.user_ctx, &params);
            }
            _ = try call.initCapTableTyped(0);
        }

        fn callReturn(ctx_ptr: *anyopaque, peer: *rpc.peer.Peer, ret: rpc.protocol.Return, caps: *const rpc.cap_table.InboundCapTable) anyerror!void {
            const ctx: *CallContext = @ptrCast(@alignCast(ctx_ptr));
            defer peer.allocator.destroy(ctx);
            var response: Response = undefined;
            switch (ret.tag) {
                .results => {
                    const payload = ret.results orelse return error.MissingReturnPayload;
                    const struct_reader = try payload.content.getStruct();
                    const results = Results.Reader.wrap(struct_reader);
                    response = .{ .results = results };
                },
                .exception => {
                    const ex = ret.exception orelse return error.MissingException;
                    response = .{ .exception = ex };
                },
                .canceled => response = .canceled,
                .resultsSentElsewhere => response = .resultsSentElsewhere,
                .take_from_other_question => {
                    const qid = ret.take_from_other_question orelse return error.MissingQuestionId;
                    response = .{ .take_from_other_question = qid };
                },
                .accept_from_third_party => response = .accept_from_third_party,
            }
            try ctx.callback(ctx.user_ctx, peer, response, caps);
        }

        fn handleCall(server: *Server, peer: *rpc.peer.Peer, call: rpc.protocol.Call, caps: *const rpc.cap_table.InboundCapTable) anyerror!void {
            const params_struct = try call.params.content.getStruct();
            const params = Params.Reader.wrap(params_struct);
            var ctx = ReturnContext{
                .server = server,
                .peer = peer,
                .params = params,
                .caps = caps,
            };
            try peer.sendReturnResults(call.question_id, &ctx, buildReturn);
        }

        fn buildReturn(ctx_ptr: *anyopaque, ret: *rpc.protocol.ReturnBuilder) anyerror!void {
            const ctx: *ReturnContext = @ptrCast(@alignCast(ctx_ptr));
            var results_builder_payload = try ret.payloadTyped();
            var results_builder_any = try results_builder_payload.initContent();
            const results_builder = try results_builder_any.initStruct(1, 1);

            var results = Results.Builder.wrap(results_builder);
            try ctx.server.vtable.sendEmote(ctx.server.ctx, ctx.peer, ctx.params, &results, ctx.caps);
            _ = try ret.initCapTableTyped(0);
        }
    };

    pub const GetHistory = struct {
        pub const ordinal: u16 = 2;
        pub const Params = GetHistoryParams;
        pub const Results = GetHistoryResults;
        pub const BuildFn = *const fn (ctx: *anyopaque, params: *Params.Builder) anyerror!void;
        pub const Handler = *const fn (ctx: *anyopaque, peer: *rpc.peer.Peer, params: Params.Reader, results: *Results.Builder, caps: *const rpc.cap_table.InboundCapTable) anyerror!void;
        pub const Response = union(enum) {
            results: Results.Reader,
            exception: rpc.protocol.Exception,
            canceled,
            results_sent_elsewhere,
            take_from_other_question: u32,
            accept_from_third_party,
        };
        pub const Callback = *const fn (ctx: *anyopaque, peer: *rpc.peer.Peer, response: Response, caps: *const rpc.cap_table.InboundCapTable) anyerror!void;

        const CallContext = struct {
            user_ctx: *anyopaque,
            build: ?BuildFn,
            callback: Callback,
        };

        const ReturnContext = struct {
            server: *Server,
            peer: *rpc.peer.Peer,
            params: Params.Reader,
            caps: *const rpc.cap_table.InboundCapTable,
        };

        fn callBuild(ctx_ptr: *anyopaque, call: *rpc.protocol.CallBuilder) anyerror!void {
            const ctx: *CallContext = @ptrCast(@alignCast(ctx_ptr));
            var params_builder_payload = try call.payloadTyped();
            var params_builder_any = try params_builder_payload.initContent();
            const params_builder = try params_builder_any.initStruct(1, 0);

            var params = Params.Builder.wrap(params_builder);
            if (ctx.build) |build_fn| {
                try build_fn(ctx.user_ctx, &params);
            }
            _ = try call.initCapTableTyped(0);
        }

        fn callReturn(ctx_ptr: *anyopaque, peer: *rpc.peer.Peer, ret: rpc.protocol.Return, caps: *const rpc.cap_table.InboundCapTable) anyerror!void {
            const ctx: *CallContext = @ptrCast(@alignCast(ctx_ptr));
            defer peer.allocator.destroy(ctx);
            var response: Response = undefined;
            switch (ret.tag) {
                .results => {
                    const payload = ret.results orelse return error.MissingReturnPayload;
                    const struct_reader = try payload.content.getStruct();
                    const results = Results.Reader.wrap(struct_reader);
                    response = .{ .results = results };
                },
                .exception => {
                    const ex = ret.exception orelse return error.MissingException;
                    response = .{ .exception = ex };
                },
                .canceled => response = .canceled,
                .resultsSentElsewhere => response = .resultsSentElsewhere,
                .take_from_other_question => {
                    const qid = ret.take_from_other_question orelse return error.MissingQuestionId;
                    response = .{ .take_from_other_question = qid };
                },
                .accept_from_third_party => response = .accept_from_third_party,
            }
            try ctx.callback(ctx.user_ctx, peer, response, caps);
        }

        fn handleCall(server: *Server, peer: *rpc.peer.Peer, call: rpc.protocol.Call, caps: *const rpc.cap_table.InboundCapTable) anyerror!void {
            const params_struct = try call.params.content.getStruct();
            const params = Params.Reader.wrap(params_struct);
            var ctx = ReturnContext{
                .server = server,
                .peer = peer,
                .params = params,
                .caps = caps,
            };
            try peer.sendReturnResults(call.question_id, &ctx, buildReturn);
        }

        fn buildReturn(ctx_ptr: *anyopaque, ret: *rpc.protocol.ReturnBuilder) anyerror!void {
            const ctx: *ReturnContext = @ptrCast(@alignCast(ctx_ptr));
            var results_builder_payload = try ret.payloadTyped();
            var results_builder_any = try results_builder_payload.initContent();
            const results_builder = try results_builder_any.initStruct(0, 1);

            var results = Results.Builder.wrap(results_builder);
            try ctx.server.vtable.getHistory(ctx.server.ctx, ctx.peer, ctx.params, &results, ctx.caps);
            _ = try ret.initCapTableTyped(0);
        }
    };

    pub const GetInfo = struct {
        pub const ordinal: u16 = 3;
        pub const Params = GetInfoParams;
        pub const Results = GetInfoResults;
        pub const BuildFn = *const fn (ctx: *anyopaque, params: *Params.Builder) anyerror!void;
        pub const Handler = *const fn (ctx: *anyopaque, peer: *rpc.peer.Peer, params: Params.Reader, results: *Results.Builder, caps: *const rpc.cap_table.InboundCapTable) anyerror!void;
        pub const Response = union(enum) {
            results: Results.Reader,
            exception: rpc.protocol.Exception,
            canceled,
            results_sent_elsewhere,
            take_from_other_question: u32,
            accept_from_third_party,
        };
        pub const Callback = *const fn (ctx: *anyopaque, peer: *rpc.peer.Peer, response: Response, caps: *const rpc.cap_table.InboundCapTable) anyerror!void;

        const CallContext = struct {
            user_ctx: *anyopaque,
            build: ?BuildFn,
            callback: Callback,
        };

        const ReturnContext = struct {
            server: *Server,
            peer: *rpc.peer.Peer,
            params: Params.Reader,
            caps: *const rpc.cap_table.InboundCapTable,
        };

        fn callBuild(ctx_ptr: *anyopaque, call: *rpc.protocol.CallBuilder) anyerror!void {
            const ctx: *CallContext = @ptrCast(@alignCast(ctx_ptr));
            var params_builder_payload = try call.payloadTyped();
            var params_builder_any = try params_builder_payload.initContent();
            const params_builder = try params_builder_any.initStruct(0, 0);

            var params = Params.Builder.wrap(params_builder);
            if (ctx.build) |build_fn| {
                try build_fn(ctx.user_ctx, &params);
            }
            _ = try call.initCapTableTyped(0);
        }

        fn callReturn(ctx_ptr: *anyopaque, peer: *rpc.peer.Peer, ret: rpc.protocol.Return, caps: *const rpc.cap_table.InboundCapTable) anyerror!void {
            const ctx: *CallContext = @ptrCast(@alignCast(ctx_ptr));
            defer peer.allocator.destroy(ctx);
            var response: Response = undefined;
            switch (ret.tag) {
                .results => {
                    const payload = ret.results orelse return error.MissingReturnPayload;
                    const struct_reader = try payload.content.getStruct();
                    const results = Results.Reader.wrap(struct_reader);
                    response = .{ .results = results };
                },
                .exception => {
                    const ex = ret.exception orelse return error.MissingException;
                    response = .{ .exception = ex };
                },
                .canceled => response = .canceled,
                .resultsSentElsewhere => response = .resultsSentElsewhere,
                .take_from_other_question => {
                    const qid = ret.take_from_other_question orelse return error.MissingQuestionId;
                    response = .{ .take_from_other_question = qid };
                },
                .accept_from_third_party => response = .accept_from_third_party,
            }
            try ctx.callback(ctx.user_ctx, peer, response, caps);
        }

        fn handleCall(server: *Server, peer: *rpc.peer.Peer, call: rpc.protocol.Call, caps: *const rpc.cap_table.InboundCapTable) anyerror!void {
            const params_struct = try call.params.content.getStruct();
            const params = Params.Reader.wrap(params_struct);
            var ctx = ReturnContext{
                .server = server,
                .peer = peer,
                .params = params,
                .caps = caps,
            };
            try peer.sendReturnResults(call.question_id, &ctx, buildReturn);
        }

        fn buildReturn(ctx_ptr: *anyopaque, ret: *rpc.protocol.ReturnBuilder) anyerror!void {
            const ctx: *ReturnContext = @ptrCast(@alignCast(ctx_ptr));
            var results_builder_payload = try ret.payloadTyped();
            var results_builder_any = try results_builder_payload.initContent();
            const results_builder = try results_builder_any.initStruct(0, 1);

            var results = Results.Builder.wrap(results_builder);
            try ctx.server.vtable.getInfo(ctx.server.ctx, ctx.peer, ctx.params, &results, ctx.caps);
            _ = try ret.initCapTableTyped(0);
        }
    };

    pub const Leave = struct {
        pub const ordinal: u16 = 4;
        pub const Params = LeaveParams;
        pub const Results = LeaveResults;
        pub const BuildFn = *const fn (ctx: *anyopaque, params: *Params.Builder) anyerror!void;
        pub const Handler = *const fn (ctx: *anyopaque, peer: *rpc.peer.Peer, params: Params.Reader, results: *Results.Builder, caps: *const rpc.cap_table.InboundCapTable) anyerror!void;
        pub const Response = union(enum) {
            results: Results.Reader,
            exception: rpc.protocol.Exception,
            canceled,
            results_sent_elsewhere,
            take_from_other_question: u32,
            accept_from_third_party,
        };
        pub const Callback = *const fn (ctx: *anyopaque, peer: *rpc.peer.Peer, response: Response, caps: *const rpc.cap_table.InboundCapTable) anyerror!void;

        const CallContext = struct {
            user_ctx: *anyopaque,
            build: ?BuildFn,
            callback: Callback,
        };

        const ReturnContext = struct {
            server: *Server,
            peer: *rpc.peer.Peer,
            params: Params.Reader,
            caps: *const rpc.cap_table.InboundCapTable,
        };

        fn callBuild(ctx_ptr: *anyopaque, call: *rpc.protocol.CallBuilder) anyerror!void {
            const ctx: *CallContext = @ptrCast(@alignCast(ctx_ptr));
            var params_builder_payload = try call.payloadTyped();
            var params_builder_any = try params_builder_payload.initContent();
            const params_builder = try params_builder_any.initStruct(0, 0);

            var params = Params.Builder.wrap(params_builder);
            if (ctx.build) |build_fn| {
                try build_fn(ctx.user_ctx, &params);
            }
            _ = try call.initCapTableTyped(0);
        }

        fn callReturn(ctx_ptr: *anyopaque, peer: *rpc.peer.Peer, ret: rpc.protocol.Return, caps: *const rpc.cap_table.InboundCapTable) anyerror!void {
            const ctx: *CallContext = @ptrCast(@alignCast(ctx_ptr));
            defer peer.allocator.destroy(ctx);
            var response: Response = undefined;
            switch (ret.tag) {
                .results => {
                    const payload = ret.results orelse return error.MissingReturnPayload;
                    const struct_reader = try payload.content.getStruct();
                    const results = Results.Reader.wrap(struct_reader);
                    response = .{ .results = results };
                },
                .exception => {
                    const ex = ret.exception orelse return error.MissingException;
                    response = .{ .exception = ex };
                },
                .canceled => response = .canceled,
                .resultsSentElsewhere => response = .resultsSentElsewhere,
                .take_from_other_question => {
                    const qid = ret.take_from_other_question orelse return error.MissingQuestionId;
                    response = .{ .take_from_other_question = qid };
                },
                .accept_from_third_party => response = .accept_from_third_party,
            }
            try ctx.callback(ctx.user_ctx, peer, response, caps);
        }

        fn handleCall(server: *Server, peer: *rpc.peer.Peer, call: rpc.protocol.Call, caps: *const rpc.cap_table.InboundCapTable) anyerror!void {
            const params_struct = try call.params.content.getStruct();
            const params = Params.Reader.wrap(params_struct);
            var ctx = ReturnContext{
                .server = server,
                .peer = peer,
                .params = params,
                .caps = caps,
            };
            try peer.sendReturnResults(call.question_id, &ctx, buildReturn);
        }

        fn buildReturn(ctx_ptr: *anyopaque, ret: *rpc.protocol.ReturnBuilder) anyerror!void {
            const ctx: *ReturnContext = @ptrCast(@alignCast(ctx_ptr));
            var results_builder_payload = try ret.payloadTyped();
            var results_builder_any = try results_builder_payload.initContent();
            const results_builder = try results_builder_any.initStruct(1, 0);

            var results = Results.Builder.wrap(results_builder);
            try ctx.server.vtable.leave(ctx.server.ctx, ctx.peer, ctx.params, &results, ctx.caps);
            _ = try ret.initCapTableTyped(0);
        }
    };

    pub const Client = struct {
        peer: *rpc.peer.Peer,
        cap_id: u32,

        pub fn init(peer: *rpc.peer.Peer, cap_id: u32) Client {
            return .{ .peer = peer, .cap_id = cap_id };
        }

        pub fn callSendMessage(self: *Client, user_ctx: *anyopaque, build: ?SendMessage.BuildFn, on_return: SendMessage.Callback) !u32 {
            const ctx = try self.peer.allocator.create(SendMessage.CallContext);
            ctx.* = .{ .user_ctx = user_ctx, .build = build, .callback = on_return };
            return self.peer.sendCall(self.cap_id, interface_id, SendMessage.ordinal, ctx, SendMessage.callBuild, SendMessage.callReturn);
        }

        pub fn callSendEmote(self: *Client, user_ctx: *anyopaque, build: ?SendEmote.BuildFn, on_return: SendEmote.Callback) !u32 {
            const ctx = try self.peer.allocator.create(SendEmote.CallContext);
            ctx.* = .{ .user_ctx = user_ctx, .build = build, .callback = on_return };
            return self.peer.sendCall(self.cap_id, interface_id, SendEmote.ordinal, ctx, SendEmote.callBuild, SendEmote.callReturn);
        }

        pub fn callGetHistory(self: *Client, user_ctx: *anyopaque, build: ?GetHistory.BuildFn, on_return: GetHistory.Callback) !u32 {
            const ctx = try self.peer.allocator.create(GetHistory.CallContext);
            ctx.* = .{ .user_ctx = user_ctx, .build = build, .callback = on_return };
            return self.peer.sendCall(self.cap_id, interface_id, GetHistory.ordinal, ctx, GetHistory.callBuild, GetHistory.callReturn);
        }

        pub fn callGetInfo(self: *Client, user_ctx: *anyopaque, build: ?GetInfo.BuildFn, on_return: GetInfo.Callback) !u32 {
            const ctx = try self.peer.allocator.create(GetInfo.CallContext);
            ctx.* = .{ .user_ctx = user_ctx, .build = build, .callback = on_return };
            return self.peer.sendCall(self.cap_id, interface_id, GetInfo.ordinal, ctx, GetInfo.callBuild, GetInfo.callReturn);
        }

        pub fn callLeave(self: *Client, user_ctx: *anyopaque, build: ?Leave.BuildFn, on_return: Leave.Callback) !u32 {
            const ctx = try self.peer.allocator.create(Leave.CallContext);
            ctx.* = .{ .user_ctx = user_ctx, .build = build, .callback = on_return };
            return self.peer.sendCall(self.cap_id, interface_id, Leave.ordinal, ctx, Leave.callBuild, Leave.callReturn);
        }

        pub fn fromBootstrap(peer: *rpc.peer.Peer, user_ctx: *anyopaque, callback: BootstrapCallback) !u32 {
            return bootstrap(peer, user_ctx, callback);
        }
    };

    pub const BootstrapResponse = union(enum) {
        client: Client,
        exception: rpc.protocol.Exception,
        canceled,
        results_sent_elsewhere,
        take_from_other_question: u32,
        accept_from_third_party,
    };
    pub const BootstrapCallback = *const fn (ctx: *anyopaque, peer: *rpc.peer.Peer, response: BootstrapResponse) anyerror!void;

    const BootstrapContext = struct {
        user_ctx: *anyopaque,
        callback: BootstrapCallback,
    };

    fn bootstrapReturn(ctx_ptr: *anyopaque, peer: *rpc.peer.Peer, ret: rpc.protocol.Return, caps: *const rpc.cap_table.InboundCapTable) anyerror!void {
        const ctx: *BootstrapContext = @ptrCast(@alignCast(ctx_ptr));
        defer peer.allocator.destroy(ctx);
        var response: BootstrapResponse = undefined;
        switch (ret.tag) {
            .results => {
                const payload = ret.results orelse return error.MissingReturnPayload;
                const cap = try payload.content.getCapability();
                const resolved = try caps.resolveCapability(cap);
                switch (resolved) {
                    .imported => |imported| response = .{ .client = Client.init(peer, imported.id) },
                    else => return error.UnexpectedBootstrapCapability,
                }
            },
            .exception => {
                const ex = ret.exception orelse return error.MissingException;
                response = .{ .exception = ex };
            },
            .canceled => response = .canceled,
            .resultsSentElsewhere => response = .resultsSentElsewhere,
            .take_from_other_question => {
                const qid = ret.take_from_other_question orelse return error.MissingQuestionId;
                response = .{ .take_from_other_question = qid };
            },
            .accept_from_third_party => response = .accept_from_third_party,
        }
        try ctx.callback(ctx.user_ctx, peer, response);
    }

    pub fn bootstrap(peer: *rpc.peer.Peer, user_ctx: *anyopaque, callback: BootstrapCallback) !u32 {
        const ctx = try peer.allocator.create(BootstrapContext);
        ctx.* = .{ .user_ctx = user_ctx, .callback = callback };
        return peer.sendBootstrap(ctx, bootstrapReturn);
    }

    pub const Server = struct {
        ctx: *anyopaque,
        vtable: VTable,
    };

    pub const VTable = struct {
        sendMessage: SendMessage.Handler,
        sendEmote: SendEmote.Handler,
        getHistory: GetHistory.Handler,
        getInfo: GetInfo.Handler,
        leave: Leave.Handler,
    };

    pub fn exportServer(peer: *rpc.peer.Peer, server: *Server) !u32 {
        return peer.addExport(.{ .ctx = server, .on_call = onCall });
    }

    pub fn setBootstrap(peer: *rpc.peer.Peer, server: *Server) !u32 {
        return peer.setBootstrap(.{ .ctx = server, .on_call = onCall });
    }

    fn onCall(ctx: *anyopaque, peer: *rpc.peer.Peer, call: rpc.protocol.Call, caps: *const rpc.cap_table.InboundCapTable) anyerror!void {
        const server: *Server = @ptrCast(@alignCast(ctx));
        switch (call.method_id) {
            SendMessage.ordinal => try SendMessage.handleCall(server, peer, call, caps),
            SendEmote.ordinal => try SendEmote.handleCall(server, peer, call, caps),
            GetHistory.ordinal => try GetHistory.handleCall(server, peer, call, caps),
            GetInfo.ordinal => try GetInfo.handleCall(server, peer, call, caps),
            Leave.ordinal => try Leave.handleCall(server, peer, call, caps),
            else => try peer.sendReturnException(call.question_id, "unknown method"),
        }
    }
};

pub const SendMessageParams = struct {
    fn EnumListReader(comptime EnumType: type) type {
        return struct {
            _list: message.U16ListReader,

            pub fn len(self: @This()) u32 {
                return self._list.len();
            }

            pub fn get(self: @This(), index: u32) !EnumType {
                return @enumFromInt(try self._list.get(index));
            }

            pub fn raw(self: @This()) message.U16ListReader {
                return self._list;
            }
        };
    }

    fn EnumListBuilder(comptime EnumType: type) type {
        return struct {
            _list: message.U16ListBuilder,

            pub fn len(self: @This()) u32 {
                return self._list.len();
            }

            pub fn set(self: @This(), index: u32, value: EnumType) !void {
                try self._list.set(index, @intFromEnum(value));
            }

            pub fn raw(self: @This()) message.U16ListBuilder {
                return self._list;
            }
        };
    }

    fn StructListReader(comptime StructType: type) type {
        return struct {
            _list: message.StructListReader,

            pub fn len(self: @This()) u32 {
                return self._list.len();
            }

            pub fn get(self: @This(), index: u32) !StructType.Reader {
                const item = try self._list.get(index);
                return StructType.Reader.wrap(item);
            }

            pub fn raw(self: @This()) message.StructListReader {
                return self._list;
            }
        };
    }

    fn StructListBuilder(comptime StructType: type) type {
        return struct {
            _list: message.StructListBuilder,

            pub fn len(self: @This()) u32 {
                return self._list.len();
            }

            pub fn get(self: @This(), index: u32) !StructType.Builder {
                const item = try self._list.get(index);
                return StructType.Builder.wrap(item);
            }

            pub fn raw(self: @This()) message.StructListBuilder {
                return self._list;
            }
        };
    }

    const DataListReader = struct {
        _list: message.PointerListReader,

        pub fn len(self: @This()) u32 {
            return self._list.len();
        }

        pub fn get(self: @This(), index: u32) ![]const u8 {
            return try self._list.getData(index);
        }

        pub fn raw(self: @This()) message.PointerListReader {
            return self._list;
        }
    };

    const DataListBuilder = struct {
        _list: message.PointerListBuilder,

        pub fn len(self: @This()) u32 {
            return self._list.len();
        }

        pub fn set(self: @This(), index: u32, value: []const u8) !void {
            try self._list.setData(index, value);
        }

        pub fn setNull(self: @This(), index: u32) !void {
            try self._list.setNull(index);
        }

        pub fn raw(self: @This()) message.PointerListBuilder {
            return self._list;
        }
    };

    const CapabilityListReader = struct {
        _list: message.PointerListReader,

        pub fn len(self: @This()) u32 {
            return self._list.len();
        }

        pub fn get(self: @This(), index: u32) !message.Capability {
            return try self._list.getCapability(index);
        }

        pub fn raw(self: @This()) message.PointerListReader {
            return self._list;
        }
    };

    const CapabilityListBuilder = struct {
        _list: message.PointerListBuilder,

        pub fn len(self: @This()) u32 {
            return self._list.len();
        }

        pub fn set(self: @This(), index: u32, cap: message.Capability) !void {
            try self._list.setCapability(index, cap);
        }

        pub fn setNull(self: @This(), index: u32) !void {
            try self._list.setNull(index);
        }

        pub fn raw(self: @This()) message.PointerListBuilder {
            return self._list;
        }
    };

    pub const Reader = struct {
        _reader: message.StructReader,

        pub fn init(msg: *const message.Message) !Reader {
            const root = try msg.getRootStruct();
            return .{ ._reader = root };
        }

        pub fn wrap(reader: message.StructReader) Reader {
            return .{ ._reader = reader };
        }

        pub fn getContent(self: Reader) ![]const u8 {
            if (self._reader.isPointerNull(0)) return "";
            return try self._reader.readText(0);
        }
    };

    pub const Builder = struct {
        _builder: message.StructBuilder,

        pub fn init(msg: *message.MessageBuilder) !Builder {
            const builder = try msg.allocateStruct(0, 1);
            return .{ ._builder = builder };
        }

        pub fn wrap(builder: message.StructBuilder) Builder {
            return .{ ._builder = builder };
        }

        pub fn setContent(self: *Builder, value: []const u8) !void {
            try self._builder.writeText(0, value);
        }
    };
};

pub const SendMessageResults = struct {
    fn EnumListReader(comptime EnumType: type) type {
        return struct {
            _list: message.U16ListReader,

            pub fn len(self: @This()) u32 {
                return self._list.len();
            }

            pub fn get(self: @This(), index: u32) !EnumType {
                return @enumFromInt(try self._list.get(index));
            }

            pub fn raw(self: @This()) message.U16ListReader {
                return self._list;
            }
        };
    }

    fn EnumListBuilder(comptime EnumType: type) type {
        return struct {
            _list: message.U16ListBuilder,

            pub fn len(self: @This()) u32 {
                return self._list.len();
            }

            pub fn set(self: @This(), index: u32, value: EnumType) !void {
                try self._list.set(index, @intFromEnum(value));
            }

            pub fn raw(self: @This()) message.U16ListBuilder {
                return self._list;
            }
        };
    }

    fn StructListReader(comptime StructType: type) type {
        return struct {
            _list: message.StructListReader,

            pub fn len(self: @This()) u32 {
                return self._list.len();
            }

            pub fn get(self: @This(), index: u32) !StructType.Reader {
                const item = try self._list.get(index);
                return StructType.Reader.wrap(item);
            }

            pub fn raw(self: @This()) message.StructListReader {
                return self._list;
            }
        };
    }

    fn StructListBuilder(comptime StructType: type) type {
        return struct {
            _list: message.StructListBuilder,

            pub fn len(self: @This()) u32 {
                return self._list.len();
            }

            pub fn get(self: @This(), index: u32) !StructType.Builder {
                const item = try self._list.get(index);
                return StructType.Builder.wrap(item);
            }

            pub fn raw(self: @This()) message.StructListBuilder {
                return self._list;
            }
        };
    }

    const DataListReader = struct {
        _list: message.PointerListReader,

        pub fn len(self: @This()) u32 {
            return self._list.len();
        }

        pub fn get(self: @This(), index: u32) ![]const u8 {
            return try self._list.getData(index);
        }

        pub fn raw(self: @This()) message.PointerListReader {
            return self._list;
        }
    };

    const DataListBuilder = struct {
        _list: message.PointerListBuilder,

        pub fn len(self: @This()) u32 {
            return self._list.len();
        }

        pub fn set(self: @This(), index: u32, value: []const u8) !void {
            try self._list.setData(index, value);
        }

        pub fn setNull(self: @This(), index: u32) !void {
            try self._list.setNull(index);
        }

        pub fn raw(self: @This()) message.PointerListBuilder {
            return self._list;
        }
    };

    const CapabilityListReader = struct {
        _list: message.PointerListReader,

        pub fn len(self: @This()) u32 {
            return self._list.len();
        }

        pub fn get(self: @This(), index: u32) !message.Capability {
            return try self._list.getCapability(index);
        }

        pub fn raw(self: @This()) message.PointerListReader {
            return self._list;
        }
    };

    const CapabilityListBuilder = struct {
        _list: message.PointerListBuilder,

        pub fn len(self: @This()) u32 {
            return self._list.len();
        }

        pub fn set(self: @This(), index: u32, cap: message.Capability) !void {
            try self._list.setCapability(index, cap);
        }

        pub fn setNull(self: @This(), index: u32) !void {
            try self._list.setNull(index);
        }

        pub fn raw(self: @This()) message.PointerListBuilder {
            return self._list;
        }
    };

    pub const Reader = struct {
        _reader: message.StructReader,

        pub fn init(msg: *const message.Message) !Reader {
            const root = try msg.getRootStruct();
            return .{ ._reader = root };
        }

        pub fn wrap(reader: message.StructReader) Reader {
            return .{ ._reader = reader };
        }

        pub fn getMessage(self: Reader) !ChatMessage.Reader {
            const value = try self._reader.readStruct(0);
            return ChatMessage.Reader{ ._reader = value };
        }

        pub fn getStatus(self: Reader) !StatusCode {
            const raw = self._reader.readU16(0) ^ @as(u16, 0);
            return @enumFromInt(raw);
        }
    };

    pub const Builder = struct {
        _builder: message.StructBuilder,

        pub fn init(msg: *message.MessageBuilder) !Builder {
            const builder = try msg.allocateStruct(1, 1);
            return .{ ._builder = builder };
        }

        pub fn wrap(builder: message.StructBuilder) Builder {
            return .{ ._builder = builder };
        }

        pub fn initMessage(self: *Builder) !ChatMessage.Builder {
            const builder = try self._builder.initStruct(0, 1, 4);
            return ChatMessage.Builder{ ._builder = builder };
        }

        pub fn setStatus(self: *Builder, value: StatusCode) !void {
            const raw = @as(u16, @intFromEnum(value));
            const stored = raw ^ @as(u16, 0);
            self._builder.writeU16(0, stored);
        }
    };
};

pub const SendEmoteParams = struct {
    fn EnumListReader(comptime EnumType: type) type {
        return struct {
            _list: message.U16ListReader,

            pub fn len(self: @This()) u32 {
                return self._list.len();
            }

            pub fn get(self: @This(), index: u32) !EnumType {
                return @enumFromInt(try self._list.get(index));
            }

            pub fn raw(self: @This()) message.U16ListReader {
                return self._list;
            }
        };
    }

    fn EnumListBuilder(comptime EnumType: type) type {
        return struct {
            _list: message.U16ListBuilder,

            pub fn len(self: @This()) u32 {
                return self._list.len();
            }

            pub fn set(self: @This(), index: u32, value: EnumType) !void {
                try self._list.set(index, @intFromEnum(value));
            }

            pub fn raw(self: @This()) message.U16ListBuilder {
                return self._list;
            }
        };
    }

    fn StructListReader(comptime StructType: type) type {
        return struct {
            _list: message.StructListReader,

            pub fn len(self: @This()) u32 {
                return self._list.len();
            }

            pub fn get(self: @This(), index: u32) !StructType.Reader {
                const item = try self._list.get(index);
                return StructType.Reader.wrap(item);
            }

            pub fn raw(self: @This()) message.StructListReader {
                return self._list;
            }
        };
    }

    fn StructListBuilder(comptime StructType: type) type {
        return struct {
            _list: message.StructListBuilder,

            pub fn len(self: @This()) u32 {
                return self._list.len();
            }

            pub fn get(self: @This(), index: u32) !StructType.Builder {
                const item = try self._list.get(index);
                return StructType.Builder.wrap(item);
            }

            pub fn raw(self: @This()) message.StructListBuilder {
                return self._list;
            }
        };
    }

    const DataListReader = struct {
        _list: message.PointerListReader,

        pub fn len(self: @This()) u32 {
            return self._list.len();
        }

        pub fn get(self: @This(), index: u32) ![]const u8 {
            return try self._list.getData(index);
        }

        pub fn raw(self: @This()) message.PointerListReader {
            return self._list;
        }
    };

    const DataListBuilder = struct {
        _list: message.PointerListBuilder,

        pub fn len(self: @This()) u32 {
            return self._list.len();
        }

        pub fn set(self: @This(), index: u32, value: []const u8) !void {
            try self._list.setData(index, value);
        }

        pub fn setNull(self: @This(), index: u32) !void {
            try self._list.setNull(index);
        }

        pub fn raw(self: @This()) message.PointerListBuilder {
            return self._list;
        }
    };

    const CapabilityListReader = struct {
        _list: message.PointerListReader,

        pub fn len(self: @This()) u32 {
            return self._list.len();
        }

        pub fn get(self: @This(), index: u32) !message.Capability {
            return try self._list.getCapability(index);
        }

        pub fn raw(self: @This()) message.PointerListReader {
            return self._list;
        }
    };

    const CapabilityListBuilder = struct {
        _list: message.PointerListBuilder,

        pub fn len(self: @This()) u32 {
            return self._list.len();
        }

        pub fn set(self: @This(), index: u32, cap: message.Capability) !void {
            try self._list.setCapability(index, cap);
        }

        pub fn setNull(self: @This(), index: u32) !void {
            try self._list.setNull(index);
        }

        pub fn raw(self: @This()) message.PointerListBuilder {
            return self._list;
        }
    };

    pub const Reader = struct {
        _reader: message.StructReader,

        pub fn init(msg: *const message.Message) !Reader {
            const root = try msg.getRootStruct();
            return .{ ._reader = root };
        }

        pub fn wrap(reader: message.StructReader) Reader {
            return .{ ._reader = reader };
        }

        pub fn getContent(self: Reader) ![]const u8 {
            if (self._reader.isPointerNull(0)) return "";
            return try self._reader.readText(0);
        }
    };

    pub const Builder = struct {
        _builder: message.StructBuilder,

        pub fn init(msg: *message.MessageBuilder) !Builder {
            const builder = try msg.allocateStruct(0, 1);
            return .{ ._builder = builder };
        }

        pub fn wrap(builder: message.StructBuilder) Builder {
            return .{ ._builder = builder };
        }

        pub fn setContent(self: *Builder, value: []const u8) !void {
            try self._builder.writeText(0, value);
        }
    };
};

pub const SendEmoteResults = struct {
    fn EnumListReader(comptime EnumType: type) type {
        return struct {
            _list: message.U16ListReader,

            pub fn len(self: @This()) u32 {
                return self._list.len();
            }

            pub fn get(self: @This(), index: u32) !EnumType {
                return @enumFromInt(try self._list.get(index));
            }

            pub fn raw(self: @This()) message.U16ListReader {
                return self._list;
            }
        };
    }

    fn EnumListBuilder(comptime EnumType: type) type {
        return struct {
            _list: message.U16ListBuilder,

            pub fn len(self: @This()) u32 {
                return self._list.len();
            }

            pub fn set(self: @This(), index: u32, value: EnumType) !void {
                try self._list.set(index, @intFromEnum(value));
            }

            pub fn raw(self: @This()) message.U16ListBuilder {
                return self._list;
            }
        };
    }

    fn StructListReader(comptime StructType: type) type {
        return struct {
            _list: message.StructListReader,

            pub fn len(self: @This()) u32 {
                return self._list.len();
            }

            pub fn get(self: @This(), index: u32) !StructType.Reader {
                const item = try self._list.get(index);
                return StructType.Reader.wrap(item);
            }

            pub fn raw(self: @This()) message.StructListReader {
                return self._list;
            }
        };
    }

    fn StructListBuilder(comptime StructType: type) type {
        return struct {
            _list: message.StructListBuilder,

            pub fn len(self: @This()) u32 {
                return self._list.len();
            }

            pub fn get(self: @This(), index: u32) !StructType.Builder {
                const item = try self._list.get(index);
                return StructType.Builder.wrap(item);
            }

            pub fn raw(self: @This()) message.StructListBuilder {
                return self._list;
            }
        };
    }

    const DataListReader = struct {
        _list: message.PointerListReader,

        pub fn len(self: @This()) u32 {
            return self._list.len();
        }

        pub fn get(self: @This(), index: u32) ![]const u8 {
            return try self._list.getData(index);
        }

        pub fn raw(self: @This()) message.PointerListReader {
            return self._list;
        }
    };

    const DataListBuilder = struct {
        _list: message.PointerListBuilder,

        pub fn len(self: @This()) u32 {
            return self._list.len();
        }

        pub fn set(self: @This(), index: u32, value: []const u8) !void {
            try self._list.setData(index, value);
        }

        pub fn setNull(self: @This(), index: u32) !void {
            try self._list.setNull(index);
        }

        pub fn raw(self: @This()) message.PointerListBuilder {
            return self._list;
        }
    };

    const CapabilityListReader = struct {
        _list: message.PointerListReader,

        pub fn len(self: @This()) u32 {
            return self._list.len();
        }

        pub fn get(self: @This(), index: u32) !message.Capability {
            return try self._list.getCapability(index);
        }

        pub fn raw(self: @This()) message.PointerListReader {
            return self._list;
        }
    };

    const CapabilityListBuilder = struct {
        _list: message.PointerListBuilder,

        pub fn len(self: @This()) u32 {
            return self._list.len();
        }

        pub fn set(self: @This(), index: u32, cap: message.Capability) !void {
            try self._list.setCapability(index, cap);
        }

        pub fn setNull(self: @This(), index: u32) !void {
            try self._list.setNull(index);
        }

        pub fn raw(self: @This()) message.PointerListBuilder {
            return self._list;
        }
    };

    pub const Reader = struct {
        _reader: message.StructReader,

        pub fn init(msg: *const message.Message) !Reader {
            const root = try msg.getRootStruct();
            return .{ ._reader = root };
        }

        pub fn wrap(reader: message.StructReader) Reader {
            return .{ ._reader = reader };
        }

        pub fn getMessage(self: Reader) !ChatMessage.Reader {
            const value = try self._reader.readStruct(0);
            return ChatMessage.Reader{ ._reader = value };
        }

        pub fn getStatus(self: Reader) !StatusCode {
            const raw = self._reader.readU16(0) ^ @as(u16, 0);
            return @enumFromInt(raw);
        }
    };

    pub const Builder = struct {
        _builder: message.StructBuilder,

        pub fn init(msg: *message.MessageBuilder) !Builder {
            const builder = try msg.allocateStruct(1, 1);
            return .{ ._builder = builder };
        }

        pub fn wrap(builder: message.StructBuilder) Builder {
            return .{ ._builder = builder };
        }

        pub fn initMessage(self: *Builder) !ChatMessage.Builder {
            const builder = try self._builder.initStruct(0, 1, 4);
            return ChatMessage.Builder{ ._builder = builder };
        }

        pub fn setStatus(self: *Builder, value: StatusCode) !void {
            const raw = @as(u16, @intFromEnum(value));
            const stored = raw ^ @as(u16, 0);
            self._builder.writeU16(0, stored);
        }
    };
};

pub const GetHistoryParams = struct {
    fn EnumListReader(comptime EnumType: type) type {
        return struct {
            _list: message.U16ListReader,

            pub fn len(self: @This()) u32 {
                return self._list.len();
            }

            pub fn get(self: @This(), index: u32) !EnumType {
                return @enumFromInt(try self._list.get(index));
            }

            pub fn raw(self: @This()) message.U16ListReader {
                return self._list;
            }
        };
    }

    fn EnumListBuilder(comptime EnumType: type) type {
        return struct {
            _list: message.U16ListBuilder,

            pub fn len(self: @This()) u32 {
                return self._list.len();
            }

            pub fn set(self: @This(), index: u32, value: EnumType) !void {
                try self._list.set(index, @intFromEnum(value));
            }

            pub fn raw(self: @This()) message.U16ListBuilder {
                return self._list;
            }
        };
    }

    fn StructListReader(comptime StructType: type) type {
        return struct {
            _list: message.StructListReader,

            pub fn len(self: @This()) u32 {
                return self._list.len();
            }

            pub fn get(self: @This(), index: u32) !StructType.Reader {
                const item = try self._list.get(index);
                return StructType.Reader.wrap(item);
            }

            pub fn raw(self: @This()) message.StructListReader {
                return self._list;
            }
        };
    }

    fn StructListBuilder(comptime StructType: type) type {
        return struct {
            _list: message.StructListBuilder,

            pub fn len(self: @This()) u32 {
                return self._list.len();
            }

            pub fn get(self: @This(), index: u32) !StructType.Builder {
                const item = try self._list.get(index);
                return StructType.Builder.wrap(item);
            }

            pub fn raw(self: @This()) message.StructListBuilder {
                return self._list;
            }
        };
    }

    const DataListReader = struct {
        _list: message.PointerListReader,

        pub fn len(self: @This()) u32 {
            return self._list.len();
        }

        pub fn get(self: @This(), index: u32) ![]const u8 {
            return try self._list.getData(index);
        }

        pub fn raw(self: @This()) message.PointerListReader {
            return self._list;
        }
    };

    const DataListBuilder = struct {
        _list: message.PointerListBuilder,

        pub fn len(self: @This()) u32 {
            return self._list.len();
        }

        pub fn set(self: @This(), index: u32, value: []const u8) !void {
            try self._list.setData(index, value);
        }

        pub fn setNull(self: @This(), index: u32) !void {
            try self._list.setNull(index);
        }

        pub fn raw(self: @This()) message.PointerListBuilder {
            return self._list;
        }
    };

    const CapabilityListReader = struct {
        _list: message.PointerListReader,

        pub fn len(self: @This()) u32 {
            return self._list.len();
        }

        pub fn get(self: @This(), index: u32) !message.Capability {
            return try self._list.getCapability(index);
        }

        pub fn raw(self: @This()) message.PointerListReader {
            return self._list;
        }
    };

    const CapabilityListBuilder = struct {
        _list: message.PointerListBuilder,

        pub fn len(self: @This()) u32 {
            return self._list.len();
        }

        pub fn set(self: @This(), index: u32, cap: message.Capability) !void {
            try self._list.setCapability(index, cap);
        }

        pub fn setNull(self: @This(), index: u32) !void {
            try self._list.setNull(index);
        }

        pub fn raw(self: @This()) message.PointerListBuilder {
            return self._list;
        }
    };

    pub const Reader = struct {
        _reader: message.StructReader,

        pub fn init(msg: *const message.Message) !Reader {
            const root = try msg.getRootStruct();
            return .{ ._reader = root };
        }

        pub fn wrap(reader: message.StructReader) Reader {
            return .{ ._reader = reader };
        }

        pub fn getLimit(self: Reader) !u32 {
            const raw = self._reader.readU32(0);
            const value = raw ^ @as(u32, 0);
            return value;
        }
    };

    pub const Builder = struct {
        _builder: message.StructBuilder,

        pub fn init(msg: *message.MessageBuilder) !Builder {
            const builder = try msg.allocateStruct(1, 0);
            return .{ ._builder = builder };
        }

        pub fn wrap(builder: message.StructBuilder) Builder {
            return .{ ._builder = builder };
        }

        pub fn setLimit(self: *Builder, value: u32) !void {
            const stored = @as(u32, @bitCast(value)) ^ @as(u32, 0);
            self._builder.writeU32(0, stored);
        }
    };
};

pub const GetHistoryResults = struct {
    fn EnumListReader(comptime EnumType: type) type {
        return struct {
            _list: message.U16ListReader,

            pub fn len(self: @This()) u32 {
                return self._list.len();
            }

            pub fn get(self: @This(), index: u32) !EnumType {
                return @enumFromInt(try self._list.get(index));
            }

            pub fn raw(self: @This()) message.U16ListReader {
                return self._list;
            }
        };
    }

    fn EnumListBuilder(comptime EnumType: type) type {
        return struct {
            _list: message.U16ListBuilder,

            pub fn len(self: @This()) u32 {
                return self._list.len();
            }

            pub fn set(self: @This(), index: u32, value: EnumType) !void {
                try self._list.set(index, @intFromEnum(value));
            }

            pub fn raw(self: @This()) message.U16ListBuilder {
                return self._list;
            }
        };
    }

    fn StructListReader(comptime StructType: type) type {
        return struct {
            _list: message.StructListReader,

            pub fn len(self: @This()) u32 {
                return self._list.len();
            }

            pub fn get(self: @This(), index: u32) !StructType.Reader {
                const item = try self._list.get(index);
                return StructType.Reader.wrap(item);
            }

            pub fn raw(self: @This()) message.StructListReader {
                return self._list;
            }
        };
    }

    fn StructListBuilder(comptime StructType: type) type {
        return struct {
            _list: message.StructListBuilder,

            pub fn len(self: @This()) u32 {
                return self._list.len();
            }

            pub fn get(self: @This(), index: u32) !StructType.Builder {
                const item = try self._list.get(index);
                return StructType.Builder.wrap(item);
            }

            pub fn raw(self: @This()) message.StructListBuilder {
                return self._list;
            }
        };
    }

    const DataListReader = struct {
        _list: message.PointerListReader,

        pub fn len(self: @This()) u32 {
            return self._list.len();
        }

        pub fn get(self: @This(), index: u32) ![]const u8 {
            return try self._list.getData(index);
        }

        pub fn raw(self: @This()) message.PointerListReader {
            return self._list;
        }
    };

    const DataListBuilder = struct {
        _list: message.PointerListBuilder,

        pub fn len(self: @This()) u32 {
            return self._list.len();
        }

        pub fn set(self: @This(), index: u32, value: []const u8) !void {
            try self._list.setData(index, value);
        }

        pub fn setNull(self: @This(), index: u32) !void {
            try self._list.setNull(index);
        }

        pub fn raw(self: @This()) message.PointerListBuilder {
            return self._list;
        }
    };

    const CapabilityListReader = struct {
        _list: message.PointerListReader,

        pub fn len(self: @This()) u32 {
            return self._list.len();
        }

        pub fn get(self: @This(), index: u32) !message.Capability {
            return try self._list.getCapability(index);
        }

        pub fn raw(self: @This()) message.PointerListReader {
            return self._list;
        }
    };

    const CapabilityListBuilder = struct {
        _list: message.PointerListBuilder,

        pub fn len(self: @This()) u32 {
            return self._list.len();
        }

        pub fn set(self: @This(), index: u32, cap: message.Capability) !void {
            try self._list.setCapability(index, cap);
        }

        pub fn setNull(self: @This(), index: u32) !void {
            try self._list.setNull(index);
        }

        pub fn raw(self: @This()) message.PointerListBuilder {
            return self._list;
        }
    };

    pub const Reader = struct {
        _reader: message.StructReader,

        pub fn init(msg: *const message.Message) !Reader {
            const root = try msg.getRootStruct();
            return .{ ._reader = root };
        }

        pub fn wrap(reader: message.StructReader) Reader {
            return .{ ._reader = reader };
        }

        pub fn getMessages(self: Reader) !StructListReader(ChatMessage) {
            const raw = try self._reader.readStructList(0);
            return StructListReader(ChatMessage){ ._list = raw };
        }
    };

    pub const Builder = struct {
        _builder: message.StructBuilder,

        pub fn init(msg: *message.MessageBuilder) !Builder {
            const builder = try msg.allocateStruct(0, 1);
            return .{ ._builder = builder };
        }

        pub fn wrap(builder: message.StructBuilder) Builder {
            return .{ ._builder = builder };
        }

        pub fn initMessages(self: *Builder, element_count: u32) !StructListBuilder(ChatMessage) {
            const raw = try self._builder.writeStructList(0, element_count, 1, 4);
            return StructListBuilder(ChatMessage){ ._list = raw };
        }
    };
};

pub const GetInfoParams = struct {
    fn EnumListReader(comptime EnumType: type) type {
        return struct {
            _list: message.U16ListReader,

            pub fn len(self: @This()) u32 {
                return self._list.len();
            }

            pub fn get(self: @This(), index: u32) !EnumType {
                return @enumFromInt(try self._list.get(index));
            }

            pub fn raw(self: @This()) message.U16ListReader {
                return self._list;
            }
        };
    }

    fn EnumListBuilder(comptime EnumType: type) type {
        return struct {
            _list: message.U16ListBuilder,

            pub fn len(self: @This()) u32 {
                return self._list.len();
            }

            pub fn set(self: @This(), index: u32, value: EnumType) !void {
                try self._list.set(index, @intFromEnum(value));
            }

            pub fn raw(self: @This()) message.U16ListBuilder {
                return self._list;
            }
        };
    }

    fn StructListReader(comptime StructType: type) type {
        return struct {
            _list: message.StructListReader,

            pub fn len(self: @This()) u32 {
                return self._list.len();
            }

            pub fn get(self: @This(), index: u32) !StructType.Reader {
                const item = try self._list.get(index);
                return StructType.Reader.wrap(item);
            }

            pub fn raw(self: @This()) message.StructListReader {
                return self._list;
            }
        };
    }

    fn StructListBuilder(comptime StructType: type) type {
        return struct {
            _list: message.StructListBuilder,

            pub fn len(self: @This()) u32 {
                return self._list.len();
            }

            pub fn get(self: @This(), index: u32) !StructType.Builder {
                const item = try self._list.get(index);
                return StructType.Builder.wrap(item);
            }

            pub fn raw(self: @This()) message.StructListBuilder {
                return self._list;
            }
        };
    }

    const DataListReader = struct {
        _list: message.PointerListReader,

        pub fn len(self: @This()) u32 {
            return self._list.len();
        }

        pub fn get(self: @This(), index: u32) ![]const u8 {
            return try self._list.getData(index);
        }

        pub fn raw(self: @This()) message.PointerListReader {
            return self._list;
        }
    };

    const DataListBuilder = struct {
        _list: message.PointerListBuilder,

        pub fn len(self: @This()) u32 {
            return self._list.len();
        }

        pub fn set(self: @This(), index: u32, value: []const u8) !void {
            try self._list.setData(index, value);
        }

        pub fn setNull(self: @This(), index: u32) !void {
            try self._list.setNull(index);
        }

        pub fn raw(self: @This()) message.PointerListBuilder {
            return self._list;
        }
    };

    const CapabilityListReader = struct {
        _list: message.PointerListReader,

        pub fn len(self: @This()) u32 {
            return self._list.len();
        }

        pub fn get(self: @This(), index: u32) !message.Capability {
            return try self._list.getCapability(index);
        }

        pub fn raw(self: @This()) message.PointerListReader {
            return self._list;
        }
    };

    const CapabilityListBuilder = struct {
        _list: message.PointerListBuilder,

        pub fn len(self: @This()) u32 {
            return self._list.len();
        }

        pub fn set(self: @This(), index: u32, cap: message.Capability) !void {
            try self._list.setCapability(index, cap);
        }

        pub fn setNull(self: @This(), index: u32) !void {
            try self._list.setNull(index);
        }

        pub fn raw(self: @This()) message.PointerListBuilder {
            return self._list;
        }
    };

    pub const Reader = struct {
        _reader: message.StructReader,

        pub fn init(msg: *const message.Message) !Reader {
            const root = try msg.getRootStruct();
            return .{ ._reader = root };
        }

        pub fn wrap(reader: message.StructReader) Reader {
            return .{ ._reader = reader };
        }
    };

    pub const Builder = struct {
        _builder: message.StructBuilder,

        pub fn init(msg: *message.MessageBuilder) !Builder {
            const builder = try msg.allocateStruct(0, 0);
            return .{ ._builder = builder };
        }

        pub fn wrap(builder: message.StructBuilder) Builder {
            return .{ ._builder = builder };
        }
    };
};

pub const GetInfoResults = struct {
    fn EnumListReader(comptime EnumType: type) type {
        return struct {
            _list: message.U16ListReader,

            pub fn len(self: @This()) u32 {
                return self._list.len();
            }

            pub fn get(self: @This(), index: u32) !EnumType {
                return @enumFromInt(try self._list.get(index));
            }

            pub fn raw(self: @This()) message.U16ListReader {
                return self._list;
            }
        };
    }

    fn EnumListBuilder(comptime EnumType: type) type {
        return struct {
            _list: message.U16ListBuilder,

            pub fn len(self: @This()) u32 {
                return self._list.len();
            }

            pub fn set(self: @This(), index: u32, value: EnumType) !void {
                try self._list.set(index, @intFromEnum(value));
            }

            pub fn raw(self: @This()) message.U16ListBuilder {
                return self._list;
            }
        };
    }

    fn StructListReader(comptime StructType: type) type {
        return struct {
            _list: message.StructListReader,

            pub fn len(self: @This()) u32 {
                return self._list.len();
            }

            pub fn get(self: @This(), index: u32) !StructType.Reader {
                const item = try self._list.get(index);
                return StructType.Reader.wrap(item);
            }

            pub fn raw(self: @This()) message.StructListReader {
                return self._list;
            }
        };
    }

    fn StructListBuilder(comptime StructType: type) type {
        return struct {
            _list: message.StructListBuilder,

            pub fn len(self: @This()) u32 {
                return self._list.len();
            }

            pub fn get(self: @This(), index: u32) !StructType.Builder {
                const item = try self._list.get(index);
                return StructType.Builder.wrap(item);
            }

            pub fn raw(self: @This()) message.StructListBuilder {
                return self._list;
            }
        };
    }

    const DataListReader = struct {
        _list: message.PointerListReader,

        pub fn len(self: @This()) u32 {
            return self._list.len();
        }

        pub fn get(self: @This(), index: u32) ![]const u8 {
            return try self._list.getData(index);
        }

        pub fn raw(self: @This()) message.PointerListReader {
            return self._list;
        }
    };

    const DataListBuilder = struct {
        _list: message.PointerListBuilder,

        pub fn len(self: @This()) u32 {
            return self._list.len();
        }

        pub fn set(self: @This(), index: u32, value: []const u8) !void {
            try self._list.setData(index, value);
        }

        pub fn setNull(self: @This(), index: u32) !void {
            try self._list.setNull(index);
        }

        pub fn raw(self: @This()) message.PointerListBuilder {
            return self._list;
        }
    };

    const CapabilityListReader = struct {
        _list: message.PointerListReader,

        pub fn len(self: @This()) u32 {
            return self._list.len();
        }

        pub fn get(self: @This(), index: u32) !message.Capability {
            return try self._list.getCapability(index);
        }

        pub fn raw(self: @This()) message.PointerListReader {
            return self._list;
        }
    };

    const CapabilityListBuilder = struct {
        _list: message.PointerListBuilder,

        pub fn len(self: @This()) u32 {
            return self._list.len();
        }

        pub fn set(self: @This(), index: u32, cap: message.Capability) !void {
            try self._list.setCapability(index, cap);
        }

        pub fn setNull(self: @This(), index: u32) !void {
            try self._list.setNull(index);
        }

        pub fn raw(self: @This()) message.PointerListBuilder {
            return self._list;
        }
    };

    pub const Reader = struct {
        _reader: message.StructReader,

        pub fn init(msg: *const message.Message) !Reader {
            const root = try msg.getRootStruct();
            return .{ ._reader = root };
        }

        pub fn wrap(reader: message.StructReader) Reader {
            return .{ ._reader = reader };
        }

        pub fn getInfo(self: Reader) !RoomInfo.Reader {
            const value = try self._reader.readStruct(0);
            return RoomInfo.Reader{ ._reader = value };
        }
    };

    pub const Builder = struct {
        _builder: message.StructBuilder,

        pub fn init(msg: *message.MessageBuilder) !Builder {
            const builder = try msg.allocateStruct(0, 1);
            return .{ ._builder = builder };
        }

        pub fn wrap(builder: message.StructBuilder) Builder {
            return .{ ._builder = builder };
        }

        pub fn initInfo(self: *Builder) !RoomInfo.Builder {
            const builder = try self._builder.initStruct(0, 1, 3);
            return RoomInfo.Builder{ ._builder = builder };
        }
    };
};

pub const LeaveParams = struct {
    fn EnumListReader(comptime EnumType: type) type {
        return struct {
            _list: message.U16ListReader,

            pub fn len(self: @This()) u32 {
                return self._list.len();
            }

            pub fn get(self: @This(), index: u32) !EnumType {
                return @enumFromInt(try self._list.get(index));
            }

            pub fn raw(self: @This()) message.U16ListReader {
                return self._list;
            }
        };
    }

    fn EnumListBuilder(comptime EnumType: type) type {
        return struct {
            _list: message.U16ListBuilder,

            pub fn len(self: @This()) u32 {
                return self._list.len();
            }

            pub fn set(self: @This(), index: u32, value: EnumType) !void {
                try self._list.set(index, @intFromEnum(value));
            }

            pub fn raw(self: @This()) message.U16ListBuilder {
                return self._list;
            }
        };
    }

    fn StructListReader(comptime StructType: type) type {
        return struct {
            _list: message.StructListReader,

            pub fn len(self: @This()) u32 {
                return self._list.len();
            }

            pub fn get(self: @This(), index: u32) !StructType.Reader {
                const item = try self._list.get(index);
                return StructType.Reader.wrap(item);
            }

            pub fn raw(self: @This()) message.StructListReader {
                return self._list;
            }
        };
    }

    fn StructListBuilder(comptime StructType: type) type {
        return struct {
            _list: message.StructListBuilder,

            pub fn len(self: @This()) u32 {
                return self._list.len();
            }

            pub fn get(self: @This(), index: u32) !StructType.Builder {
                const item = try self._list.get(index);
                return StructType.Builder.wrap(item);
            }

            pub fn raw(self: @This()) message.StructListBuilder {
                return self._list;
            }
        };
    }

    const DataListReader = struct {
        _list: message.PointerListReader,

        pub fn len(self: @This()) u32 {
            return self._list.len();
        }

        pub fn get(self: @This(), index: u32) ![]const u8 {
            return try self._list.getData(index);
        }

        pub fn raw(self: @This()) message.PointerListReader {
            return self._list;
        }
    };

    const DataListBuilder = struct {
        _list: message.PointerListBuilder,

        pub fn len(self: @This()) u32 {
            return self._list.len();
        }

        pub fn set(self: @This(), index: u32, value: []const u8) !void {
            try self._list.setData(index, value);
        }

        pub fn setNull(self: @This(), index: u32) !void {
            try self._list.setNull(index);
        }

        pub fn raw(self: @This()) message.PointerListBuilder {
            return self._list;
        }
    };

    const CapabilityListReader = struct {
        _list: message.PointerListReader,

        pub fn len(self: @This()) u32 {
            return self._list.len();
        }

        pub fn get(self: @This(), index: u32) !message.Capability {
            return try self._list.getCapability(index);
        }

        pub fn raw(self: @This()) message.PointerListReader {
            return self._list;
        }
    };

    const CapabilityListBuilder = struct {
        _list: message.PointerListBuilder,

        pub fn len(self: @This()) u32 {
            return self._list.len();
        }

        pub fn set(self: @This(), index: u32, cap: message.Capability) !void {
            try self._list.setCapability(index, cap);
        }

        pub fn setNull(self: @This(), index: u32) !void {
            try self._list.setNull(index);
        }

        pub fn raw(self: @This()) message.PointerListBuilder {
            return self._list;
        }
    };

    pub const Reader = struct {
        _reader: message.StructReader,

        pub fn init(msg: *const message.Message) !Reader {
            const root = try msg.getRootStruct();
            return .{ ._reader = root };
        }

        pub fn wrap(reader: message.StructReader) Reader {
            return .{ ._reader = reader };
        }
    };

    pub const Builder = struct {
        _builder: message.StructBuilder,

        pub fn init(msg: *message.MessageBuilder) !Builder {
            const builder = try msg.allocateStruct(0, 0);
            return .{ ._builder = builder };
        }

        pub fn wrap(builder: message.StructBuilder) Builder {
            return .{ ._builder = builder };
        }
    };
};

pub const LeaveResults = struct {
    fn EnumListReader(comptime EnumType: type) type {
        return struct {
            _list: message.U16ListReader,

            pub fn len(self: @This()) u32 {
                return self._list.len();
            }

            pub fn get(self: @This(), index: u32) !EnumType {
                return @enumFromInt(try self._list.get(index));
            }

            pub fn raw(self: @This()) message.U16ListReader {
                return self._list;
            }
        };
    }

    fn EnumListBuilder(comptime EnumType: type) type {
        return struct {
            _list: message.U16ListBuilder,

            pub fn len(self: @This()) u32 {
                return self._list.len();
            }

            pub fn set(self: @This(), index: u32, value: EnumType) !void {
                try self._list.set(index, @intFromEnum(value));
            }

            pub fn raw(self: @This()) message.U16ListBuilder {
                return self._list;
            }
        };
    }

    fn StructListReader(comptime StructType: type) type {
        return struct {
            _list: message.StructListReader,

            pub fn len(self: @This()) u32 {
                return self._list.len();
            }

            pub fn get(self: @This(), index: u32) !StructType.Reader {
                const item = try self._list.get(index);
                return StructType.Reader.wrap(item);
            }

            pub fn raw(self: @This()) message.StructListReader {
                return self._list;
            }
        };
    }

    fn StructListBuilder(comptime StructType: type) type {
        return struct {
            _list: message.StructListBuilder,

            pub fn len(self: @This()) u32 {
                return self._list.len();
            }

            pub fn get(self: @This(), index: u32) !StructType.Builder {
                const item = try self._list.get(index);
                return StructType.Builder.wrap(item);
            }

            pub fn raw(self: @This()) message.StructListBuilder {
                return self._list;
            }
        };
    }

    const DataListReader = struct {
        _list: message.PointerListReader,

        pub fn len(self: @This()) u32 {
            return self._list.len();
        }

        pub fn get(self: @This(), index: u32) ![]const u8 {
            return try self._list.getData(index);
        }

        pub fn raw(self: @This()) message.PointerListReader {
            return self._list;
        }
    };

    const DataListBuilder = struct {
        _list: message.PointerListBuilder,

        pub fn len(self: @This()) u32 {
            return self._list.len();
        }

        pub fn set(self: @This(), index: u32, value: []const u8) !void {
            try self._list.setData(index, value);
        }

        pub fn setNull(self: @This(), index: u32) !void {
            try self._list.setNull(index);
        }

        pub fn raw(self: @This()) message.PointerListBuilder {
            return self._list;
        }
    };

    const CapabilityListReader = struct {
        _list: message.PointerListReader,

        pub fn len(self: @This()) u32 {
            return self._list.len();
        }

        pub fn get(self: @This(), index: u32) !message.Capability {
            return try self._list.getCapability(index);
        }

        pub fn raw(self: @This()) message.PointerListReader {
            return self._list;
        }
    };

    const CapabilityListBuilder = struct {
        _list: message.PointerListBuilder,

        pub fn len(self: @This()) u32 {
            return self._list.len();
        }

        pub fn set(self: @This(), index: u32, cap: message.Capability) !void {
            try self._list.setCapability(index, cap);
        }

        pub fn setNull(self: @This(), index: u32) !void {
            try self._list.setNull(index);
        }

        pub fn raw(self: @This()) message.PointerListBuilder {
            return self._list;
        }
    };

    pub const Reader = struct {
        _reader: message.StructReader,

        pub fn init(msg: *const message.Message) !Reader {
            const root = try msg.getRootStruct();
            return .{ ._reader = root };
        }

        pub fn wrap(reader: message.StructReader) Reader {
            return .{ ._reader = reader };
        }

        pub fn getStatus(self: Reader) !StatusCode {
            const raw = self._reader.readU16(0) ^ @as(u16, 0);
            return @enumFromInt(raw);
        }
    };

    pub const Builder = struct {
        _builder: message.StructBuilder,

        pub fn init(msg: *message.MessageBuilder) !Builder {
            const builder = try msg.allocateStruct(1, 0);
            return .{ ._builder = builder };
        }

        pub fn wrap(builder: message.StructBuilder) Builder {
            return .{ ._builder = builder };
        }

        pub fn setStatus(self: *Builder, value: StatusCode) !void {
            const raw = @as(u16, @intFromEnum(value));
            const stored = raw ^ @as(u16, 0);
            self._builder.writeU16(0, stored);
        }
    };
};

pub const ChatService = struct {
    pub const interface_id: u64 = 0x8eeb95216aab7eaa;
    pub const Method = enum(u16) {
        CreateRoom = 0,
        JoinRoom = 1,
        ListRooms = 2,
        Whisper = 3,
    };

    pub const CreateRoom = struct {
        pub const ordinal: u16 = 0;
        pub const Params = CreateRoomParams;
        pub const Results = CreateRoomResults;
        pub const BuildFn = *const fn (ctx: *anyopaque, params: *Params.Builder) anyerror!void;
        pub const Handler = *const fn (ctx: *anyopaque, peer: *rpc.peer.Peer, params: Params.Reader, results: *Results.Builder, caps: *const rpc.cap_table.InboundCapTable) anyerror!void;
        pub const Response = union(enum) {
            results: Results.Reader,
            exception: rpc.protocol.Exception,
            canceled,
            results_sent_elsewhere,
            take_from_other_question: u32,
            accept_from_third_party,
        };
        pub const Callback = *const fn (ctx: *anyopaque, peer: *rpc.peer.Peer, response: Response, caps: *const rpc.cap_table.InboundCapTable) anyerror!void;

        const CallContext = struct {
            user_ctx: *anyopaque,
            build: ?BuildFn,
            callback: Callback,
        };

        const ReturnContext = struct {
            server: *Server,
            peer: *rpc.peer.Peer,
            params: Params.Reader,
            caps: *const rpc.cap_table.InboundCapTable,
        };

        fn callBuild(ctx_ptr: *anyopaque, call: *rpc.protocol.CallBuilder) anyerror!void {
            const ctx: *CallContext = @ptrCast(@alignCast(ctx_ptr));
            var params_builder_payload = try call.payloadTyped();
            var params_builder_any = try params_builder_payload.initContent();
            const params_builder = try params_builder_any.initStruct(0, 2);

            var params = Params.Builder.wrap(params_builder);
            if (ctx.build) |build_fn| {
                try build_fn(ctx.user_ctx, &params);
            }
            _ = try call.initCapTableTyped(0);
        }

        fn callReturn(ctx_ptr: *anyopaque, peer: *rpc.peer.Peer, ret: rpc.protocol.Return, caps: *const rpc.cap_table.InboundCapTable) anyerror!void {
            const ctx: *CallContext = @ptrCast(@alignCast(ctx_ptr));
            defer peer.allocator.destroy(ctx);
            var response: Response = undefined;
            switch (ret.tag) {
                .results => {
                    const payload = ret.results orelse return error.MissingReturnPayload;
                    const struct_reader = try payload.content.getStruct();
                    const results = Results.Reader.wrap(struct_reader);
                    response = .{ .results = results };
                },
                .exception => {
                    const ex = ret.exception orelse return error.MissingException;
                    response = .{ .exception = ex };
                },
                .canceled => response = .canceled,
                .resultsSentElsewhere => response = .resultsSentElsewhere,
                .take_from_other_question => {
                    const qid = ret.take_from_other_question orelse return error.MissingQuestionId;
                    response = .{ .take_from_other_question = qid };
                },
                .accept_from_third_party => response = .accept_from_third_party,
            }
            try ctx.callback(ctx.user_ctx, peer, response, caps);
        }

        fn handleCall(server: *Server, peer: *rpc.peer.Peer, call: rpc.protocol.Call, caps: *const rpc.cap_table.InboundCapTable) anyerror!void {
            const params_struct = try call.params.content.getStruct();
            const params = Params.Reader.wrap(params_struct);
            var ctx = ReturnContext{
                .server = server,
                .peer = peer,
                .params = params,
                .caps = caps,
            };
            try peer.sendReturnResults(call.question_id, &ctx, buildReturn);
        }

        fn buildReturn(ctx_ptr: *anyopaque, ret: *rpc.protocol.ReturnBuilder) anyerror!void {
            const ctx: *ReturnContext = @ptrCast(@alignCast(ctx_ptr));
            var results_builder_payload = try ret.payloadTyped();
            var results_builder_any = try results_builder_payload.initContent();
            const results_builder = try results_builder_any.initStruct(1, 2);

            var results = Results.Builder.wrap(results_builder);
            try ctx.server.vtable.createRoom(ctx.server.ctx, ctx.peer, ctx.params, &results, ctx.caps);
            _ = try ret.initCapTableTyped(0);
        }
    };

    pub const JoinRoom = struct {
        pub const ordinal: u16 = 1;
        pub const Params = JoinRoomParams;
        pub const Results = JoinRoomResults;
        pub const BuildFn = *const fn (ctx: *anyopaque, params: *Params.Builder) anyerror!void;
        pub const Handler = *const fn (ctx: *anyopaque, peer: *rpc.peer.Peer, params: Params.Reader, results: *Results.Builder, caps: *const rpc.cap_table.InboundCapTable) anyerror!void;
        pub const Response = union(enum) {
            results: Results.Reader,
            exception: rpc.protocol.Exception,
            canceled,
            results_sent_elsewhere,
            take_from_other_question: u32,
            accept_from_third_party,
        };
        pub const Callback = *const fn (ctx: *anyopaque, peer: *rpc.peer.Peer, response: Response, caps: *const rpc.cap_table.InboundCapTable) anyerror!void;

        const CallContext = struct {
            user_ctx: *anyopaque,
            build: ?BuildFn,
            callback: Callback,
        };

        const ReturnContext = struct {
            server: *Server,
            peer: *rpc.peer.Peer,
            params: Params.Reader,
            caps: *const rpc.cap_table.InboundCapTable,
        };

        fn callBuild(ctx_ptr: *anyopaque, call: *rpc.protocol.CallBuilder) anyerror!void {
            const ctx: *CallContext = @ptrCast(@alignCast(ctx_ptr));
            var params_builder_payload = try call.payloadTyped();
            var params_builder_any = try params_builder_payload.initContent();
            const params_builder = try params_builder_any.initStruct(0, 2);

            var params = Params.Builder.wrap(params_builder);
            if (ctx.build) |build_fn| {
                try build_fn(ctx.user_ctx, &params);
            }
            _ = try call.initCapTableTyped(0);
        }

        fn callReturn(ctx_ptr: *anyopaque, peer: *rpc.peer.Peer, ret: rpc.protocol.Return, caps: *const rpc.cap_table.InboundCapTable) anyerror!void {
            const ctx: *CallContext = @ptrCast(@alignCast(ctx_ptr));
            defer peer.allocator.destroy(ctx);
            var response: Response = undefined;
            switch (ret.tag) {
                .results => {
                    const payload = ret.results orelse return error.MissingReturnPayload;
                    const struct_reader = try payload.content.getStruct();
                    const results = Results.Reader.wrap(struct_reader);
                    response = .{ .results = results };
                },
                .exception => {
                    const ex = ret.exception orelse return error.MissingException;
                    response = .{ .exception = ex };
                },
                .canceled => response = .canceled,
                .resultsSentElsewhere => response = .resultsSentElsewhere,
                .take_from_other_question => {
                    const qid = ret.take_from_other_question orelse return error.MissingQuestionId;
                    response = .{ .take_from_other_question = qid };
                },
                .accept_from_third_party => response = .accept_from_third_party,
            }
            try ctx.callback(ctx.user_ctx, peer, response, caps);
        }

        fn handleCall(server: *Server, peer: *rpc.peer.Peer, call: rpc.protocol.Call, caps: *const rpc.cap_table.InboundCapTable) anyerror!void {
            const params_struct = try call.params.content.getStruct();
            const params = Params.Reader.wrap(params_struct);
            var ctx = ReturnContext{
                .server = server,
                .peer = peer,
                .params = params,
                .caps = caps,
            };
            try peer.sendReturnResults(call.question_id, &ctx, buildReturn);
        }

        fn buildReturn(ctx_ptr: *anyopaque, ret: *rpc.protocol.ReturnBuilder) anyerror!void {
            const ctx: *ReturnContext = @ptrCast(@alignCast(ctx_ptr));
            var results_builder_payload = try ret.payloadTyped();
            var results_builder_any = try results_builder_payload.initContent();
            const results_builder = try results_builder_any.initStruct(1, 1);

            var results = Results.Builder.wrap(results_builder);
            try ctx.server.vtable.joinRoom(ctx.server.ctx, ctx.peer, ctx.params, &results, ctx.caps);
            _ = try ret.initCapTableTyped(0);
        }
    };

    pub const ListRooms = struct {
        pub const ordinal: u16 = 2;
        pub const Params = ListRoomsParams;
        pub const Results = ListRoomsResults;
        pub const BuildFn = *const fn (ctx: *anyopaque, params: *Params.Builder) anyerror!void;
        pub const Handler = *const fn (ctx: *anyopaque, peer: *rpc.peer.Peer, params: Params.Reader, results: *Results.Builder, caps: *const rpc.cap_table.InboundCapTable) anyerror!void;
        pub const Response = union(enum) {
            results: Results.Reader,
            exception: rpc.protocol.Exception,
            canceled,
            results_sent_elsewhere,
            take_from_other_question: u32,
            accept_from_third_party,
        };
        pub const Callback = *const fn (ctx: *anyopaque, peer: *rpc.peer.Peer, response: Response, caps: *const rpc.cap_table.InboundCapTable) anyerror!void;

        const CallContext = struct {
            user_ctx: *anyopaque,
            build: ?BuildFn,
            callback: Callback,
        };

        const ReturnContext = struct {
            server: *Server,
            peer: *rpc.peer.Peer,
            params: Params.Reader,
            caps: *const rpc.cap_table.InboundCapTable,
        };

        fn callBuild(ctx_ptr: *anyopaque, call: *rpc.protocol.CallBuilder) anyerror!void {
            const ctx: *CallContext = @ptrCast(@alignCast(ctx_ptr));
            var params_builder_payload = try call.payloadTyped();
            var params_builder_any = try params_builder_payload.initContent();
            const params_builder = try params_builder_any.initStruct(0, 0);

            var params = Params.Builder.wrap(params_builder);
            if (ctx.build) |build_fn| {
                try build_fn(ctx.user_ctx, &params);
            }
            _ = try call.initCapTableTyped(0);
        }

        fn callReturn(ctx_ptr: *anyopaque, peer: *rpc.peer.Peer, ret: rpc.protocol.Return, caps: *const rpc.cap_table.InboundCapTable) anyerror!void {
            const ctx: *CallContext = @ptrCast(@alignCast(ctx_ptr));
            defer peer.allocator.destroy(ctx);
            var response: Response = undefined;
            switch (ret.tag) {
                .results => {
                    const payload = ret.results orelse return error.MissingReturnPayload;
                    const struct_reader = try payload.content.getStruct();
                    const results = Results.Reader.wrap(struct_reader);
                    response = .{ .results = results };
                },
                .exception => {
                    const ex = ret.exception orelse return error.MissingException;
                    response = .{ .exception = ex };
                },
                .canceled => response = .canceled,
                .resultsSentElsewhere => response = .resultsSentElsewhere,
                .take_from_other_question => {
                    const qid = ret.take_from_other_question orelse return error.MissingQuestionId;
                    response = .{ .take_from_other_question = qid };
                },
                .accept_from_third_party => response = .accept_from_third_party,
            }
            try ctx.callback(ctx.user_ctx, peer, response, caps);
        }

        fn handleCall(server: *Server, peer: *rpc.peer.Peer, call: rpc.protocol.Call, caps: *const rpc.cap_table.InboundCapTable) anyerror!void {
            const params_struct = try call.params.content.getStruct();
            const params = Params.Reader.wrap(params_struct);
            var ctx = ReturnContext{
                .server = server,
                .peer = peer,
                .params = params,
                .caps = caps,
            };
            try peer.sendReturnResults(call.question_id, &ctx, buildReturn);
        }

        fn buildReturn(ctx_ptr: *anyopaque, ret: *rpc.protocol.ReturnBuilder) anyerror!void {
            const ctx: *ReturnContext = @ptrCast(@alignCast(ctx_ptr));
            var results_builder_payload = try ret.payloadTyped();
            var results_builder_any = try results_builder_payload.initContent();
            const results_builder = try results_builder_any.initStruct(0, 1);

            var results = Results.Builder.wrap(results_builder);
            try ctx.server.vtable.listRooms(ctx.server.ctx, ctx.peer, ctx.params, &results, ctx.caps);
            _ = try ret.initCapTableTyped(0);
        }
    };

    pub const Whisper = struct {
        pub const ordinal: u16 = 3;
        pub const Params = WhisperParams;
        pub const Results = WhisperResults;
        pub const BuildFn = *const fn (ctx: *anyopaque, params: *Params.Builder) anyerror!void;
        pub const Handler = *const fn (ctx: *anyopaque, peer: *rpc.peer.Peer, params: Params.Reader, results: *Results.Builder, caps: *const rpc.cap_table.InboundCapTable) anyerror!void;
        pub const Response = union(enum) {
            results: Results.Reader,
            exception: rpc.protocol.Exception,
            canceled,
            results_sent_elsewhere,
            take_from_other_question: u32,
            accept_from_third_party,
        };
        pub const Callback = *const fn (ctx: *anyopaque, peer: *rpc.peer.Peer, response: Response, caps: *const rpc.cap_table.InboundCapTable) anyerror!void;

        const CallContext = struct {
            user_ctx: *anyopaque,
            build: ?BuildFn,
            callback: Callback,
        };

        const ReturnContext = struct {
            server: *Server,
            peer: *rpc.peer.Peer,
            params: Params.Reader,
            caps: *const rpc.cap_table.InboundCapTable,
        };

        fn callBuild(ctx_ptr: *anyopaque, call: *rpc.protocol.CallBuilder) anyerror!void {
            const ctx: *CallContext = @ptrCast(@alignCast(ctx_ptr));
            var params_builder_payload = try call.payloadTyped();
            var params_builder_any = try params_builder_payload.initContent();
            const params_builder = try params_builder_any.initStruct(0, 3);

            var params = Params.Builder.wrap(params_builder);
            if (ctx.build) |build_fn| {
                try build_fn(ctx.user_ctx, &params);
            }
            _ = try call.initCapTableTyped(0);
        }

        fn callReturn(ctx_ptr: *anyopaque, peer: *rpc.peer.Peer, ret: rpc.protocol.Return, caps: *const rpc.cap_table.InboundCapTable) anyerror!void {
            const ctx: *CallContext = @ptrCast(@alignCast(ctx_ptr));
            defer peer.allocator.destroy(ctx);
            var response: Response = undefined;
            switch (ret.tag) {
                .results => {
                    const payload = ret.results orelse return error.MissingReturnPayload;
                    const struct_reader = try payload.content.getStruct();
                    const results = Results.Reader.wrap(struct_reader);
                    response = .{ .results = results };
                },
                .exception => {
                    const ex = ret.exception orelse return error.MissingException;
                    response = .{ .exception = ex };
                },
                .canceled => response = .canceled,
                .resultsSentElsewhere => response = .resultsSentElsewhere,
                .take_from_other_question => {
                    const qid = ret.take_from_other_question orelse return error.MissingQuestionId;
                    response = .{ .take_from_other_question = qid };
                },
                .accept_from_third_party => response = .accept_from_third_party,
            }
            try ctx.callback(ctx.user_ctx, peer, response, caps);
        }

        fn handleCall(server: *Server, peer: *rpc.peer.Peer, call: rpc.protocol.Call, caps: *const rpc.cap_table.InboundCapTable) anyerror!void {
            const params_struct = try call.params.content.getStruct();
            const params = Params.Reader.wrap(params_struct);
            var ctx = ReturnContext{
                .server = server,
                .peer = peer,
                .params = params,
                .caps = caps,
            };
            try peer.sendReturnResults(call.question_id, &ctx, buildReturn);
        }

        fn buildReturn(ctx_ptr: *anyopaque, ret: *rpc.protocol.ReturnBuilder) anyerror!void {
            const ctx: *ReturnContext = @ptrCast(@alignCast(ctx_ptr));
            var results_builder_payload = try ret.payloadTyped();
            var results_builder_any = try results_builder_payload.initContent();
            const results_builder = try results_builder_any.initStruct(1, 1);

            var results = Results.Builder.wrap(results_builder);
            try ctx.server.vtable.whisper(ctx.server.ctx, ctx.peer, ctx.params, &results, ctx.caps);
            _ = try ret.initCapTableTyped(0);
        }
    };

    pub const Client = struct {
        peer: *rpc.peer.Peer,
        cap_id: u32,

        pub fn init(peer: *rpc.peer.Peer, cap_id: u32) Client {
            return .{ .peer = peer, .cap_id = cap_id };
        }

        pub fn callCreateRoom(self: *Client, user_ctx: *anyopaque, build: ?CreateRoom.BuildFn, on_return: CreateRoom.Callback) !u32 {
            const ctx = try self.peer.allocator.create(CreateRoom.CallContext);
            ctx.* = .{ .user_ctx = user_ctx, .build = build, .callback = on_return };
            return self.peer.sendCall(self.cap_id, interface_id, CreateRoom.ordinal, ctx, CreateRoom.callBuild, CreateRoom.callReturn);
        }

        pub fn callJoinRoom(self: *Client, user_ctx: *anyopaque, build: ?JoinRoom.BuildFn, on_return: JoinRoom.Callback) !u32 {
            const ctx = try self.peer.allocator.create(JoinRoom.CallContext);
            ctx.* = .{ .user_ctx = user_ctx, .build = build, .callback = on_return };
            return self.peer.sendCall(self.cap_id, interface_id, JoinRoom.ordinal, ctx, JoinRoom.callBuild, JoinRoom.callReturn);
        }

        pub fn callListRooms(self: *Client, user_ctx: *anyopaque, build: ?ListRooms.BuildFn, on_return: ListRooms.Callback) !u32 {
            const ctx = try self.peer.allocator.create(ListRooms.CallContext);
            ctx.* = .{ .user_ctx = user_ctx, .build = build, .callback = on_return };
            return self.peer.sendCall(self.cap_id, interface_id, ListRooms.ordinal, ctx, ListRooms.callBuild, ListRooms.callReturn);
        }

        pub fn callWhisper(self: *Client, user_ctx: *anyopaque, build: ?Whisper.BuildFn, on_return: Whisper.Callback) !u32 {
            const ctx = try self.peer.allocator.create(Whisper.CallContext);
            ctx.* = .{ .user_ctx = user_ctx, .build = build, .callback = on_return };
            return self.peer.sendCall(self.cap_id, interface_id, Whisper.ordinal, ctx, Whisper.callBuild, Whisper.callReturn);
        }

        pub fn fromBootstrap(peer: *rpc.peer.Peer, user_ctx: *anyopaque, callback: BootstrapCallback) !u32 {
            return bootstrap(peer, user_ctx, callback);
        }
    };

    pub const BootstrapResponse = union(enum) {
        client: Client,
        exception: rpc.protocol.Exception,
        canceled,
        results_sent_elsewhere,
        take_from_other_question: u32,
        accept_from_third_party,
    };
    pub const BootstrapCallback = *const fn (ctx: *anyopaque, peer: *rpc.peer.Peer, response: BootstrapResponse) anyerror!void;

    const BootstrapContext = struct {
        user_ctx: *anyopaque,
        callback: BootstrapCallback,
    };

    fn bootstrapReturn(ctx_ptr: *anyopaque, peer: *rpc.peer.Peer, ret: rpc.protocol.Return, caps: *const rpc.cap_table.InboundCapTable) anyerror!void {
        const ctx: *BootstrapContext = @ptrCast(@alignCast(ctx_ptr));
        defer peer.allocator.destroy(ctx);
        var response: BootstrapResponse = undefined;
        switch (ret.tag) {
            .results => {
                const payload = ret.results orelse return error.MissingReturnPayload;
                const cap = try payload.content.getCapability();
                const resolved = try caps.resolveCapability(cap);
                switch (resolved) {
                    .imported => |imported| response = .{ .client = Client.init(peer, imported.id) },
                    else => return error.UnexpectedBootstrapCapability,
                }
            },
            .exception => {
                const ex = ret.exception orelse return error.MissingException;
                response = .{ .exception = ex };
            },
            .canceled => response = .canceled,
            .resultsSentElsewhere => response = .resultsSentElsewhere,
            .take_from_other_question => {
                const qid = ret.take_from_other_question orelse return error.MissingQuestionId;
                response = .{ .take_from_other_question = qid };
            },
            .accept_from_third_party => response = .accept_from_third_party,
        }
        try ctx.callback(ctx.user_ctx, peer, response);
    }

    pub fn bootstrap(peer: *rpc.peer.Peer, user_ctx: *anyopaque, callback: BootstrapCallback) !u32 {
        const ctx = try peer.allocator.create(BootstrapContext);
        ctx.* = .{ .user_ctx = user_ctx, .callback = callback };
        return peer.sendBootstrap(ctx, bootstrapReturn);
    }

    pub const Server = struct {
        ctx: *anyopaque,
        vtable: VTable,
    };

    pub const VTable = struct {
        createRoom: CreateRoom.Handler,
        joinRoom: JoinRoom.Handler,
        listRooms: ListRooms.Handler,
        whisper: Whisper.Handler,
    };

    pub fn exportServer(peer: *rpc.peer.Peer, server: *Server) !u32 {
        return peer.addExport(.{ .ctx = server, .on_call = onCall });
    }

    pub fn setBootstrap(peer: *rpc.peer.Peer, server: *Server) !u32 {
        return peer.setBootstrap(.{ .ctx = server, .on_call = onCall });
    }

    fn onCall(ctx: *anyopaque, peer: *rpc.peer.Peer, call: rpc.protocol.Call, caps: *const rpc.cap_table.InboundCapTable) anyerror!void {
        const server: *Server = @ptrCast(@alignCast(ctx));
        switch (call.method_id) {
            CreateRoom.ordinal => try CreateRoom.handleCall(server, peer, call, caps),
            JoinRoom.ordinal => try JoinRoom.handleCall(server, peer, call, caps),
            ListRooms.ordinal => try ListRooms.handleCall(server, peer, call, caps),
            Whisper.ordinal => try Whisper.handleCall(server, peer, call, caps),
            else => try peer.sendReturnException(call.question_id, "unknown method"),
        }
    }
};

pub const CreateRoomParams = struct {
    fn EnumListReader(comptime EnumType: type) type {
        return struct {
            _list: message.U16ListReader,

            pub fn len(self: @This()) u32 {
                return self._list.len();
            }

            pub fn get(self: @This(), index: u32) !EnumType {
                return @enumFromInt(try self._list.get(index));
            }

            pub fn raw(self: @This()) message.U16ListReader {
                return self._list;
            }
        };
    }

    fn EnumListBuilder(comptime EnumType: type) type {
        return struct {
            _list: message.U16ListBuilder,

            pub fn len(self: @This()) u32 {
                return self._list.len();
            }

            pub fn set(self: @This(), index: u32, value: EnumType) !void {
                try self._list.set(index, @intFromEnum(value));
            }

            pub fn raw(self: @This()) message.U16ListBuilder {
                return self._list;
            }
        };
    }

    fn StructListReader(comptime StructType: type) type {
        return struct {
            _list: message.StructListReader,

            pub fn len(self: @This()) u32 {
                return self._list.len();
            }

            pub fn get(self: @This(), index: u32) !StructType.Reader {
                const item = try self._list.get(index);
                return StructType.Reader.wrap(item);
            }

            pub fn raw(self: @This()) message.StructListReader {
                return self._list;
            }
        };
    }

    fn StructListBuilder(comptime StructType: type) type {
        return struct {
            _list: message.StructListBuilder,

            pub fn len(self: @This()) u32 {
                return self._list.len();
            }

            pub fn get(self: @This(), index: u32) !StructType.Builder {
                const item = try self._list.get(index);
                return StructType.Builder.wrap(item);
            }

            pub fn raw(self: @This()) message.StructListBuilder {
                return self._list;
            }
        };
    }

    const DataListReader = struct {
        _list: message.PointerListReader,

        pub fn len(self: @This()) u32 {
            return self._list.len();
        }

        pub fn get(self: @This(), index: u32) ![]const u8 {
            return try self._list.getData(index);
        }

        pub fn raw(self: @This()) message.PointerListReader {
            return self._list;
        }
    };

    const DataListBuilder = struct {
        _list: message.PointerListBuilder,

        pub fn len(self: @This()) u32 {
            return self._list.len();
        }

        pub fn set(self: @This(), index: u32, value: []const u8) !void {
            try self._list.setData(index, value);
        }

        pub fn setNull(self: @This(), index: u32) !void {
            try self._list.setNull(index);
        }

        pub fn raw(self: @This()) message.PointerListBuilder {
            return self._list;
        }
    };

    const CapabilityListReader = struct {
        _list: message.PointerListReader,

        pub fn len(self: @This()) u32 {
            return self._list.len();
        }

        pub fn get(self: @This(), index: u32) !message.Capability {
            return try self._list.getCapability(index);
        }

        pub fn raw(self: @This()) message.PointerListReader {
            return self._list;
        }
    };

    const CapabilityListBuilder = struct {
        _list: message.PointerListBuilder,

        pub fn len(self: @This()) u32 {
            return self._list.len();
        }

        pub fn set(self: @This(), index: u32, cap: message.Capability) !void {
            try self._list.setCapability(index, cap);
        }

        pub fn setNull(self: @This(), index: u32) !void {
            try self._list.setNull(index);
        }

        pub fn raw(self: @This()) message.PointerListBuilder {
            return self._list;
        }
    };

    pub const Reader = struct {
        _reader: message.StructReader,

        pub fn init(msg: *const message.Message) !Reader {
            const root = try msg.getRootStruct();
            return .{ ._reader = root };
        }

        pub fn wrap(reader: message.StructReader) Reader {
            return .{ ._reader = reader };
        }

        pub fn getName(self: Reader) ![]const u8 {
            if (self._reader.isPointerNull(0)) return "";
            return try self._reader.readText(0);
        }

        pub fn getTopic(self: Reader) ![]const u8 {
            if (self._reader.isPointerNull(1)) return "";
            return try self._reader.readText(1);
        }
    };

    pub const Builder = struct {
        _builder: message.StructBuilder,

        pub fn init(msg: *message.MessageBuilder) !Builder {
            const builder = try msg.allocateStruct(0, 2);
            return .{ ._builder = builder };
        }

        pub fn wrap(builder: message.StructBuilder) Builder {
            return .{ ._builder = builder };
        }

        pub fn setName(self: *Builder, value: []const u8) !void {
            try self._builder.writeText(0, value);
        }

        pub fn setTopic(self: *Builder, value: []const u8) !void {
            try self._builder.writeText(1, value);
        }
    };
};

pub const CreateRoomResults = struct {
    fn EnumListReader(comptime EnumType: type) type {
        return struct {
            _list: message.U16ListReader,

            pub fn len(self: @This()) u32 {
                return self._list.len();
            }

            pub fn get(self: @This(), index: u32) !EnumType {
                return @enumFromInt(try self._list.get(index));
            }

            pub fn raw(self: @This()) message.U16ListReader {
                return self._list;
            }
        };
    }

    fn EnumListBuilder(comptime EnumType: type) type {
        return struct {
            _list: message.U16ListBuilder,

            pub fn len(self: @This()) u32 {
                return self._list.len();
            }

            pub fn set(self: @This(), index: u32, value: EnumType) !void {
                try self._list.set(index, @intFromEnum(value));
            }

            pub fn raw(self: @This()) message.U16ListBuilder {
                return self._list;
            }
        };
    }

    fn StructListReader(comptime StructType: type) type {
        return struct {
            _list: message.StructListReader,

            pub fn len(self: @This()) u32 {
                return self._list.len();
            }

            pub fn get(self: @This(), index: u32) !StructType.Reader {
                const item = try self._list.get(index);
                return StructType.Reader.wrap(item);
            }

            pub fn raw(self: @This()) message.StructListReader {
                return self._list;
            }
        };
    }

    fn StructListBuilder(comptime StructType: type) type {
        return struct {
            _list: message.StructListBuilder,

            pub fn len(self: @This()) u32 {
                return self._list.len();
            }

            pub fn get(self: @This(), index: u32) !StructType.Builder {
                const item = try self._list.get(index);
                return StructType.Builder.wrap(item);
            }

            pub fn raw(self: @This()) message.StructListBuilder {
                return self._list;
            }
        };
    }

    const DataListReader = struct {
        _list: message.PointerListReader,

        pub fn len(self: @This()) u32 {
            return self._list.len();
        }

        pub fn get(self: @This(), index: u32) ![]const u8 {
            return try self._list.getData(index);
        }

        pub fn raw(self: @This()) message.PointerListReader {
            return self._list;
        }
    };

    const DataListBuilder = struct {
        _list: message.PointerListBuilder,

        pub fn len(self: @This()) u32 {
            return self._list.len();
        }

        pub fn set(self: @This(), index: u32, value: []const u8) !void {
            try self._list.setData(index, value);
        }

        pub fn setNull(self: @This(), index: u32) !void {
            try self._list.setNull(index);
        }

        pub fn raw(self: @This()) message.PointerListBuilder {
            return self._list;
        }
    };

    const CapabilityListReader = struct {
        _list: message.PointerListReader,

        pub fn len(self: @This()) u32 {
            return self._list.len();
        }

        pub fn get(self: @This(), index: u32) !message.Capability {
            return try self._list.getCapability(index);
        }

        pub fn raw(self: @This()) message.PointerListReader {
            return self._list;
        }
    };

    const CapabilityListBuilder = struct {
        _list: message.PointerListBuilder,

        pub fn len(self: @This()) u32 {
            return self._list.len();
        }

        pub fn set(self: @This(), index: u32, cap: message.Capability) !void {
            try self._list.setCapability(index, cap);
        }

        pub fn setNull(self: @This(), index: u32) !void {
            try self._list.setNull(index);
        }

        pub fn raw(self: @This()) message.PointerListBuilder {
            return self._list;
        }
    };

    pub const Reader = struct {
        _reader: message.StructReader,

        pub fn init(msg: *const message.Message) !Reader {
            const root = try msg.getRootStruct();
            return .{ ._reader = root };
        }

        pub fn wrap(reader: message.StructReader) Reader {
            return .{ ._reader = reader };
        }

        pub fn getRoom(self: Reader) !message.Capability {
            return try self._reader.readCapability(0);
        }

        pub fn getInfo(self: Reader) !RoomInfo.Reader {
            const value = try self._reader.readStruct(1);
            return RoomInfo.Reader{ ._reader = value };
        }

        pub fn getStatus(self: Reader) !StatusCode {
            const raw = self._reader.readU16(0) ^ @as(u16, 0);
            return @enumFromInt(raw);
        }
    };

    pub const Builder = struct {
        _builder: message.StructBuilder,

        pub fn init(msg: *message.MessageBuilder) !Builder {
            const builder = try msg.allocateStruct(1, 2);
            return .{ ._builder = builder };
        }

        pub fn wrap(builder: message.StructBuilder) Builder {
            return .{ ._builder = builder };
        }

        pub fn initRoom(self: *Builder) !message.AnyPointerBuilder {
            return try self._builder.getAnyPointer(0);
        }

        pub fn clearRoom(self: *Builder) !void {
            var any = try self._builder.getAnyPointer(0);
            try any.setNull();
        }

        pub fn setRoomCapability(self: *Builder, cap: message.Capability) !void {
            var any = try self._builder.getAnyPointer(0);
            try any.setCapability(cap);
        }

        pub fn initInfo(self: *Builder) !RoomInfo.Builder {
            const builder = try self._builder.initStruct(1, 1, 3);
            return RoomInfo.Builder{ ._builder = builder };
        }

        pub fn setStatus(self: *Builder, value: StatusCode) !void {
            const raw = @as(u16, @intFromEnum(value));
            const stored = raw ^ @as(u16, 0);
            self._builder.writeU16(0, stored);
        }
    };
};

pub const JoinRoomParams = struct {
    fn EnumListReader(comptime EnumType: type) type {
        return struct {
            _list: message.U16ListReader,

            pub fn len(self: @This()) u32 {
                return self._list.len();
            }

            pub fn get(self: @This(), index: u32) !EnumType {
                return @enumFromInt(try self._list.get(index));
            }

            pub fn raw(self: @This()) message.U16ListReader {
                return self._list;
            }
        };
    }

    fn EnumListBuilder(comptime EnumType: type) type {
        return struct {
            _list: message.U16ListBuilder,

            pub fn len(self: @This()) u32 {
                return self._list.len();
            }

            pub fn set(self: @This(), index: u32, value: EnumType) !void {
                try self._list.set(index, @intFromEnum(value));
            }

            pub fn raw(self: @This()) message.U16ListBuilder {
                return self._list;
            }
        };
    }

    fn StructListReader(comptime StructType: type) type {
        return struct {
            _list: message.StructListReader,

            pub fn len(self: @This()) u32 {
                return self._list.len();
            }

            pub fn get(self: @This(), index: u32) !StructType.Reader {
                const item = try self._list.get(index);
                return StructType.Reader.wrap(item);
            }

            pub fn raw(self: @This()) message.StructListReader {
                return self._list;
            }
        };
    }

    fn StructListBuilder(comptime StructType: type) type {
        return struct {
            _list: message.StructListBuilder,

            pub fn len(self: @This()) u32 {
                return self._list.len();
            }

            pub fn get(self: @This(), index: u32) !StructType.Builder {
                const item = try self._list.get(index);
                return StructType.Builder.wrap(item);
            }

            pub fn raw(self: @This()) message.StructListBuilder {
                return self._list;
            }
        };
    }

    const DataListReader = struct {
        _list: message.PointerListReader,

        pub fn len(self: @This()) u32 {
            return self._list.len();
        }

        pub fn get(self: @This(), index: u32) ![]const u8 {
            return try self._list.getData(index);
        }

        pub fn raw(self: @This()) message.PointerListReader {
            return self._list;
        }
    };

    const DataListBuilder = struct {
        _list: message.PointerListBuilder,

        pub fn len(self: @This()) u32 {
            return self._list.len();
        }

        pub fn set(self: @This(), index: u32, value: []const u8) !void {
            try self._list.setData(index, value);
        }

        pub fn setNull(self: @This(), index: u32) !void {
            try self._list.setNull(index);
        }

        pub fn raw(self: @This()) message.PointerListBuilder {
            return self._list;
        }
    };

    const CapabilityListReader = struct {
        _list: message.PointerListReader,

        pub fn len(self: @This()) u32 {
            return self._list.len();
        }

        pub fn get(self: @This(), index: u32) !message.Capability {
            return try self._list.getCapability(index);
        }

        pub fn raw(self: @This()) message.PointerListReader {
            return self._list;
        }
    };

    const CapabilityListBuilder = struct {
        _list: message.PointerListBuilder,

        pub fn len(self: @This()) u32 {
            return self._list.len();
        }

        pub fn set(self: @This(), index: u32, cap: message.Capability) !void {
            try self._list.setCapability(index, cap);
        }

        pub fn setNull(self: @This(), index: u32) !void {
            try self._list.setNull(index);
        }

        pub fn raw(self: @This()) message.PointerListBuilder {
            return self._list;
        }
    };

    pub const Reader = struct {
        _reader: message.StructReader,

        pub fn init(msg: *const message.Message) !Reader {
            const root = try msg.getRootStruct();
            return .{ ._reader = root };
        }

        pub fn wrap(reader: message.StructReader) Reader {
            return .{ ._reader = reader };
        }

        pub fn getName(self: Reader) ![]const u8 {
            if (self._reader.isPointerNull(0)) return "";
            return try self._reader.readText(0);
        }

        pub fn getPlayer(self: Reader) !PlayerInfo.Reader {
            const value = try self._reader.readStruct(1);
            return PlayerInfo.Reader{ ._reader = value };
        }
    };

    pub const Builder = struct {
        _builder: message.StructBuilder,

        pub fn init(msg: *message.MessageBuilder) !Builder {
            const builder = try msg.allocateStruct(0, 2);
            return .{ ._builder = builder };
        }

        pub fn wrap(builder: message.StructBuilder) Builder {
            return .{ ._builder = builder };
        }

        pub fn setName(self: *Builder, value: []const u8) !void {
            try self._builder.writeText(0, value);
        }

        pub fn initPlayer(self: *Builder) !PlayerInfo.Builder {
            const builder = try self._builder.initStruct(1, 1, 2);
            return PlayerInfo.Builder{ ._builder = builder };
        }
    };
};

pub const JoinRoomResults = struct {
    fn EnumListReader(comptime EnumType: type) type {
        return struct {
            _list: message.U16ListReader,

            pub fn len(self: @This()) u32 {
                return self._list.len();
            }

            pub fn get(self: @This(), index: u32) !EnumType {
                return @enumFromInt(try self._list.get(index));
            }

            pub fn raw(self: @This()) message.U16ListReader {
                return self._list;
            }
        };
    }

    fn EnumListBuilder(comptime EnumType: type) type {
        return struct {
            _list: message.U16ListBuilder,

            pub fn len(self: @This()) u32 {
                return self._list.len();
            }

            pub fn set(self: @This(), index: u32, value: EnumType) !void {
                try self._list.set(index, @intFromEnum(value));
            }

            pub fn raw(self: @This()) message.U16ListBuilder {
                return self._list;
            }
        };
    }

    fn StructListReader(comptime StructType: type) type {
        return struct {
            _list: message.StructListReader,

            pub fn len(self: @This()) u32 {
                return self._list.len();
            }

            pub fn get(self: @This(), index: u32) !StructType.Reader {
                const item = try self._list.get(index);
                return StructType.Reader.wrap(item);
            }

            pub fn raw(self: @This()) message.StructListReader {
                return self._list;
            }
        };
    }

    fn StructListBuilder(comptime StructType: type) type {
        return struct {
            _list: message.StructListBuilder,

            pub fn len(self: @This()) u32 {
                return self._list.len();
            }

            pub fn get(self: @This(), index: u32) !StructType.Builder {
                const item = try self._list.get(index);
                return StructType.Builder.wrap(item);
            }

            pub fn raw(self: @This()) message.StructListBuilder {
                return self._list;
            }
        };
    }

    const DataListReader = struct {
        _list: message.PointerListReader,

        pub fn len(self: @This()) u32 {
            return self._list.len();
        }

        pub fn get(self: @This(), index: u32) ![]const u8 {
            return try self._list.getData(index);
        }

        pub fn raw(self: @This()) message.PointerListReader {
            return self._list;
        }
    };

    const DataListBuilder = struct {
        _list: message.PointerListBuilder,

        pub fn len(self: @This()) u32 {
            return self._list.len();
        }

        pub fn set(self: @This(), index: u32, value: []const u8) !void {
            try self._list.setData(index, value);
        }

        pub fn setNull(self: @This(), index: u32) !void {
            try self._list.setNull(index);
        }

        pub fn raw(self: @This()) message.PointerListBuilder {
            return self._list;
        }
    };

    const CapabilityListReader = struct {
        _list: message.PointerListReader,

        pub fn len(self: @This()) u32 {
            return self._list.len();
        }

        pub fn get(self: @This(), index: u32) !message.Capability {
            return try self._list.getCapability(index);
        }

        pub fn raw(self: @This()) message.PointerListReader {
            return self._list;
        }
    };

    const CapabilityListBuilder = struct {
        _list: message.PointerListBuilder,

        pub fn len(self: @This()) u32 {
            return self._list.len();
        }

        pub fn set(self: @This(), index: u32, cap: message.Capability) !void {
            try self._list.setCapability(index, cap);
        }

        pub fn setNull(self: @This(), index: u32) !void {
            try self._list.setNull(index);
        }

        pub fn raw(self: @This()) message.PointerListBuilder {
            return self._list;
        }
    };

    pub const Reader = struct {
        _reader: message.StructReader,

        pub fn init(msg: *const message.Message) !Reader {
            const root = try msg.getRootStruct();
            return .{ ._reader = root };
        }

        pub fn wrap(reader: message.StructReader) Reader {
            return .{ ._reader = reader };
        }

        pub fn getRoom(self: Reader) !message.Capability {
            return try self._reader.readCapability(0);
        }

        pub fn getStatus(self: Reader) !StatusCode {
            const raw = self._reader.readU16(0) ^ @as(u16, 0);
            return @enumFromInt(raw);
        }
    };

    pub const Builder = struct {
        _builder: message.StructBuilder,

        pub fn init(msg: *message.MessageBuilder) !Builder {
            const builder = try msg.allocateStruct(1, 1);
            return .{ ._builder = builder };
        }

        pub fn wrap(builder: message.StructBuilder) Builder {
            return .{ ._builder = builder };
        }

        pub fn initRoom(self: *Builder) !message.AnyPointerBuilder {
            return try self._builder.getAnyPointer(0);
        }

        pub fn clearRoom(self: *Builder) !void {
            var any = try self._builder.getAnyPointer(0);
            try any.setNull();
        }

        pub fn setRoomCapability(self: *Builder, cap: message.Capability) !void {
            var any = try self._builder.getAnyPointer(0);
            try any.setCapability(cap);
        }

        pub fn setStatus(self: *Builder, value: StatusCode) !void {
            const raw = @as(u16, @intFromEnum(value));
            const stored = raw ^ @as(u16, 0);
            self._builder.writeU16(0, stored);
        }
    };
};

pub const ListRoomsParams = struct {
    fn EnumListReader(comptime EnumType: type) type {
        return struct {
            _list: message.U16ListReader,

            pub fn len(self: @This()) u32 {
                return self._list.len();
            }

            pub fn get(self: @This(), index: u32) !EnumType {
                return @enumFromInt(try self._list.get(index));
            }

            pub fn raw(self: @This()) message.U16ListReader {
                return self._list;
            }
        };
    }

    fn EnumListBuilder(comptime EnumType: type) type {
        return struct {
            _list: message.U16ListBuilder,

            pub fn len(self: @This()) u32 {
                return self._list.len();
            }

            pub fn set(self: @This(), index: u32, value: EnumType) !void {
                try self._list.set(index, @intFromEnum(value));
            }

            pub fn raw(self: @This()) message.U16ListBuilder {
                return self._list;
            }
        };
    }

    fn StructListReader(comptime StructType: type) type {
        return struct {
            _list: message.StructListReader,

            pub fn len(self: @This()) u32 {
                return self._list.len();
            }

            pub fn get(self: @This(), index: u32) !StructType.Reader {
                const item = try self._list.get(index);
                return StructType.Reader.wrap(item);
            }

            pub fn raw(self: @This()) message.StructListReader {
                return self._list;
            }
        };
    }

    fn StructListBuilder(comptime StructType: type) type {
        return struct {
            _list: message.StructListBuilder,

            pub fn len(self: @This()) u32 {
                return self._list.len();
            }

            pub fn get(self: @This(), index: u32) !StructType.Builder {
                const item = try self._list.get(index);
                return StructType.Builder.wrap(item);
            }

            pub fn raw(self: @This()) message.StructListBuilder {
                return self._list;
            }
        };
    }

    const DataListReader = struct {
        _list: message.PointerListReader,

        pub fn len(self: @This()) u32 {
            return self._list.len();
        }

        pub fn get(self: @This(), index: u32) ![]const u8 {
            return try self._list.getData(index);
        }

        pub fn raw(self: @This()) message.PointerListReader {
            return self._list;
        }
    };

    const DataListBuilder = struct {
        _list: message.PointerListBuilder,

        pub fn len(self: @This()) u32 {
            return self._list.len();
        }

        pub fn set(self: @This(), index: u32, value: []const u8) !void {
            try self._list.setData(index, value);
        }

        pub fn setNull(self: @This(), index: u32) !void {
            try self._list.setNull(index);
        }

        pub fn raw(self: @This()) message.PointerListBuilder {
            return self._list;
        }
    };

    const CapabilityListReader = struct {
        _list: message.PointerListReader,

        pub fn len(self: @This()) u32 {
            return self._list.len();
        }

        pub fn get(self: @This(), index: u32) !message.Capability {
            return try self._list.getCapability(index);
        }

        pub fn raw(self: @This()) message.PointerListReader {
            return self._list;
        }
    };

    const CapabilityListBuilder = struct {
        _list: message.PointerListBuilder,

        pub fn len(self: @This()) u32 {
            return self._list.len();
        }

        pub fn set(self: @This(), index: u32, cap: message.Capability) !void {
            try self._list.setCapability(index, cap);
        }

        pub fn setNull(self: @This(), index: u32) !void {
            try self._list.setNull(index);
        }

        pub fn raw(self: @This()) message.PointerListBuilder {
            return self._list;
        }
    };

    pub const Reader = struct {
        _reader: message.StructReader,

        pub fn init(msg: *const message.Message) !Reader {
            const root = try msg.getRootStruct();
            return .{ ._reader = root };
        }

        pub fn wrap(reader: message.StructReader) Reader {
            return .{ ._reader = reader };
        }
    };

    pub const Builder = struct {
        _builder: message.StructBuilder,

        pub fn init(msg: *message.MessageBuilder) !Builder {
            const builder = try msg.allocateStruct(0, 0);
            return .{ ._builder = builder };
        }

        pub fn wrap(builder: message.StructBuilder) Builder {
            return .{ ._builder = builder };
        }
    };
};

pub const ListRoomsResults = struct {
    fn EnumListReader(comptime EnumType: type) type {
        return struct {
            _list: message.U16ListReader,

            pub fn len(self: @This()) u32 {
                return self._list.len();
            }

            pub fn get(self: @This(), index: u32) !EnumType {
                return @enumFromInt(try self._list.get(index));
            }

            pub fn raw(self: @This()) message.U16ListReader {
                return self._list;
            }
        };
    }

    fn EnumListBuilder(comptime EnumType: type) type {
        return struct {
            _list: message.U16ListBuilder,

            pub fn len(self: @This()) u32 {
                return self._list.len();
            }

            pub fn set(self: @This(), index: u32, value: EnumType) !void {
                try self._list.set(index, @intFromEnum(value));
            }

            pub fn raw(self: @This()) message.U16ListBuilder {
                return self._list;
            }
        };
    }

    fn StructListReader(comptime StructType: type) type {
        return struct {
            _list: message.StructListReader,

            pub fn len(self: @This()) u32 {
                return self._list.len();
            }

            pub fn get(self: @This(), index: u32) !StructType.Reader {
                const item = try self._list.get(index);
                return StructType.Reader.wrap(item);
            }

            pub fn raw(self: @This()) message.StructListReader {
                return self._list;
            }
        };
    }

    fn StructListBuilder(comptime StructType: type) type {
        return struct {
            _list: message.StructListBuilder,

            pub fn len(self: @This()) u32 {
                return self._list.len();
            }

            pub fn get(self: @This(), index: u32) !StructType.Builder {
                const item = try self._list.get(index);
                return StructType.Builder.wrap(item);
            }

            pub fn raw(self: @This()) message.StructListBuilder {
                return self._list;
            }
        };
    }

    const DataListReader = struct {
        _list: message.PointerListReader,

        pub fn len(self: @This()) u32 {
            return self._list.len();
        }

        pub fn get(self: @This(), index: u32) ![]const u8 {
            return try self._list.getData(index);
        }

        pub fn raw(self: @This()) message.PointerListReader {
            return self._list;
        }
    };

    const DataListBuilder = struct {
        _list: message.PointerListBuilder,

        pub fn len(self: @This()) u32 {
            return self._list.len();
        }

        pub fn set(self: @This(), index: u32, value: []const u8) !void {
            try self._list.setData(index, value);
        }

        pub fn setNull(self: @This(), index: u32) !void {
            try self._list.setNull(index);
        }

        pub fn raw(self: @This()) message.PointerListBuilder {
            return self._list;
        }
    };

    const CapabilityListReader = struct {
        _list: message.PointerListReader,

        pub fn len(self: @This()) u32 {
            return self._list.len();
        }

        pub fn get(self: @This(), index: u32) !message.Capability {
            return try self._list.getCapability(index);
        }

        pub fn raw(self: @This()) message.PointerListReader {
            return self._list;
        }
    };

    const CapabilityListBuilder = struct {
        _list: message.PointerListBuilder,

        pub fn len(self: @This()) u32 {
            return self._list.len();
        }

        pub fn set(self: @This(), index: u32, cap: message.Capability) !void {
            try self._list.setCapability(index, cap);
        }

        pub fn setNull(self: @This(), index: u32) !void {
            try self._list.setNull(index);
        }

        pub fn raw(self: @This()) message.PointerListBuilder {
            return self._list;
        }
    };

    pub const Reader = struct {
        _reader: message.StructReader,

        pub fn init(msg: *const message.Message) !Reader {
            const root = try msg.getRootStruct();
            return .{ ._reader = root };
        }

        pub fn wrap(reader: message.StructReader) Reader {
            return .{ ._reader = reader };
        }

        pub fn getRooms(self: Reader) !StructListReader(RoomInfo) {
            const raw = try self._reader.readStructList(0);
            return StructListReader(RoomInfo){ ._list = raw };
        }
    };

    pub const Builder = struct {
        _builder: message.StructBuilder,

        pub fn init(msg: *message.MessageBuilder) !Builder {
            const builder = try msg.allocateStruct(0, 1);
            return .{ ._builder = builder };
        }

        pub fn wrap(builder: message.StructBuilder) Builder {
            return .{ ._builder = builder };
        }

        pub fn initRooms(self: *Builder, element_count: u32) !StructListBuilder(RoomInfo) {
            const raw = try self._builder.writeStructList(0, element_count, 1, 3);
            return StructListBuilder(RoomInfo){ ._list = raw };
        }
    };
};

pub const WhisperParams = struct {
    fn EnumListReader(comptime EnumType: type) type {
        return struct {
            _list: message.U16ListReader,

            pub fn len(self: @This()) u32 {
                return self._list.len();
            }

            pub fn get(self: @This(), index: u32) !EnumType {
                return @enumFromInt(try self._list.get(index));
            }

            pub fn raw(self: @This()) message.U16ListReader {
                return self._list;
            }
        };
    }

    fn EnumListBuilder(comptime EnumType: type) type {
        return struct {
            _list: message.U16ListBuilder,

            pub fn len(self: @This()) u32 {
                return self._list.len();
            }

            pub fn set(self: @This(), index: u32, value: EnumType) !void {
                try self._list.set(index, @intFromEnum(value));
            }

            pub fn raw(self: @This()) message.U16ListBuilder {
                return self._list;
            }
        };
    }

    fn StructListReader(comptime StructType: type) type {
        return struct {
            _list: message.StructListReader,

            pub fn len(self: @This()) u32 {
                return self._list.len();
            }

            pub fn get(self: @This(), index: u32) !StructType.Reader {
                const item = try self._list.get(index);
                return StructType.Reader.wrap(item);
            }

            pub fn raw(self: @This()) message.StructListReader {
                return self._list;
            }
        };
    }

    fn StructListBuilder(comptime StructType: type) type {
        return struct {
            _list: message.StructListBuilder,

            pub fn len(self: @This()) u32 {
                return self._list.len();
            }

            pub fn get(self: @This(), index: u32) !StructType.Builder {
                const item = try self._list.get(index);
                return StructType.Builder.wrap(item);
            }

            pub fn raw(self: @This()) message.StructListBuilder {
                return self._list;
            }
        };
    }

    const DataListReader = struct {
        _list: message.PointerListReader,

        pub fn len(self: @This()) u32 {
            return self._list.len();
        }

        pub fn get(self: @This(), index: u32) ![]const u8 {
            return try self._list.getData(index);
        }

        pub fn raw(self: @This()) message.PointerListReader {
            return self._list;
        }
    };

    const DataListBuilder = struct {
        _list: message.PointerListBuilder,

        pub fn len(self: @This()) u32 {
            return self._list.len();
        }

        pub fn set(self: @This(), index: u32, value: []const u8) !void {
            try self._list.setData(index, value);
        }

        pub fn setNull(self: @This(), index: u32) !void {
            try self._list.setNull(index);
        }

        pub fn raw(self: @This()) message.PointerListBuilder {
            return self._list;
        }
    };

    const CapabilityListReader = struct {
        _list: message.PointerListReader,

        pub fn len(self: @This()) u32 {
            return self._list.len();
        }

        pub fn get(self: @This(), index: u32) !message.Capability {
            return try self._list.getCapability(index);
        }

        pub fn raw(self: @This()) message.PointerListReader {
            return self._list;
        }
    };

    const CapabilityListBuilder = struct {
        _list: message.PointerListBuilder,

        pub fn len(self: @This()) u32 {
            return self._list.len();
        }

        pub fn set(self: @This(), index: u32, cap: message.Capability) !void {
            try self._list.setCapability(index, cap);
        }

        pub fn setNull(self: @This(), index: u32) !void {
            try self._list.setNull(index);
        }

        pub fn raw(self: @This()) message.PointerListBuilder {
            return self._list;
        }
    };

    pub const Reader = struct {
        _reader: message.StructReader,

        pub fn init(msg: *const message.Message) !Reader {
            const root = try msg.getRootStruct();
            return .{ ._reader = root };
        }

        pub fn wrap(reader: message.StructReader) Reader {
            return .{ ._reader = reader };
        }

        pub fn getFrom(self: Reader) !PlayerInfo.Reader {
            const value = try self._reader.readStruct(0);
            return PlayerInfo.Reader{ ._reader = value };
        }

        pub fn getTo(self: Reader) !PlayerId.Reader {
            const value = try self._reader.readStruct(1);
            return PlayerId.Reader{ ._reader = value };
        }

        pub fn getContent(self: Reader) ![]const u8 {
            if (self._reader.isPointerNull(2)) return "";
            return try self._reader.readText(2);
        }
    };

    pub const Builder = struct {
        _builder: message.StructBuilder,

        pub fn init(msg: *message.MessageBuilder) !Builder {
            const builder = try msg.allocateStruct(0, 3);
            return .{ ._builder = builder };
        }

        pub fn wrap(builder: message.StructBuilder) Builder {
            return .{ ._builder = builder };
        }

        pub fn initFrom(self: *Builder) !PlayerInfo.Builder {
            const builder = try self._builder.initStruct(0, 1, 2);
            return PlayerInfo.Builder{ ._builder = builder };
        }

        pub fn initTo(self: *Builder) !PlayerId.Builder {
            const builder = try self._builder.initStruct(1, 1, 0);
            return PlayerId.Builder{ ._builder = builder };
        }

        pub fn setContent(self: *Builder, value: []const u8) !void {
            try self._builder.writeText(2, value);
        }
    };
};

pub const WhisperResults = struct {
    fn EnumListReader(comptime EnumType: type) type {
        return struct {
            _list: message.U16ListReader,

            pub fn len(self: @This()) u32 {
                return self._list.len();
            }

            pub fn get(self: @This(), index: u32) !EnumType {
                return @enumFromInt(try self._list.get(index));
            }

            pub fn raw(self: @This()) message.U16ListReader {
                return self._list;
            }
        };
    }

    fn EnumListBuilder(comptime EnumType: type) type {
        return struct {
            _list: message.U16ListBuilder,

            pub fn len(self: @This()) u32 {
                return self._list.len();
            }

            pub fn set(self: @This(), index: u32, value: EnumType) !void {
                try self._list.set(index, @intFromEnum(value));
            }

            pub fn raw(self: @This()) message.U16ListBuilder {
                return self._list;
            }
        };
    }

    fn StructListReader(comptime StructType: type) type {
        return struct {
            _list: message.StructListReader,

            pub fn len(self: @This()) u32 {
                return self._list.len();
            }

            pub fn get(self: @This(), index: u32) !StructType.Reader {
                const item = try self._list.get(index);
                return StructType.Reader.wrap(item);
            }

            pub fn raw(self: @This()) message.StructListReader {
                return self._list;
            }
        };
    }

    fn StructListBuilder(comptime StructType: type) type {
        return struct {
            _list: message.StructListBuilder,

            pub fn len(self: @This()) u32 {
                return self._list.len();
            }

            pub fn get(self: @This(), index: u32) !StructType.Builder {
                const item = try self._list.get(index);
                return StructType.Builder.wrap(item);
            }

            pub fn raw(self: @This()) message.StructListBuilder {
                return self._list;
            }
        };
    }

    const DataListReader = struct {
        _list: message.PointerListReader,

        pub fn len(self: @This()) u32 {
            return self._list.len();
        }

        pub fn get(self: @This(), index: u32) ![]const u8 {
            return try self._list.getData(index);
        }

        pub fn raw(self: @This()) message.PointerListReader {
            return self._list;
        }
    };

    const DataListBuilder = struct {
        _list: message.PointerListBuilder,

        pub fn len(self: @This()) u32 {
            return self._list.len();
        }

        pub fn set(self: @This(), index: u32, value: []const u8) !void {
            try self._list.setData(index, value);
        }

        pub fn setNull(self: @This(), index: u32) !void {
            try self._list.setNull(index);
        }

        pub fn raw(self: @This()) message.PointerListBuilder {
            return self._list;
        }
    };

    const CapabilityListReader = struct {
        _list: message.PointerListReader,

        pub fn len(self: @This()) u32 {
            return self._list.len();
        }

        pub fn get(self: @This(), index: u32) !message.Capability {
            return try self._list.getCapability(index);
        }

        pub fn raw(self: @This()) message.PointerListReader {
            return self._list;
        }
    };

    const CapabilityListBuilder = struct {
        _list: message.PointerListBuilder,

        pub fn len(self: @This()) u32 {
            return self._list.len();
        }

        pub fn set(self: @This(), index: u32, cap: message.Capability) !void {
            try self._list.setCapability(index, cap);
        }

        pub fn setNull(self: @This(), index: u32) !void {
            try self._list.setNull(index);
        }

        pub fn raw(self: @This()) message.PointerListBuilder {
            return self._list;
        }
    };

    pub const Reader = struct {
        _reader: message.StructReader,

        pub fn init(msg: *const message.Message) !Reader {
            const root = try msg.getRootStruct();
            return .{ ._reader = root };
        }

        pub fn wrap(reader: message.StructReader) Reader {
            return .{ ._reader = reader };
        }

        pub fn getMessage(self: Reader) !ChatMessage.Reader {
            const value = try self._reader.readStruct(0);
            return ChatMessage.Reader{ ._reader = value };
        }

        pub fn getStatus(self: Reader) !StatusCode {
            const raw = self._reader.readU16(0) ^ @as(u16, 0);
            return @enumFromInt(raw);
        }
    };

    pub const Builder = struct {
        _builder: message.StructBuilder,

        pub fn init(msg: *message.MessageBuilder) !Builder {
            const builder = try msg.allocateStruct(1, 1);
            return .{ ._builder = builder };
        }

        pub fn wrap(builder: message.StructBuilder) Builder {
            return .{ ._builder = builder };
        }

        pub fn initMessage(self: *Builder) !ChatMessage.Builder {
            const builder = try self._builder.initStruct(0, 1, 4);
            return ChatMessage.Builder{ ._builder = builder };
        }

        pub fn setStatus(self: *Builder, value: StatusCode) !void {
            const raw = @as(u16, @intFromEnum(value));
            const stored = raw ^ @as(u16, 0);
            self._builder.writeU16(0, stored);
        }
    };
};
