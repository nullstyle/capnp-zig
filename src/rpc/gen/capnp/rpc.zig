// Generated by capnpc-zig
// Source: capnp/rpc.capnp

const std = @import("std");
const capnpc = @import("capnpc-zig");
const message = capnpc.message;
const schema = capnpc.schema;

pub const CAPNP_SCHEMA_MANIFEST_JSON: []const u8 = "{\"schema\":\"capnp/rpc.capnp\",\"module\":\"rpc\",\"serde\":[{\"id\":15332985841292492822,\"type_name\":\"Accept\",\"to_json_export\":\"capnp_rpc_accept_to_json\",\"from_json_export\":\"capnp_rpc_accept_from_json\"},{\"id\":16811039658553601732,\"type_name\":\"Bootstrap\",\"to_json_export\":\"capnp_rpc_bootstrap_to_json\",\"from_json_export\":\"capnp_rpc_bootstrap_from_json\"},{\"id\":9469473312751832276,\"type_name\":\"Call\",\"to_json_export\":\"capnp_rpc_call_to_json\",\"from_json_export\":\"capnp_rpc_call_from_json\"},{\"id\":9593755465305995440,\"type_name\":\"CapDescriptor\",\"to_json_export\":\"capnp_rpc_cap_descriptor_to_json\",\"from_json_export\":\"capnp_rpc_cap_descriptor_from_json\"},{\"id\":15474736733840799965,\"type_name\":\"Detail\",\"to_json_export\":\"capnp_rpc_detail_to_json\",\"from_json_export\":\"capnp_rpc_detail_from_json\"},{\"id\":17970548384007534353,\"type_name\":\"Disembargo\",\"to_json_export\":\"capnp_rpc_disembargo_to_json\",\"from_json_export\":\"capnp_rpc_disembargo_from_json\"},{\"id\":15430940935639230746,\"type_name\":\"Exception\",\"to_json_export\":\"capnp_rpc_exception_to_json\",\"from_json_export\":\"capnp_rpc_exception_from_json\"},{\"id\":15239388059401719395,\"type_name\":\"Finish\",\"to_json_export\":\"capnp_rpc_finish_to_json\",\"from_json_export\":\"capnp_rpc_finish_from_json\"},{\"id\":18149955118657700271,\"type_name\":\"Join\",\"to_json_export\":\"capnp_rpc_join_to_json\",\"from_json_export\":\"capnp_rpc_join_from_json\"},{\"id\":10500036013887172658,\"type_name\":\"Message\",\"to_json_export\":\"capnp_rpc_message_to_json\",\"from_json_export\":\"capnp_rpc_message_from_json\"},{\"id\":10789521159760378817,\"type_name\":\"MessageTarget\",\"to_json_export\":\"capnp_rpc_message_target_to_json\",\"from_json_export\":\"capnp_rpc_message_target_from_json\"},{\"id\":17516350820840804481,\"type_name\":\"Op\",\"to_json_export\":\"capnp_rpc_op_to_json\",\"from_json_export\":\"capnp_rpc_op_from_json\"},{\"id\":11100916931204903995,\"type_name\":\"Payload\",\"to_json_export\":\"capnp_rpc_payload_to_json\",\"from_json_export\":\"capnp_rpc_payload_from_json\"},{\"id\":15564635848320162976,\"type_name\":\"PromisedAnswer\",\"to_json_export\":\"capnp_rpc_promised_answer_to_json\",\"from_json_export\":\"capnp_rpc_promised_answer_from_json\"},{\"id\":11270825879279873114,\"type_name\":\"Provide\",\"to_json_export\":\"capnp_rpc_provide_to_json\",\"from_json_export\":\"capnp_rpc_provide_from_json\"},{\"id\":12473400923157197975,\"type_name\":\"Release\",\"to_json_export\":\"capnp_rpc_release_to_json\",\"from_json_export\":\"capnp_rpc_release_from_json\"},{\"id\":13529541526594062446,\"type_name\":\"Resolve\",\"to_json_export\":\"capnp_rpc_resolve_to_json\",\"from_json_export\":\"capnp_rpc_resolve_from_json\"},{\"id\":11392333052105676602,\"type_name\":\"Return\",\"to_json_export\":\"capnp_rpc_return_to_json\",\"from_json_export\":\"capnp_rpc_return_from_json\"},{\"id\":13137313365505402252,\"type_name\":\"ThirdPartyAnswer\",\"to_json_export\":\"capnp_rpc_third_party_answer_to_json\",\"from_json_export\":\"capnp_rpc_third_party_answer_from_json\"},{\"id\":15235686326393111165,\"type_name\":\"ThirdPartyCapDescriptor\",\"to_json_export\":\"capnp_rpc_third_party_cap_descriptor_to_json\",\"from_json_export\":\"capnp_rpc_third_party_cap_descriptor_from_json\"}]}";
pub fn capnpSchemaManifestJson() []const u8 {
    return CAPNP_SCHEMA_MANIFEST_JSON;
}

pub const Message = struct {
    const EnumListReader = message.typed_list_helpers.EnumListReader;
    const EnumListBuilder = message.typed_list_helpers.EnumListBuilder;
    const StructListReader = message.typed_list_helpers.StructListReader;
    const StructListBuilder = message.typed_list_helpers.StructListBuilder;
    const DataListReader = message.typed_list_helpers.DataListReader;
    const DataListBuilder = message.typed_list_helpers.DataListBuilder;
    const CapabilityListReader = message.typed_list_helpers.CapabilityListReader;
    const CapabilityListBuilder = message.typed_list_helpers.CapabilityListBuilder;

    pub const WhichTag = enum(u16) {
        unimplemented = 0,
        abort = 1,
        call = 2,
        @"return" = 3,
        finish = 4,
        resolve = 5,
        release = 6,
        obsoleteSave = 7,
        bootstrap = 8,
        obsoleteDelete = 9,
        provide = 10,
        accept = 11,
        join = 12,
        disembargo = 13,
        thirdPartyAnswer = 14,
    };

    pub const Reader = struct {
        _reader: message.StructReader,

        pub fn init(msg: *const message.Message) !Reader {
            const root = try msg.getRootStruct();
            return .{ ._reader = root };
        }

        pub fn wrap(reader: message.StructReader) Reader {
            return .{ ._reader = reader };
        }

        pub fn which(self: Reader) error{InvalidEnumValue}!WhichTag {
            return std.meta.intToEnum(WhichTag, self._reader.readU16(0)) catch return error.InvalidEnumValue;
        }

        pub fn getUnimplemented(self: Reader) !Message.Reader {
            const value = try self._reader.readStruct(0);
            return Message.Reader{ ._reader = value };
        }

        pub fn getAbort(self: Reader) !Exception.Reader {
            const value = try self._reader.readStruct(0);
            return Exception.Reader{ ._reader = value };
        }

        pub fn getCall(self: Reader) !Call.Reader {
            const value = try self._reader.readStruct(0);
            return Call.Reader{ ._reader = value };
        }

        pub fn getReturn(self: Reader) !Return.Reader {
            const value = try self._reader.readStruct(0);
            return Return.Reader{ ._reader = value };
        }

        pub fn getFinish(self: Reader) !Finish.Reader {
            const value = try self._reader.readStruct(0);
            return Finish.Reader{ ._reader = value };
        }

        pub fn getResolve(self: Reader) !Resolve.Reader {
            const value = try self._reader.readStruct(0);
            return Resolve.Reader{ ._reader = value };
        }

        pub fn getRelease(self: Reader) !Release.Reader {
            const value = try self._reader.readStruct(0);
            return Release.Reader{ ._reader = value };
        }

        pub fn getObsoleteSave(self: Reader) !message.AnyPointerReader {
            return try self._reader.readAnyPointer(0);
        }

        pub fn getBootstrap(self: Reader) !Bootstrap.Reader {
            const value = try self._reader.readStruct(0);
            return Bootstrap.Reader{ ._reader = value };
        }

        pub fn getObsoleteDelete(self: Reader) !message.AnyPointerReader {
            return try self._reader.readAnyPointer(0);
        }

        pub fn getProvide(self: Reader) !Provide.Reader {
            const value = try self._reader.readStruct(0);
            return Provide.Reader{ ._reader = value };
        }

        pub fn getAccept(self: Reader) !Accept.Reader {
            const value = try self._reader.readStruct(0);
            return Accept.Reader{ ._reader = value };
        }

        pub fn getJoin(self: Reader) !Join.Reader {
            const value = try self._reader.readStruct(0);
            return Join.Reader{ ._reader = value };
        }

        pub fn getDisembargo(self: Reader) !Disembargo.Reader {
            const value = try self._reader.readStruct(0);
            return Disembargo.Reader{ ._reader = value };
        }

        pub fn getThirdPartyAnswer(self: Reader) !ThirdPartyAnswer.Reader {
            const value = try self._reader.readStruct(0);
            return ThirdPartyAnswer.Reader{ ._reader = value };
        }

    };

    pub const Builder = struct {
        _builder: message.StructBuilder,

        pub fn init(msg: *message.MessageBuilder) !Builder {
            const builder = try msg.allocateStruct(1, 1);
            return .{ ._builder = builder };
        }

        pub fn wrap(builder: message.StructBuilder) Builder {
            return .{ ._builder = builder };
        }

        pub fn initUnimplemented(self: *Builder) !Message.Builder {
            self._builder.writeU16(0, 0);
            const builder = try self._builder.initStruct(0, 1, 1);
            return Message.Builder{ ._builder = builder };
        }

        pub fn initAbort(self: *Builder) !Exception.Builder {
            self._builder.writeU16(0, 1);
            const builder = try self._builder.initStruct(0, 1, 3);
            return Exception.Builder{ ._builder = builder };
        }

        pub fn initCall(self: *Builder) !Call.Builder {
            self._builder.writeU16(0, 2);
            const builder = try self._builder.initStruct(0, 3, 3);
            return Call.Builder{ ._builder = builder };
        }

        pub fn initReturn(self: *Builder) !Return.Builder {
            self._builder.writeU16(0, 3);
            const builder = try self._builder.initStruct(0, 2, 1);
            return Return.Builder{ ._builder = builder };
        }

        pub fn initFinish(self: *Builder) !Finish.Builder {
            self._builder.writeU16(0, 4);
            const builder = try self._builder.initStruct(0, 1, 0);
            return Finish.Builder{ ._builder = builder };
        }

        pub fn initResolve(self: *Builder) !Resolve.Builder {
            self._builder.writeU16(0, 5);
            const builder = try self._builder.initStruct(0, 1, 1);
            return Resolve.Builder{ ._builder = builder };
        }

        pub fn initRelease(self: *Builder) !Release.Builder {
            self._builder.writeU16(0, 6);
            const builder = try self._builder.initStruct(0, 1, 0);
            return Release.Builder{ ._builder = builder };
        }

        pub fn initObsoleteSave(self: *Builder) !message.AnyPointerBuilder {
            self._builder.writeU16(0, 7);
            return try self._builder.getAnyPointer(0);
        }

        pub fn setObsoleteSaveNull(self: *Builder) !void {
            self._builder.writeU16(0, 7);
            var any = try self._builder.getAnyPointer(0);
            try any.setNull();
        }

        pub fn setObsoleteSaveText(self: *Builder, value: []const u8) !void {
            self._builder.writeU16(0, 7);
            var any = try self._builder.getAnyPointer(0);
            try any.setText(value);
        }

        pub fn setObsoleteSaveData(self: *Builder, value: []const u8) !void {
            self._builder.writeU16(0, 7);
            var any = try self._builder.getAnyPointer(0);
            try any.setData(value);
        }

        pub fn setObsoleteSaveCapability(self: *Builder, cap: message.Capability) !void {
            self._builder.writeU16(0, 7);
            var any = try self._builder.getAnyPointer(0);
            try any.setCapability(cap);
        }

        pub fn initBootstrap(self: *Builder) !Bootstrap.Builder {
            self._builder.writeU16(0, 8);
            const builder = try self._builder.initStruct(0, 1, 1);
            return Bootstrap.Builder{ ._builder = builder };
        }

        pub fn initObsoleteDelete(self: *Builder) !message.AnyPointerBuilder {
            self._builder.writeU16(0, 9);
            return try self._builder.getAnyPointer(0);
        }

        pub fn setObsoleteDeleteNull(self: *Builder) !void {
            self._builder.writeU16(0, 9);
            var any = try self._builder.getAnyPointer(0);
            try any.setNull();
        }

        pub fn setObsoleteDeleteText(self: *Builder, value: []const u8) !void {
            self._builder.writeU16(0, 9);
            var any = try self._builder.getAnyPointer(0);
            try any.setText(value);
        }

        pub fn setObsoleteDeleteData(self: *Builder, value: []const u8) !void {
            self._builder.writeU16(0, 9);
            var any = try self._builder.getAnyPointer(0);
            try any.setData(value);
        }

        pub fn setObsoleteDeleteCapability(self: *Builder, cap: message.Capability) !void {
            self._builder.writeU16(0, 9);
            var any = try self._builder.getAnyPointer(0);
            try any.setCapability(cap);
        }

        pub fn initProvide(self: *Builder) !Provide.Builder {
            self._builder.writeU16(0, 10);
            const builder = try self._builder.initStruct(0, 1, 2);
            return Provide.Builder{ ._builder = builder };
        }

        pub fn initAccept(self: *Builder) !Accept.Builder {
            self._builder.writeU16(0, 11);
            const builder = try self._builder.initStruct(0, 1, 2);
            return Accept.Builder{ ._builder = builder };
        }

        pub fn initJoin(self: *Builder) !Join.Builder {
            self._builder.writeU16(0, 12);
            const builder = try self._builder.initStruct(0, 1, 2);
            return Join.Builder{ ._builder = builder };
        }

        pub fn initDisembargo(self: *Builder) !Disembargo.Builder {
            self._builder.writeU16(0, 13);
            const builder = try self._builder.initStruct(0, 1, 2);
            return Disembargo.Builder{ ._builder = builder };
        }

        pub fn initThirdPartyAnswer(self: *Builder) !ThirdPartyAnswer.Builder {
            self._builder.writeU16(0, 14);
            const builder = try self._builder.initStruct(0, 1, 1);
            return ThirdPartyAnswer.Builder{ ._builder = builder };
        }

    };
};

pub const Bootstrap = struct {
    const EnumListReader = message.typed_list_helpers.EnumListReader;
    const EnumListBuilder = message.typed_list_helpers.EnumListBuilder;
    const StructListReader = message.typed_list_helpers.StructListReader;
    const StructListBuilder = message.typed_list_helpers.StructListBuilder;
    const DataListReader = message.typed_list_helpers.DataListReader;
    const DataListBuilder = message.typed_list_helpers.DataListBuilder;
    const CapabilityListReader = message.typed_list_helpers.CapabilityListReader;
    const CapabilityListBuilder = message.typed_list_helpers.CapabilityListBuilder;

    pub const Reader = struct {
        _reader: message.StructReader,

        pub fn init(msg: *const message.Message) !Reader {
            const root = try msg.getRootStruct();
            return .{ ._reader = root };
        }

        pub fn wrap(reader: message.StructReader) Reader {
            return .{ ._reader = reader };
        }

        pub fn getQuestionId(self: Reader) !u32 {
            const raw = self._reader.readU32(0);
            const value = raw ^ @as(u32, 0);
            return value;
        }

        pub fn getDeprecatedObjectId(self: Reader) !message.AnyPointerReader {
            return try self._reader.readAnyPointer(0);
        }

    };

    pub const Builder = struct {
        _builder: message.StructBuilder,

        pub fn init(msg: *message.MessageBuilder) !Builder {
            const builder = try msg.allocateStruct(1, 1);
            return .{ ._builder = builder };
        }

        pub fn wrap(builder: message.StructBuilder) Builder {
            return .{ ._builder = builder };
        }

        pub fn setQuestionId(self: *Builder, value: u32) !void {
            const stored = @as(u32, @bitCast(value)) ^ @as(u32, 0);
            self._builder.writeU32(0, stored);
        }

        pub fn initDeprecatedObjectId(self: *Builder) !message.AnyPointerBuilder {
            return try self._builder.getAnyPointer(0);
        }

        pub fn setDeprecatedObjectIdNull(self: *Builder) !void {
            var any = try self._builder.getAnyPointer(0);
            try any.setNull();
        }

        pub fn setDeprecatedObjectIdText(self: *Builder, value: []const u8) !void {
            var any = try self._builder.getAnyPointer(0);
            try any.setText(value);
        }

        pub fn setDeprecatedObjectIdData(self: *Builder, value: []const u8) !void {
            var any = try self._builder.getAnyPointer(0);
            try any.setData(value);
        }

        pub fn setDeprecatedObjectIdCapability(self: *Builder, cap: message.Capability) !void {
            var any = try self._builder.getAnyPointer(0);
            try any.setCapability(cap);
        }

    };
};

pub const Call = struct {
    const EnumListReader = message.typed_list_helpers.EnumListReader;
    const EnumListBuilder = message.typed_list_helpers.EnumListBuilder;
    const StructListReader = message.typed_list_helpers.StructListReader;
    const StructListBuilder = message.typed_list_helpers.StructListBuilder;
    const DataListReader = message.typed_list_helpers.DataListReader;
    const DataListBuilder = message.typed_list_helpers.DataListBuilder;
    const CapabilityListReader = message.typed_list_helpers.CapabilityListReader;
    const CapabilityListBuilder = message.typed_list_helpers.CapabilityListBuilder;

    pub const SendResultsTo = struct {
        pub const WhichTag = enum(u16) {
            caller = 0,
            yourself = 1,
            thirdParty = 2,
        };

        pub const Reader = struct {
            _reader: message.StructReader,

            pub fn wrap(reader: message.StructReader) @This() {
                return .{ ._reader = reader };
            }

            pub fn which(self: @This()) error{InvalidEnumValue}!WhichTag {
                return std.meta.intToEnum(WhichTag, self._reader.readU16(6)) catch return error.InvalidEnumValue;
            }

            pub fn getCaller(self: @This()) !void {
                _ = self;
                return {};
            }

            pub fn getYourself(self: @This()) !void {
                _ = self;
                return {};
            }

            pub fn getThirdParty(self: @This()) !message.AnyPointerReader {
                return try self._reader.readAnyPointer(2);
            }

        };

        pub const Builder = struct {
            _builder: message.StructBuilder,

            pub fn wrap(builder: message.StructBuilder) @This() {
                return .{ ._builder = builder };
            }

            pub fn setCaller(self: *@This(), value: void) !void {
            self._builder.writeU16(6, 0);
                _ = value;
            }

            pub fn setYourself(self: *@This(), value: void) !void {
            self._builder.writeU16(6, 1);
                _ = value;
            }

            pub fn initThirdParty(self: *@This()) !message.AnyPointerBuilder {
            self._builder.writeU16(6, 2);
                return try self._builder.getAnyPointer(2);
            }

        };
    };

    pub const Reader = struct {
        _reader: message.StructReader,

        pub fn init(msg: *const message.Message) !Reader {
            const root = try msg.getRootStruct();
            return .{ ._reader = root };
        }

        pub fn wrap(reader: message.StructReader) Reader {
            return .{ ._reader = reader };
        }

        pub fn getQuestionId(self: Reader) !u32 {
            const raw = self._reader.readU32(0);
            const value = raw ^ @as(u32, 0);
            return value;
        }

        pub fn getTarget(self: Reader) !MessageTarget.Reader {
            const value = try self._reader.readStruct(0);
            return MessageTarget.Reader{ ._reader = value };
        }

        pub fn getInterfaceId(self: Reader) !u64 {
            const raw = self._reader.readU64(8);
            const value = raw ^ @as(u64, 0);
            return value;
        }

        pub fn getMethodId(self: Reader) !u16 {
            const raw = self._reader.readU16(4);
            const value = raw ^ @as(u16, 0);
            return value;
        }

        pub fn getParams(self: Reader) !Payload.Reader {
            const value = try self._reader.readStruct(1);
            return Payload.Reader{ ._reader = value };
        }

        pub fn getSendResultsTo(self: Reader) SendResultsTo.Reader {
            return .{ ._reader = self._reader };
        }

        pub fn getAllowThirdPartyTailCall(self: Reader) !bool {
            return self._reader.readBool(16, 0) != false;
        }

        pub fn getNoPromisePipelining(self: Reader) !bool {
            return self._reader.readBool(16, 1) != false;
        }

        pub fn getOnlyPromisePipeline(self: Reader) !bool {
            return self._reader.readBool(16, 2) != false;
        }

    };

    pub const Builder = struct {
        _builder: message.StructBuilder,

        pub fn init(msg: *message.MessageBuilder) !Builder {
            const builder = try msg.allocateStruct(3, 3);
            return .{ ._builder = builder };
        }

        pub fn wrap(builder: message.StructBuilder) Builder {
            return .{ ._builder = builder };
        }

        pub fn setQuestionId(self: *Builder, value: u32) !void {
            const stored = @as(u32, @bitCast(value)) ^ @as(u32, 0);
            self._builder.writeU32(0, stored);
        }

        pub fn initTarget(self: *Builder) !MessageTarget.Builder {
            const builder = try self._builder.initStruct(0, 1, 1);
            return MessageTarget.Builder{ ._builder = builder };
        }

        pub fn setInterfaceId(self: *Builder, value: u64) !void {
            const stored = @as(u64, @bitCast(value)) ^ @as(u64, 0);
            self._builder.writeU64(8, stored);
        }

        pub fn setMethodId(self: *Builder, value: u16) !void {
            const stored = @as(u16, @bitCast(value)) ^ @as(u16, 0);
            self._builder.writeU16(4, stored);
        }

        pub fn initParams(self: *Builder) !Payload.Builder {
            const builder = try self._builder.initStruct(1, 0, 2);
            return Payload.Builder{ ._builder = builder };
        }

        pub fn getSendResultsTo(self: *Builder) SendResultsTo.Builder {
            return .{ ._builder = self._builder };
        }

        pub fn setAllowThirdPartyTailCall(self: *Builder, value: bool) !void {
            self._builder.writeBool(16, 0, value != false);
        }

        pub fn setNoPromisePipelining(self: *Builder, value: bool) !void {
            self._builder.writeBool(16, 1, value != false);
        }

        pub fn setOnlyPromisePipeline(self: *Builder, value: bool) !void {
            self._builder.writeBool(16, 2, value != false);
        }

    };
};

pub const Return = struct {
    const EnumListReader = message.typed_list_helpers.EnumListReader;
    const EnumListBuilder = message.typed_list_helpers.EnumListBuilder;
    const StructListReader = message.typed_list_helpers.StructListReader;
    const StructListBuilder = message.typed_list_helpers.StructListBuilder;
    const DataListReader = message.typed_list_helpers.DataListReader;
    const DataListBuilder = message.typed_list_helpers.DataListBuilder;
    const CapabilityListReader = message.typed_list_helpers.CapabilityListReader;
    const CapabilityListBuilder = message.typed_list_helpers.CapabilityListBuilder;

    pub const WhichTag = enum(u16) {
        results = 0,
        exception = 1,
        canceled = 2,
        resultsSentElsewhere = 3,
        takeFromOtherQuestion = 4,
        awaitFromThirdParty = 5,
    };

    pub const Reader = struct {
        _reader: message.StructReader,

        pub fn init(msg: *const message.Message) !Reader {
            const root = try msg.getRootStruct();
            return .{ ._reader = root };
        }

        pub fn wrap(reader: message.StructReader) Reader {
            return .{ ._reader = reader };
        }

        pub fn which(self: Reader) error{InvalidEnumValue}!WhichTag {
            return std.meta.intToEnum(WhichTag, self._reader.readU16(6)) catch return error.InvalidEnumValue;
        }

        pub fn getAnswerId(self: Reader) !u32 {
            const raw = self._reader.readU32(0);
            const value = raw ^ @as(u32, 0);
            return value;
        }

        pub fn getReleaseParamCaps(self: Reader) !bool {
            return self._reader.readBool(4, 0) != true;
        }

        pub fn getResults(self: Reader) !Payload.Reader {
            const value = try self._reader.readStruct(0);
            return Payload.Reader{ ._reader = value };
        }

        pub fn getException(self: Reader) !Exception.Reader {
            const value = try self._reader.readStruct(0);
            return Exception.Reader{ ._reader = value };
        }

        pub fn getCanceled(self: Reader) !void {
            _ = self;
            return {};
        }

        pub fn getResultsSentElsewhere(self: Reader) !void {
            _ = self;
            return {};
        }

        pub fn getTakeFromOtherQuestion(self: Reader) !u32 {
            const raw = self._reader.readU32(8);
            const value = raw ^ @as(u32, 0);
            return value;
        }

        pub fn getAwaitFromThirdParty(self: Reader) !message.AnyPointerReader {
            return try self._reader.readAnyPointer(0);
        }

        pub fn getNoFinishNeeded(self: Reader) !bool {
            return self._reader.readBool(4, 1) != false;
        }

    };

    pub const Builder = struct {
        _builder: message.StructBuilder,

        pub fn init(msg: *message.MessageBuilder) !Builder {
            const builder = try msg.allocateStruct(2, 1);
            return .{ ._builder = builder };
        }

        pub fn wrap(builder: message.StructBuilder) Builder {
            return .{ ._builder = builder };
        }

        pub fn setAnswerId(self: *Builder, value: u32) !void {
            const stored = @as(u32, @bitCast(value)) ^ @as(u32, 0);
            self._builder.writeU32(0, stored);
        }

        pub fn setReleaseParamCaps(self: *Builder, value: bool) !void {
            self._builder.writeBool(4, 0, value != true);
        }

        pub fn initResults(self: *Builder) !Payload.Builder {
            self._builder.writeU16(6, 0);
            const builder = try self._builder.initStruct(0, 0, 2);
            return Payload.Builder{ ._builder = builder };
        }

        pub fn initException(self: *Builder) !Exception.Builder {
            self._builder.writeU16(6, 1);
            const builder = try self._builder.initStruct(0, 1, 3);
            return Exception.Builder{ ._builder = builder };
        }

        pub fn setCanceled(self: *Builder, value: void) !void {
            self._builder.writeU16(6, 2);
            _ = value;
        }

        pub fn setResultsSentElsewhere(self: *Builder, value: void) !void {
            self._builder.writeU16(6, 3);
            _ = value;
        }

        pub fn setTakeFromOtherQuestion(self: *Builder, value: u32) !void {
            self._builder.writeU16(6, 4);
            const stored = @as(u32, @bitCast(value)) ^ @as(u32, 0);
            self._builder.writeU32(8, stored);
        }

        pub fn initAwaitFromThirdParty(self: *Builder) !message.AnyPointerBuilder {
            self._builder.writeU16(6, 5);
            return try self._builder.getAnyPointer(0);
        }

        pub fn setAwaitFromThirdPartyNull(self: *Builder) !void {
            self._builder.writeU16(6, 5);
            var any = try self._builder.getAnyPointer(0);
            try any.setNull();
        }

        pub fn setAwaitFromThirdPartyText(self: *Builder, value: []const u8) !void {
            self._builder.writeU16(6, 5);
            var any = try self._builder.getAnyPointer(0);
            try any.setText(value);
        }

        pub fn setAwaitFromThirdPartyData(self: *Builder, value: []const u8) !void {
            self._builder.writeU16(6, 5);
            var any = try self._builder.getAnyPointer(0);
            try any.setData(value);
        }

        pub fn setAwaitFromThirdPartyCapability(self: *Builder, cap: message.Capability) !void {
            self._builder.writeU16(6, 5);
            var any = try self._builder.getAnyPointer(0);
            try any.setCapability(cap);
        }

        pub fn setNoFinishNeeded(self: *Builder, value: bool) !void {
            self._builder.writeBool(4, 1, value != false);
        }

    };
};

pub const Finish = struct {
    const EnumListReader = message.typed_list_helpers.EnumListReader;
    const EnumListBuilder = message.typed_list_helpers.EnumListBuilder;
    const StructListReader = message.typed_list_helpers.StructListReader;
    const StructListBuilder = message.typed_list_helpers.StructListBuilder;
    const DataListReader = message.typed_list_helpers.DataListReader;
    const DataListBuilder = message.typed_list_helpers.DataListBuilder;
    const CapabilityListReader = message.typed_list_helpers.CapabilityListReader;
    const CapabilityListBuilder = message.typed_list_helpers.CapabilityListBuilder;

    pub const Reader = struct {
        _reader: message.StructReader,

        pub fn init(msg: *const message.Message) !Reader {
            const root = try msg.getRootStruct();
            return .{ ._reader = root };
        }

        pub fn wrap(reader: message.StructReader) Reader {
            return .{ ._reader = reader };
        }

        pub fn getQuestionId(self: Reader) !u32 {
            const raw = self._reader.readU32(0);
            const value = raw ^ @as(u32, 0);
            return value;
        }

        pub fn getReleaseResultCaps(self: Reader) !bool {
            return self._reader.readBool(4, 0) != true;
        }

        pub fn getRequireEarlyCancellationWorkaround(self: Reader) !bool {
            return self._reader.readBool(4, 1) != true;
        }

    };

    pub const Builder = struct {
        _builder: message.StructBuilder,

        pub fn init(msg: *message.MessageBuilder) !Builder {
            const builder = try msg.allocateStruct(1, 0);
            return .{ ._builder = builder };
        }

        pub fn wrap(builder: message.StructBuilder) Builder {
            return .{ ._builder = builder };
        }

        pub fn setQuestionId(self: *Builder, value: u32) !void {
            const stored = @as(u32, @bitCast(value)) ^ @as(u32, 0);
            self._builder.writeU32(0, stored);
        }

        pub fn setReleaseResultCaps(self: *Builder, value: bool) !void {
            self._builder.writeBool(4, 0, value != true);
        }

        pub fn setRequireEarlyCancellationWorkaround(self: *Builder, value: bool) !void {
            self._builder.writeBool(4, 1, value != true);
        }

    };
};

pub const Resolve = struct {
    const EnumListReader = message.typed_list_helpers.EnumListReader;
    const EnumListBuilder = message.typed_list_helpers.EnumListBuilder;
    const StructListReader = message.typed_list_helpers.StructListReader;
    const StructListBuilder = message.typed_list_helpers.StructListBuilder;
    const DataListReader = message.typed_list_helpers.DataListReader;
    const DataListBuilder = message.typed_list_helpers.DataListBuilder;
    const CapabilityListReader = message.typed_list_helpers.CapabilityListReader;
    const CapabilityListBuilder = message.typed_list_helpers.CapabilityListBuilder;

    pub const WhichTag = enum(u16) {
        cap = 0,
        exception = 1,
    };

    pub const Reader = struct {
        _reader: message.StructReader,

        pub fn init(msg: *const message.Message) !Reader {
            const root = try msg.getRootStruct();
            return .{ ._reader = root };
        }

        pub fn wrap(reader: message.StructReader) Reader {
            return .{ ._reader = reader };
        }

        pub fn which(self: Reader) error{InvalidEnumValue}!WhichTag {
            return std.meta.intToEnum(WhichTag, self._reader.readU16(4)) catch return error.InvalidEnumValue;
        }

        pub fn getPromiseId(self: Reader) !u32 {
            const raw = self._reader.readU32(0);
            const value = raw ^ @as(u32, 0);
            return value;
        }

        pub fn getCap(self: Reader) !CapDescriptor.Reader {
            const value = try self._reader.readStruct(0);
            return CapDescriptor.Reader{ ._reader = value };
        }

        pub fn getException(self: Reader) !Exception.Reader {
            const value = try self._reader.readStruct(0);
            return Exception.Reader{ ._reader = value };
        }

    };

    pub const Builder = struct {
        _builder: message.StructBuilder,

        pub fn init(msg: *message.MessageBuilder) !Builder {
            const builder = try msg.allocateStruct(1, 1);
            return .{ ._builder = builder };
        }

        pub fn wrap(builder: message.StructBuilder) Builder {
            return .{ ._builder = builder };
        }

        pub fn setPromiseId(self: *Builder, value: u32) !void {
            const stored = @as(u32, @bitCast(value)) ^ @as(u32, 0);
            self._builder.writeU32(0, stored);
        }

        pub fn initCap(self: *Builder) !CapDescriptor.Builder {
            self._builder.writeU16(4, 0);
            const builder = try self._builder.initStruct(0, 1, 1);
            return CapDescriptor.Builder{ ._builder = builder };
        }

        pub fn initException(self: *Builder) !Exception.Builder {
            self._builder.writeU16(4, 1);
            const builder = try self._builder.initStruct(0, 1, 3);
            return Exception.Builder{ ._builder = builder };
        }

    };
};

pub const Release = struct {
    const EnumListReader = message.typed_list_helpers.EnumListReader;
    const EnumListBuilder = message.typed_list_helpers.EnumListBuilder;
    const StructListReader = message.typed_list_helpers.StructListReader;
    const StructListBuilder = message.typed_list_helpers.StructListBuilder;
    const DataListReader = message.typed_list_helpers.DataListReader;
    const DataListBuilder = message.typed_list_helpers.DataListBuilder;
    const CapabilityListReader = message.typed_list_helpers.CapabilityListReader;
    const CapabilityListBuilder = message.typed_list_helpers.CapabilityListBuilder;

    pub const Reader = struct {
        _reader: message.StructReader,

        pub fn init(msg: *const message.Message) !Reader {
            const root = try msg.getRootStruct();
            return .{ ._reader = root };
        }

        pub fn wrap(reader: message.StructReader) Reader {
            return .{ ._reader = reader };
        }

        pub fn getId(self: Reader) !u32 {
            const raw = self._reader.readU32(0);
            const value = raw ^ @as(u32, 0);
            return value;
        }

        pub fn getReferenceCount(self: Reader) !u32 {
            const raw = self._reader.readU32(4);
            const value = raw ^ @as(u32, 0);
            return value;
        }

    };

    pub const Builder = struct {
        _builder: message.StructBuilder,

        pub fn init(msg: *message.MessageBuilder) !Builder {
            const builder = try msg.allocateStruct(1, 0);
            return .{ ._builder = builder };
        }

        pub fn wrap(builder: message.StructBuilder) Builder {
            return .{ ._builder = builder };
        }

        pub fn setId(self: *Builder, value: u32) !void {
            const stored = @as(u32, @bitCast(value)) ^ @as(u32, 0);
            self._builder.writeU32(0, stored);
        }

        pub fn setReferenceCount(self: *Builder, value: u32) !void {
            const stored = @as(u32, @bitCast(value)) ^ @as(u32, 0);
            self._builder.writeU32(4, stored);
        }

    };
};

pub const Disembargo = struct {
    const EnumListReader = message.typed_list_helpers.EnumListReader;
    const EnumListBuilder = message.typed_list_helpers.EnumListBuilder;
    const StructListReader = message.typed_list_helpers.StructListReader;
    const StructListBuilder = message.typed_list_helpers.StructListBuilder;
    const DataListReader = message.typed_list_helpers.DataListReader;
    const DataListBuilder = message.typed_list_helpers.DataListBuilder;
    const CapabilityListReader = message.typed_list_helpers.CapabilityListReader;
    const CapabilityListBuilder = message.typed_list_helpers.CapabilityListBuilder;

    pub const Context = struct {
        pub const WhichTag = enum(u16) {
            senderLoopback = 0,
            receiverLoopback = 1,
            accept = 2,
        };

        pub const Reader = struct {
            _reader: message.StructReader,

            pub fn wrap(reader: message.StructReader) @This() {
                return .{ ._reader = reader };
            }

            pub fn which(self: @This()) error{InvalidEnumValue}!WhichTag {
                return std.meta.intToEnum(WhichTag, self._reader.readU16(4)) catch return error.InvalidEnumValue;
            }

            pub fn getSenderLoopback(self: @This()) !u32 {
                const raw = self._reader.readU32(0);
                const value = raw ^ @as(u32, 0);
                return value;
            }

            pub fn getReceiverLoopback(self: @This()) !u32 {
                const raw = self._reader.readU32(0);
                const value = raw ^ @as(u32, 0);
                return value;
            }

            pub fn getAccept(self: @This()) ![]const u8 {
                if (self._reader.isPointerNull(1)) return &[_]u8{};
                return try self._reader.readData(1);
            }

        };

        pub const Builder = struct {
            _builder: message.StructBuilder,

            pub fn wrap(builder: message.StructBuilder) @This() {
                return .{ ._builder = builder };
            }

            pub fn setSenderLoopback(self: *@This(), value: u32) !void {
            self._builder.writeU16(4, 0);
                const stored = @as(u32, @bitCast(value)) ^ @as(u32, 0);
                self._builder.writeU32(0, stored);
            }

            pub fn setReceiverLoopback(self: *@This(), value: u32) !void {
            self._builder.writeU16(4, 1);
                const stored = @as(u32, @bitCast(value)) ^ @as(u32, 0);
                self._builder.writeU32(0, stored);
            }

            pub fn setAccept(self: *@This(), value: []const u8) !void {
            self._builder.writeU16(4, 2);
                try self._builder.writeData(1, value);
            }

        };
    };

    pub const Reader = struct {
        _reader: message.StructReader,

        pub fn init(msg: *const message.Message) !Reader {
            const root = try msg.getRootStruct();
            return .{ ._reader = root };
        }

        pub fn wrap(reader: message.StructReader) Reader {
            return .{ ._reader = reader };
        }

        pub fn getTarget(self: Reader) !MessageTarget.Reader {
            const value = try self._reader.readStruct(0);
            return MessageTarget.Reader{ ._reader = value };
        }

        pub fn getContext(self: Reader) Context.Reader {
            return .{ ._reader = self._reader };
        }

    };

    pub const Builder = struct {
        _builder: message.StructBuilder,

        pub fn init(msg: *message.MessageBuilder) !Builder {
            const builder = try msg.allocateStruct(1, 2);
            return .{ ._builder = builder };
        }

        pub fn wrap(builder: message.StructBuilder) Builder {
            return .{ ._builder = builder };
        }

        pub fn initTarget(self: *Builder) !MessageTarget.Builder {
            const builder = try self._builder.initStruct(0, 1, 1);
            return MessageTarget.Builder{ ._builder = builder };
        }

        pub fn getContext(self: *Builder) Context.Builder {
            return .{ ._builder = self._builder };
        }

    };
};

pub const Provide = struct {
    const EnumListReader = message.typed_list_helpers.EnumListReader;
    const EnumListBuilder = message.typed_list_helpers.EnumListBuilder;
    const StructListReader = message.typed_list_helpers.StructListReader;
    const StructListBuilder = message.typed_list_helpers.StructListBuilder;
    const DataListReader = message.typed_list_helpers.DataListReader;
    const DataListBuilder = message.typed_list_helpers.DataListBuilder;
    const CapabilityListReader = message.typed_list_helpers.CapabilityListReader;
    const CapabilityListBuilder = message.typed_list_helpers.CapabilityListBuilder;

    pub const Reader = struct {
        _reader: message.StructReader,

        pub fn init(msg: *const message.Message) !Reader {
            const root = try msg.getRootStruct();
            return .{ ._reader = root };
        }

        pub fn wrap(reader: message.StructReader) Reader {
            return .{ ._reader = reader };
        }

        pub fn getQuestionId(self: Reader) !u32 {
            const raw = self._reader.readU32(0);
            const value = raw ^ @as(u32, 0);
            return value;
        }

        pub fn getTarget(self: Reader) !MessageTarget.Reader {
            const value = try self._reader.readStruct(0);
            return MessageTarget.Reader{ ._reader = value };
        }

        pub fn getRecipient(self: Reader) !message.AnyPointerReader {
            return try self._reader.readAnyPointer(1);
        }

    };

    pub const Builder = struct {
        _builder: message.StructBuilder,

        pub fn init(msg: *message.MessageBuilder) !Builder {
            const builder = try msg.allocateStruct(1, 2);
            return .{ ._builder = builder };
        }

        pub fn wrap(builder: message.StructBuilder) Builder {
            return .{ ._builder = builder };
        }

        pub fn setQuestionId(self: *Builder, value: u32) !void {
            const stored = @as(u32, @bitCast(value)) ^ @as(u32, 0);
            self._builder.writeU32(0, stored);
        }

        pub fn initTarget(self: *Builder) !MessageTarget.Builder {
            const builder = try self._builder.initStruct(0, 1, 1);
            return MessageTarget.Builder{ ._builder = builder };
        }

        pub fn initRecipient(self: *Builder) !message.AnyPointerBuilder {
            return try self._builder.getAnyPointer(1);
        }

        pub fn setRecipientNull(self: *Builder) !void {
            var any = try self._builder.getAnyPointer(1);
            try any.setNull();
        }

        pub fn setRecipientText(self: *Builder, value: []const u8) !void {
            var any = try self._builder.getAnyPointer(1);
            try any.setText(value);
        }

        pub fn setRecipientData(self: *Builder, value: []const u8) !void {
            var any = try self._builder.getAnyPointer(1);
            try any.setData(value);
        }

        pub fn setRecipientCapability(self: *Builder, cap: message.Capability) !void {
            var any = try self._builder.getAnyPointer(1);
            try any.setCapability(cap);
        }

    };
};

pub const Accept = struct {
    const EnumListReader = message.typed_list_helpers.EnumListReader;
    const EnumListBuilder = message.typed_list_helpers.EnumListBuilder;
    const StructListReader = message.typed_list_helpers.StructListReader;
    const StructListBuilder = message.typed_list_helpers.StructListBuilder;
    const DataListReader = message.typed_list_helpers.DataListReader;
    const DataListBuilder = message.typed_list_helpers.DataListBuilder;
    const CapabilityListReader = message.typed_list_helpers.CapabilityListReader;
    const CapabilityListBuilder = message.typed_list_helpers.CapabilityListBuilder;

    pub const Reader = struct {
        _reader: message.StructReader,

        pub fn init(msg: *const message.Message) !Reader {
            const root = try msg.getRootStruct();
            return .{ ._reader = root };
        }

        pub fn wrap(reader: message.StructReader) Reader {
            return .{ ._reader = reader };
        }

        pub fn getQuestionId(self: Reader) !u32 {
            const raw = self._reader.readU32(0);
            const value = raw ^ @as(u32, 0);
            return value;
        }

        pub fn getProvision(self: Reader) !message.AnyPointerReader {
            return try self._reader.readAnyPointer(0);
        }

        pub fn getEmbargo(self: Reader) ![]const u8 {
            if (self._reader.isPointerNull(1)) return &[_]u8{};
            return try self._reader.readData(1);
        }

    };

    pub const Builder = struct {
        _builder: message.StructBuilder,

        pub fn init(msg: *message.MessageBuilder) !Builder {
            const builder = try msg.allocateStruct(1, 2);
            return .{ ._builder = builder };
        }

        pub fn wrap(builder: message.StructBuilder) Builder {
            return .{ ._builder = builder };
        }

        pub fn setQuestionId(self: *Builder, value: u32) !void {
            const stored = @as(u32, @bitCast(value)) ^ @as(u32, 0);
            self._builder.writeU32(0, stored);
        }

        pub fn initProvision(self: *Builder) !message.AnyPointerBuilder {
            return try self._builder.getAnyPointer(0);
        }

        pub fn setProvisionNull(self: *Builder) !void {
            var any = try self._builder.getAnyPointer(0);
            try any.setNull();
        }

        pub fn setProvisionText(self: *Builder, value: []const u8) !void {
            var any = try self._builder.getAnyPointer(0);
            try any.setText(value);
        }

        pub fn setProvisionData(self: *Builder, value: []const u8) !void {
            var any = try self._builder.getAnyPointer(0);
            try any.setData(value);
        }

        pub fn setProvisionCapability(self: *Builder, cap: message.Capability) !void {
            var any = try self._builder.getAnyPointer(0);
            try any.setCapability(cap);
        }

        pub fn setEmbargo(self: *Builder, value: []const u8) !void {
            try self._builder.writeData(1, value);
        }

    };
};

pub const ThirdPartyAnswer = struct {
    const EnumListReader = message.typed_list_helpers.EnumListReader;
    const EnumListBuilder = message.typed_list_helpers.EnumListBuilder;
    const StructListReader = message.typed_list_helpers.StructListReader;
    const StructListBuilder = message.typed_list_helpers.StructListBuilder;
    const DataListReader = message.typed_list_helpers.DataListReader;
    const DataListBuilder = message.typed_list_helpers.DataListBuilder;
    const CapabilityListReader = message.typed_list_helpers.CapabilityListReader;
    const CapabilityListBuilder = message.typed_list_helpers.CapabilityListBuilder;

    pub const Reader = struct {
        _reader: message.StructReader,

        pub fn init(msg: *const message.Message) !Reader {
            const root = try msg.getRootStruct();
            return .{ ._reader = root };
        }

        pub fn wrap(reader: message.StructReader) Reader {
            return .{ ._reader = reader };
        }

        pub fn getCompletion(self: Reader) !message.AnyPointerReader {
            return try self._reader.readAnyPointer(0);
        }

        pub fn getAnswerId(self: Reader) !u32 {
            const raw = self._reader.readU32(0);
            const value = raw ^ @as(u32, 0);
            return value;
        }

    };

    pub const Builder = struct {
        _builder: message.StructBuilder,

        pub fn init(msg: *message.MessageBuilder) !Builder {
            const builder = try msg.allocateStruct(1, 1);
            return .{ ._builder = builder };
        }

        pub fn wrap(builder: message.StructBuilder) Builder {
            return .{ ._builder = builder };
        }

        pub fn initCompletion(self: *Builder) !message.AnyPointerBuilder {
            return try self._builder.getAnyPointer(0);
        }

        pub fn setCompletionNull(self: *Builder) !void {
            var any = try self._builder.getAnyPointer(0);
            try any.setNull();
        }

        pub fn setCompletionText(self: *Builder, value: []const u8) !void {
            var any = try self._builder.getAnyPointer(0);
            try any.setText(value);
        }

        pub fn setCompletionData(self: *Builder, value: []const u8) !void {
            var any = try self._builder.getAnyPointer(0);
            try any.setData(value);
        }

        pub fn setCompletionCapability(self: *Builder, cap: message.Capability) !void {
            var any = try self._builder.getAnyPointer(0);
            try any.setCapability(cap);
        }

        pub fn setAnswerId(self: *Builder, value: u32) !void {
            const stored = @as(u32, @bitCast(value)) ^ @as(u32, 0);
            self._builder.writeU32(0, stored);
        }

    };
};

pub const Join = struct {
    const EnumListReader = message.typed_list_helpers.EnumListReader;
    const EnumListBuilder = message.typed_list_helpers.EnumListBuilder;
    const StructListReader = message.typed_list_helpers.StructListReader;
    const StructListBuilder = message.typed_list_helpers.StructListBuilder;
    const DataListReader = message.typed_list_helpers.DataListReader;
    const DataListBuilder = message.typed_list_helpers.DataListBuilder;
    const CapabilityListReader = message.typed_list_helpers.CapabilityListReader;
    const CapabilityListBuilder = message.typed_list_helpers.CapabilityListBuilder;

    pub const Reader = struct {
        _reader: message.StructReader,

        pub fn init(msg: *const message.Message) !Reader {
            const root = try msg.getRootStruct();
            return .{ ._reader = root };
        }

        pub fn wrap(reader: message.StructReader) Reader {
            return .{ ._reader = reader };
        }

        pub fn getQuestionId(self: Reader) !u32 {
            const raw = self._reader.readU32(0);
            const value = raw ^ @as(u32, 0);
            return value;
        }

        pub fn getTarget(self: Reader) !MessageTarget.Reader {
            const value = try self._reader.readStruct(0);
            return MessageTarget.Reader{ ._reader = value };
        }

        pub fn getKeyPart(self: Reader) !message.AnyPointerReader {
            return try self._reader.readAnyPointer(1);
        }

    };

    pub const Builder = struct {
        _builder: message.StructBuilder,

        pub fn init(msg: *message.MessageBuilder) !Builder {
            const builder = try msg.allocateStruct(1, 2);
            return .{ ._builder = builder };
        }

        pub fn wrap(builder: message.StructBuilder) Builder {
            return .{ ._builder = builder };
        }

        pub fn setQuestionId(self: *Builder, value: u32) !void {
            const stored = @as(u32, @bitCast(value)) ^ @as(u32, 0);
            self._builder.writeU32(0, stored);
        }

        pub fn initTarget(self: *Builder) !MessageTarget.Builder {
            const builder = try self._builder.initStruct(0, 1, 1);
            return MessageTarget.Builder{ ._builder = builder };
        }

        pub fn initKeyPart(self: *Builder) !message.AnyPointerBuilder {
            return try self._builder.getAnyPointer(1);
        }

        pub fn setKeyPartNull(self: *Builder) !void {
            var any = try self._builder.getAnyPointer(1);
            try any.setNull();
        }

        pub fn setKeyPartText(self: *Builder, value: []const u8) !void {
            var any = try self._builder.getAnyPointer(1);
            try any.setText(value);
        }

        pub fn setKeyPartData(self: *Builder, value: []const u8) !void {
            var any = try self._builder.getAnyPointer(1);
            try any.setData(value);
        }

        pub fn setKeyPartCapability(self: *Builder, cap: message.Capability) !void {
            var any = try self._builder.getAnyPointer(1);
            try any.setCapability(cap);
        }

    };
};

pub const MessageTarget = struct {
    const EnumListReader = message.typed_list_helpers.EnumListReader;
    const EnumListBuilder = message.typed_list_helpers.EnumListBuilder;
    const StructListReader = message.typed_list_helpers.StructListReader;
    const StructListBuilder = message.typed_list_helpers.StructListBuilder;
    const DataListReader = message.typed_list_helpers.DataListReader;
    const DataListBuilder = message.typed_list_helpers.DataListBuilder;
    const CapabilityListReader = message.typed_list_helpers.CapabilityListReader;
    const CapabilityListBuilder = message.typed_list_helpers.CapabilityListBuilder;

    pub const WhichTag = enum(u16) {
        importedCap = 0,
        promisedAnswer = 1,
    };

    pub const Reader = struct {
        _reader: message.StructReader,

        pub fn init(msg: *const message.Message) !Reader {
            const root = try msg.getRootStruct();
            return .{ ._reader = root };
        }

        pub fn wrap(reader: message.StructReader) Reader {
            return .{ ._reader = reader };
        }

        pub fn which(self: Reader) error{InvalidEnumValue}!WhichTag {
            return std.meta.intToEnum(WhichTag, self._reader.readU16(4)) catch return error.InvalidEnumValue;
        }

        pub fn getImportedCap(self: Reader) !u32 {
            const raw = self._reader.readU32(0);
            const value = raw ^ @as(u32, 0);
            return value;
        }

        pub fn getPromisedAnswer(self: Reader) !PromisedAnswer.Reader {
            const value = try self._reader.readStruct(0);
            return PromisedAnswer.Reader{ ._reader = value };
        }

    };

    pub const Builder = struct {
        _builder: message.StructBuilder,

        pub fn init(msg: *message.MessageBuilder) !Builder {
            const builder = try msg.allocateStruct(1, 1);
            return .{ ._builder = builder };
        }

        pub fn wrap(builder: message.StructBuilder) Builder {
            return .{ ._builder = builder };
        }

        pub fn setImportedCap(self: *Builder, value: u32) !void {
            self._builder.writeU16(4, 0);
            const stored = @as(u32, @bitCast(value)) ^ @as(u32, 0);
            self._builder.writeU32(0, stored);
        }

        pub fn initPromisedAnswer(self: *Builder) !PromisedAnswer.Builder {
            self._builder.writeU16(4, 1);
            const builder = try self._builder.initStruct(0, 1, 1);
            return PromisedAnswer.Builder{ ._builder = builder };
        }

    };
};

pub const Payload = struct {
    const EnumListReader = message.typed_list_helpers.EnumListReader;
    const EnumListBuilder = message.typed_list_helpers.EnumListBuilder;
    const StructListReader = message.typed_list_helpers.StructListReader;
    const StructListBuilder = message.typed_list_helpers.StructListBuilder;
    const DataListReader = message.typed_list_helpers.DataListReader;
    const DataListBuilder = message.typed_list_helpers.DataListBuilder;
    const CapabilityListReader = message.typed_list_helpers.CapabilityListReader;
    const CapabilityListBuilder = message.typed_list_helpers.CapabilityListBuilder;

    pub const Reader = struct {
        _reader: message.StructReader,

        pub fn init(msg: *const message.Message) !Reader {
            const root = try msg.getRootStruct();
            return .{ ._reader = root };
        }

        pub fn wrap(reader: message.StructReader) Reader {
            return .{ ._reader = reader };
        }

        pub fn getContent(self: Reader) !message.AnyPointerReader {
            return try self._reader.readAnyPointer(0);
        }

        pub fn getCapTable(self: Reader) !StructListReader(CapDescriptor) {
            const raw = try self._reader.readStructList(1);
            return StructListReader(CapDescriptor){ ._list = raw };
        }

    };

    pub const Builder = struct {
        _builder: message.StructBuilder,

        pub fn init(msg: *message.MessageBuilder) !Builder {
            const builder = try msg.allocateStruct(0, 2);
            return .{ ._builder = builder };
        }

        pub fn wrap(builder: message.StructBuilder) Builder {
            return .{ ._builder = builder };
        }

        pub fn initContent(self: *Builder) !message.AnyPointerBuilder {
            return try self._builder.getAnyPointer(0);
        }

        pub fn setContentNull(self: *Builder) !void {
            var any = try self._builder.getAnyPointer(0);
            try any.setNull();
        }

        pub fn setContentText(self: *Builder, value: []const u8) !void {
            var any = try self._builder.getAnyPointer(0);
            try any.setText(value);
        }

        pub fn setContentData(self: *Builder, value: []const u8) !void {
            var any = try self._builder.getAnyPointer(0);
            try any.setData(value);
        }

        pub fn setContentCapability(self: *Builder, cap: message.Capability) !void {
            var any = try self._builder.getAnyPointer(0);
            try any.setCapability(cap);
        }

        pub fn initCapTable(self: *Builder, element_count: u32) !StructListBuilder(CapDescriptor) {
            const raw = try self._builder.writeStructList(1, element_count, 1, 1);
            return StructListBuilder(CapDescriptor){ ._list = raw };
        }

    };
};

pub const CapDescriptor = struct {
    const EnumListReader = message.typed_list_helpers.EnumListReader;
    const EnumListBuilder = message.typed_list_helpers.EnumListBuilder;
    const StructListReader = message.typed_list_helpers.StructListReader;
    const StructListBuilder = message.typed_list_helpers.StructListBuilder;
    const DataListReader = message.typed_list_helpers.DataListReader;
    const DataListBuilder = message.typed_list_helpers.DataListBuilder;
    const CapabilityListReader = message.typed_list_helpers.CapabilityListReader;
    const CapabilityListBuilder = message.typed_list_helpers.CapabilityListBuilder;

    pub const WhichTag = enum(u16) {
        none = 0,
        senderHosted = 1,
        senderPromise = 2,
        receiverHosted = 3,
        receiverAnswer = 4,
        thirdPartyHosted = 5,
    };

    pub const Reader = struct {
        _reader: message.StructReader,

        pub fn init(msg: *const message.Message) !Reader {
            const root = try msg.getRootStruct();
            return .{ ._reader = root };
        }

        pub fn wrap(reader: message.StructReader) Reader {
            return .{ ._reader = reader };
        }

        pub fn which(self: Reader) error{InvalidEnumValue}!WhichTag {
            return std.meta.intToEnum(WhichTag, self._reader.readU16(0)) catch return error.InvalidEnumValue;
        }

        pub fn getNone(self: Reader) !void {
            _ = self;
            return {};
        }

        pub fn getSenderHosted(self: Reader) !u32 {
            const raw = self._reader.readU32(4);
            const value = raw ^ @as(u32, 0);
            return value;
        }

        pub fn getSenderPromise(self: Reader) !u32 {
            const raw = self._reader.readU32(4);
            const value = raw ^ @as(u32, 0);
            return value;
        }

        pub fn getReceiverHosted(self: Reader) !u32 {
            const raw = self._reader.readU32(4);
            const value = raw ^ @as(u32, 0);
            return value;
        }

        pub fn getReceiverAnswer(self: Reader) !PromisedAnswer.Reader {
            const value = try self._reader.readStruct(0);
            return PromisedAnswer.Reader{ ._reader = value };
        }

        pub fn getThirdPartyHosted(self: Reader) !ThirdPartyCapDescriptor.Reader {
            const value = try self._reader.readStruct(0);
            return ThirdPartyCapDescriptor.Reader{ ._reader = value };
        }

        pub fn getAttachedFd(self: Reader) !u8 {
            const raw = self._reader.readU8(2);
            const value = raw ^ @as(u8, 255);
            return value;
        }

    };

    pub const Builder = struct {
        _builder: message.StructBuilder,

        pub fn init(msg: *message.MessageBuilder) !Builder {
            const builder = try msg.allocateStruct(1, 1);
            return .{ ._builder = builder };
        }

        pub fn wrap(builder: message.StructBuilder) Builder {
            return .{ ._builder = builder };
        }

        pub fn setNone(self: *Builder, value: void) !void {
            self._builder.writeU16(0, 0);
            _ = value;
        }

        pub fn setSenderHosted(self: *Builder, value: u32) !void {
            self._builder.writeU16(0, 1);
            const stored = @as(u32, @bitCast(value)) ^ @as(u32, 0);
            self._builder.writeU32(4, stored);
        }

        pub fn setSenderPromise(self: *Builder, value: u32) !void {
            self._builder.writeU16(0, 2);
            const stored = @as(u32, @bitCast(value)) ^ @as(u32, 0);
            self._builder.writeU32(4, stored);
        }

        pub fn setReceiverHosted(self: *Builder, value: u32) !void {
            self._builder.writeU16(0, 3);
            const stored = @as(u32, @bitCast(value)) ^ @as(u32, 0);
            self._builder.writeU32(4, stored);
        }

        pub fn initReceiverAnswer(self: *Builder) !PromisedAnswer.Builder {
            self._builder.writeU16(0, 4);
            const builder = try self._builder.initStruct(0, 1, 1);
            return PromisedAnswer.Builder{ ._builder = builder };
        }

        pub fn initThirdPartyHosted(self: *Builder) !ThirdPartyCapDescriptor.Builder {
            self._builder.writeU16(0, 5);
            const builder = try self._builder.initStruct(0, 1, 1);
            return ThirdPartyCapDescriptor.Builder{ ._builder = builder };
        }

        pub fn setAttachedFd(self: *Builder, value: u8) !void {
            const stored = @as(u8, @bitCast(value)) ^ @as(u8, 255);
            self._builder.writeU8(2, stored);
        }

    };
};

pub const PromisedAnswer = struct {
    const EnumListReader = message.typed_list_helpers.EnumListReader;
    const EnumListBuilder = message.typed_list_helpers.EnumListBuilder;
    const StructListReader = message.typed_list_helpers.StructListReader;
    const StructListBuilder = message.typed_list_helpers.StructListBuilder;
    const DataListReader = message.typed_list_helpers.DataListReader;
    const DataListBuilder = message.typed_list_helpers.DataListBuilder;
    const CapabilityListReader = message.typed_list_helpers.CapabilityListReader;
    const CapabilityListBuilder = message.typed_list_helpers.CapabilityListBuilder;

    pub const Reader = struct {
        _reader: message.StructReader,

        pub fn init(msg: *const message.Message) !Reader {
            const root = try msg.getRootStruct();
            return .{ ._reader = root };
        }

        pub fn wrap(reader: message.StructReader) Reader {
            return .{ ._reader = reader };
        }

        pub fn getQuestionId(self: Reader) !u32 {
            const raw = self._reader.readU32(0);
            const value = raw ^ @as(u32, 0);
            return value;
        }

        pub fn getTransform(self: Reader) !StructListReader(Op) {
            const raw = try self._reader.readStructList(0);
            return StructListReader(Op){ ._list = raw };
        }

    };

    pub const Builder = struct {
        _builder: message.StructBuilder,

        pub fn init(msg: *message.MessageBuilder) !Builder {
            const builder = try msg.allocateStruct(1, 1);
            return .{ ._builder = builder };
        }

        pub fn wrap(builder: message.StructBuilder) Builder {
            return .{ ._builder = builder };
        }

        pub fn setQuestionId(self: *Builder, value: u32) !void {
            const stored = @as(u32, @bitCast(value)) ^ @as(u32, 0);
            self._builder.writeU32(0, stored);
        }

        pub fn initTransform(self: *Builder, element_count: u32) !StructListBuilder(Op) {
            const raw = try self._builder.writeStructList(0, element_count, 1, 0);
            return StructListBuilder(Op){ ._list = raw };
        }

    };
};

pub const Op = struct {
    const EnumListReader = message.typed_list_helpers.EnumListReader;
    const EnumListBuilder = message.typed_list_helpers.EnumListBuilder;
    const StructListReader = message.typed_list_helpers.StructListReader;
    const StructListBuilder = message.typed_list_helpers.StructListBuilder;
    const DataListReader = message.typed_list_helpers.DataListReader;
    const DataListBuilder = message.typed_list_helpers.DataListBuilder;
    const CapabilityListReader = message.typed_list_helpers.CapabilityListReader;
    const CapabilityListBuilder = message.typed_list_helpers.CapabilityListBuilder;

    pub const WhichTag = enum(u16) {
        noop = 0,
        getPointerField = 1,
    };

    pub const Reader = struct {
        _reader: message.StructReader,

        pub fn init(msg: *const message.Message) !Reader {
            const root = try msg.getRootStruct();
            return .{ ._reader = root };
        }

        pub fn wrap(reader: message.StructReader) Reader {
            return .{ ._reader = reader };
        }

        pub fn which(self: Reader) error{InvalidEnumValue}!WhichTag {
            return std.meta.intToEnum(WhichTag, self._reader.readU16(0)) catch return error.InvalidEnumValue;
        }

        pub fn getNoop(self: Reader) !void {
            _ = self;
            return {};
        }

        pub fn getGetPointerField(self: Reader) !u16 {
            const raw = self._reader.readU16(2);
            const value = raw ^ @as(u16, 0);
            return value;
        }

    };

    pub const Builder = struct {
        _builder: message.StructBuilder,

        pub fn init(msg: *message.MessageBuilder) !Builder {
            const builder = try msg.allocateStruct(1, 0);
            return .{ ._builder = builder };
        }

        pub fn wrap(builder: message.StructBuilder) Builder {
            return .{ ._builder = builder };
        }

        pub fn setNoop(self: *Builder, value: void) !void {
            self._builder.writeU16(0, 0);
            _ = value;
        }

        pub fn setGetPointerField(self: *Builder, value: u16) !void {
            self._builder.writeU16(0, 1);
            const stored = @as(u16, @bitCast(value)) ^ @as(u16, 0);
            self._builder.writeU16(2, stored);
        }

    };
};

pub const ThirdPartyCapDescriptor = struct {
    const EnumListReader = message.typed_list_helpers.EnumListReader;
    const EnumListBuilder = message.typed_list_helpers.EnumListBuilder;
    const StructListReader = message.typed_list_helpers.StructListReader;
    const StructListBuilder = message.typed_list_helpers.StructListBuilder;
    const DataListReader = message.typed_list_helpers.DataListReader;
    const DataListBuilder = message.typed_list_helpers.DataListBuilder;
    const CapabilityListReader = message.typed_list_helpers.CapabilityListReader;
    const CapabilityListBuilder = message.typed_list_helpers.CapabilityListBuilder;

    pub const Reader = struct {
        _reader: message.StructReader,

        pub fn init(msg: *const message.Message) !Reader {
            const root = try msg.getRootStruct();
            return .{ ._reader = root };
        }

        pub fn wrap(reader: message.StructReader) Reader {
            return .{ ._reader = reader };
        }

        pub fn getId(self: Reader) !message.AnyPointerReader {
            return try self._reader.readAnyPointer(0);
        }

        pub fn getVineId(self: Reader) !u32 {
            const raw = self._reader.readU32(0);
            const value = raw ^ @as(u32, 0);
            return value;
        }

    };

    pub const Builder = struct {
        _builder: message.StructBuilder,

        pub fn init(msg: *message.MessageBuilder) !Builder {
            const builder = try msg.allocateStruct(1, 1);
            return .{ ._builder = builder };
        }

        pub fn wrap(builder: message.StructBuilder) Builder {
            return .{ ._builder = builder };
        }

        pub fn initId(self: *Builder) !message.AnyPointerBuilder {
            return try self._builder.getAnyPointer(0);
        }

        pub fn setIdNull(self: *Builder) !void {
            var any = try self._builder.getAnyPointer(0);
            try any.setNull();
        }

        pub fn setIdText(self: *Builder, value: []const u8) !void {
            var any = try self._builder.getAnyPointer(0);
            try any.setText(value);
        }

        pub fn setIdData(self: *Builder, value: []const u8) !void {
            var any = try self._builder.getAnyPointer(0);
            try any.setData(value);
        }

        pub fn setIdCapability(self: *Builder, cap: message.Capability) !void {
            var any = try self._builder.getAnyPointer(0);
            try any.setCapability(cap);
        }

        pub fn setVineId(self: *Builder, value: u32) !void {
            const stored = @as(u32, @bitCast(value)) ^ @as(u32, 0);
            self._builder.writeU32(0, stored);
        }

    };
};

pub const Exception = struct {
    const EnumListReader = message.typed_list_helpers.EnumListReader;
    const EnumListBuilder = message.typed_list_helpers.EnumListBuilder;
    const StructListReader = message.typed_list_helpers.StructListReader;
    const StructListBuilder = message.typed_list_helpers.StructListBuilder;
    const DataListReader = message.typed_list_helpers.DataListReader;
    const DataListBuilder = message.typed_list_helpers.DataListBuilder;
    const CapabilityListReader = message.typed_list_helpers.CapabilityListReader;
    const CapabilityListBuilder = message.typed_list_helpers.CapabilityListBuilder;

    pub const Reader = struct {
        _reader: message.StructReader,

        pub fn init(msg: *const message.Message) !Reader {
            const root = try msg.getRootStruct();
            return .{ ._reader = root };
        }

        pub fn wrap(reader: message.StructReader) Reader {
            return .{ ._reader = reader };
        }

        pub fn getReason(self: Reader) ![]const u8 {
            if (self._reader.isPointerNull(0)) return "";
            return try self._reader.readText(0);
        }

        pub fn getObsoleteIsCallersFault(self: Reader) !bool {
            return self._reader.readBool(0, 0) != false;
        }

        pub fn getObsoleteDurability(self: Reader) !u16 {
            const raw = self._reader.readU16(2);
            const value = raw ^ @as(u16, 0);
            return value;
        }

        pub fn getType(self: Reader) !Type {
            const raw = self._reader.readU16(4) ^ @as(u16, 0);
            return std.meta.intToEnum(Type, raw) catch return error.InvalidEnumValue;
        }

        pub fn getTrace(self: Reader) ![]const u8 {
            if (self._reader.isPointerNull(1)) return "";
            return try self._reader.readText(1);
        }

        pub fn getDetails(self: Reader) !StructListReader(Detail) {
            const raw = try self._reader.readStructList(2);
            return StructListReader(Detail){ ._list = raw };
        }

    };

    pub const Builder = struct {
        _builder: message.StructBuilder,

        pub fn init(msg: *message.MessageBuilder) !Builder {
            const builder = try msg.allocateStruct(1, 3);
            return .{ ._builder = builder };
        }

        pub fn wrap(builder: message.StructBuilder) Builder {
            return .{ ._builder = builder };
        }

        pub fn setReason(self: *Builder, value: []const u8) !void {
            try self._builder.writeText(0, value);
        }

        pub fn setObsoleteIsCallersFault(self: *Builder, value: bool) !void {
            self._builder.writeBool(0, 0, value != false);
        }

        pub fn setObsoleteDurability(self: *Builder, value: u16) !void {
            const stored = @as(u16, @bitCast(value)) ^ @as(u16, 0);
            self._builder.writeU16(2, stored);
        }

        pub fn setType(self: *Builder, value: Type) !void {
            const raw = @as(u16, @intFromEnum(value));
            const stored = raw ^ @as(u16, 0);
            self._builder.writeU16(4, stored);
        }

        pub fn setTrace(self: *Builder, value: []const u8) !void {
            try self._builder.writeText(1, value);
        }

        pub fn initDetails(self: *Builder, element_count: u32) !StructListBuilder(Detail) {
            const raw = try self._builder.writeStructList(2, element_count, 1, 1);
            return StructListBuilder(Detail){ ._list = raw };
        }

    };
};

pub const Type = enum(u16) {
    Failed = 0,
    Overloaded = 1,
    Disconnected = 2,
    Unimplemented = 3,
};

pub const Detail = struct {
    const EnumListReader = message.typed_list_helpers.EnumListReader;
    const EnumListBuilder = message.typed_list_helpers.EnumListBuilder;
    const StructListReader = message.typed_list_helpers.StructListReader;
    const StructListBuilder = message.typed_list_helpers.StructListBuilder;
    const DataListReader = message.typed_list_helpers.DataListReader;
    const DataListBuilder = message.typed_list_helpers.DataListBuilder;
    const CapabilityListReader = message.typed_list_helpers.CapabilityListReader;
    const CapabilityListBuilder = message.typed_list_helpers.CapabilityListBuilder;

    pub const Reader = struct {
        _reader: message.StructReader,

        pub fn init(msg: *const message.Message) !Reader {
            const root = try msg.getRootStruct();
            return .{ ._reader = root };
        }

        pub fn wrap(reader: message.StructReader) Reader {
            return .{ ._reader = reader };
        }

        pub fn getDetailId(self: Reader) !u64 {
            const raw = self._reader.readU64(0);
            const value = raw ^ @as(u64, 0);
            return value;
        }

        pub fn getData(self: Reader) ![]const u8 {
            if (self._reader.isPointerNull(0)) return &[_]u8{};
            return try self._reader.readData(0);
        }

    };

    pub const Builder = struct {
        _builder: message.StructBuilder,

        pub fn init(msg: *message.MessageBuilder) !Builder {
            const builder = try msg.allocateStruct(1, 1);
            return .{ ._builder = builder };
        }

        pub fn wrap(builder: message.StructBuilder) Builder {
            return .{ ._builder = builder };
        }

        pub fn setDetailId(self: *Builder, value: u64) !void {
            const stored = @as(u64, @bitCast(value)) ^ @as(u64, 0);
            self._builder.writeU64(0, stored);
        }

        pub fn setData(self: *Builder, value: []const u8) !void {
            try self._builder.writeData(0, value);
        }

    };
};

