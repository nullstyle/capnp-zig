// Generated by capnpc-zig
// Source: capnp/persistent.capnp

const std = @import("std");
const capnpc = @import("capnpc-zig");
const message = capnpc.message;
const schema = capnpc.schema;
const rpc = capnpc.rpc;

pub const CAPNP_SCHEMA_MANIFEST_JSON: []const u8 = "{\"schema\":\"capnp/persistent.capnp\",\"module\":\"persistent\",\"serde\":[{\"id\":17829674341603767205,\"type_name\":\"SaveParams\",\"to_json_export\":\"capnp_persistent_save_params_to_json\",\"from_json_export\":\"capnp_persistent_save_params_from_json\"},{\"id\":13215893102637674431,\"type_name\":\"SaveResults\",\"to_json_export\":\"capnp_persistent_save_results_to_json\",\"from_json_export\":\"capnp_persistent_save_results_from_json\"}]}";
pub fn capnpSchemaManifestJson() []const u8 {
    return CAPNP_SCHEMA_MANIFEST_JSON;
}

pub const Persistent = struct {
    pub const interface_id: u64 = 0xc8cb212fcd9f5691;
    pub const Method = enum(u16) {
        Save = 0,
    };

    pub const Save = struct {
        pub const ordinal: u16 = 0;
        pub const is_streaming: bool = false;
        pub const Params = SaveParams;
        pub const Results = SaveResults;
        pub const BuildFn = *const fn (ctx: *anyopaque, params: *Params.Builder) anyerror!void;
        pub const Handler = *const fn (ctx: *anyopaque, peer: *rpc.peer.Peer, params: Params.Reader, results: *Results.Builder, caps: *const rpc.cap_table.InboundCapTable) anyerror!void;
        pub const DeferredHandler = *const fn (ctx: *anyopaque, peer: *rpc.peer.Peer, params: Params.Reader, caps: *const rpc.cap_table.InboundCapTable, sender: ReturnSender) anyerror!void;
        pub const Response = union(enum) {
            results: Results.Reader,
            exception: rpc.protocol.Exception,
            canceled,
            results_sent_elsewhere,
            take_from_other_question: u32,
            accept_from_third_party,
        };
        pub const Callback = *const fn (ctx: *anyopaque, peer: *rpc.peer.Peer, response: Response, caps: *const rpc.cap_table.InboundCapTable) anyerror!void;

        const CallContext = struct {
            user_ctx: *anyopaque,
            build: ?BuildFn,
            callback: Callback,
        };

        const DirectReturnContext = struct {
            handler: Handler,
            ctx: *anyopaque,
            peer: *rpc.peer.Peer,
            params: Params.Reader,
            caps: *const rpc.cap_table.InboundCapTable,
        };

        pub const ReturnSender = struct {
            peer: *rpc.peer.Peer,
            question_id: u32,

            pub fn sendResults(self: ReturnSender, ctx: *anyopaque, build: *const fn (ctx: *anyopaque, ret: *rpc.protocol.ReturnBuilder) anyerror!void) !void {
                try self.peer.sendReturnResults(self.question_id, ctx, build);
            }

            pub fn sendException(self: ReturnSender, reason: []const u8) !void {
                try self.peer.sendReturnException(self.question_id, reason);
            }
        };

        fn callBuild(ctx_ptr: *anyopaque, call: *rpc.protocol.CallBuilder) anyerror!void {
            const ctx: *CallContext = @ptrCast(@alignCast(ctx_ptr));
            var payload = try call.payloadTyped();
            var params_any = try payload.initContent();
            const params_builder = try params_any.initStruct(0, 1);
            var params = Params.Builder.wrap(params_builder);
            if (ctx.build) |build_fn| {
                try build_fn(ctx.user_ctx, &params);
            }
            _ = try call.initCapTableTyped(0);
        }

        fn callReturn(ctx_ptr: *anyopaque, peer: *rpc.peer.Peer, ret: rpc.protocol.Return, caps: *const rpc.cap_table.InboundCapTable) anyerror!void {
            const ctx: *CallContext = @ptrCast(@alignCast(ctx_ptr));
            defer peer.allocator.destroy(ctx);
            var response: Response = undefined;
            switch (ret.tag) {
                .results => {
                    const payload = ret.results orelse return error.MissingReturnPayload;
                    const struct_reader = try payload.content.getStruct();
                    const results = Results.Reader.wrap(struct_reader);
                    response = .{ .results = results };
                },
                .exception => {
                    const ex = ret.exception orelse return error.MissingException;
                    response = .{ .exception = ex };
                },
                .canceled => response = .canceled,
                .resultsSentElsewhere => response = .results_sent_elsewhere,
                .takeFromOtherQuestion => {
                    const qid = ret.take_from_other_question orelse return error.MissingQuestionId;
                    response = .{ .take_from_other_question = qid };
                },
                .awaitFromThirdParty => response = .accept_from_third_party,
            }
            try ctx.callback(ctx.user_ctx, peer, response, caps);
        }

        pub fn handleCallDirect(handler: Handler, deferred_handler: ?DeferredHandler, ctx: *anyopaque, peer: *rpc.peer.Peer, call: rpc.protocol.Call, caps: *const rpc.cap_table.InboundCapTable) anyerror!void {
            const params_struct = try call.params.content.getStruct();
            const params = Params.Reader.wrap(params_struct);
            if (deferred_handler) |deferred_fn| {
                const sender = ReturnSender{ .peer = peer, .question_id = call.question_id };
                try deferred_fn(ctx, peer, params, caps, sender);
            } else {
                var dctx = DirectReturnContext{
                    .handler = handler,
                    .ctx = ctx,
                    .peer = peer,
                    .params = params,
                    .caps = caps,
                };
                try peer.sendReturnResults(call.question_id, &dctx, buildReturnDirect);
            }
        }

        fn handleCall(server: *Server, peer: *rpc.peer.Peer, call: rpc.protocol.Call, caps: *const rpc.cap_table.InboundCapTable) anyerror!void {
            try handleCallDirect(server.vtable.save, server.vtable.save_deferred, server.ctx, peer, call, caps);
        }

        fn buildReturnDirect(ctx_ptr: *anyopaque, ret: *rpc.protocol.ReturnBuilder) anyerror!void {
            const dctx: *DirectReturnContext = @ptrCast(@alignCast(ctx_ptr));
            var payload = try ret.payloadTyped();
            var results_any = try payload.initContent();
            const results_builder = try results_any.initStruct(0, 1);
            var results = Results.Builder.wrap(results_builder);
            try dctx.handler(dctx.ctx, dctx.peer, dctx.params, &results, dctx.caps);
            _ = try ret.initCapTableTyped(0);
        }
    };

    pub const Client = struct {
        peer: *rpc.peer.Peer,
        cap_id: u32,

        pub fn init(peer: *rpc.peer.Peer, cap_id: u32) Client {
            return .{ .peer = peer, .cap_id = cap_id };
        }

        pub fn callSave(self: *Client, user_ctx: *anyopaque, build: ?Save.BuildFn, on_return: Save.Callback) !u32 {
            const ctx = try self.peer.allocator.create(Save.CallContext);
            ctx.* = .{ .user_ctx = user_ctx, .build = build, .callback = on_return };
            return self.peer.sendCall(self.cap_id, interface_id, Save.ordinal, ctx, Save.callBuild, Save.callReturn);
        }

        pub fn fromBootstrap(peer: *rpc.peer.Peer, user_ctx: *anyopaque, callback: BootstrapCallback) !u32 {
            return bootstrap(peer, user_ctx, callback);
        }
    };

    pub const PipelinedClient = struct {
        peer: *rpc.peer.Peer,
        question_id: u32,
        pointer_index: u16,

        pub fn callSave(self: *PipelinedClient, user_ctx: *anyopaque, build: ?Save.BuildFn, on_return: Save.Callback) !u32 {
            const ctx = try self.peer.allocator.create(Save.CallContext);
            ctx.* = .{ .user_ctx = user_ctx, .build = build, .callback = on_return };
            return self.peer.sendCallPromisedWithOps(self.question_id, &[_]rpc.protocol.PromisedAnswerOp{.{ .tag = .getPointerField, .pointer_index = self.pointer_index }}, interface_id, Save.ordinal, ctx, Save.callBuild, Save.callReturn);
        }
    };

    pub const BootstrapResponse = union(enum) {
        client: Client,
        exception: rpc.protocol.Exception,
        canceled,
        results_sent_elsewhere,
        take_from_other_question: u32,
        accept_from_third_party,
    };
    pub const BootstrapCallback = *const fn (ctx: *anyopaque, peer: *rpc.peer.Peer, response: BootstrapResponse) anyerror!void;

    const BootstrapContext = struct {
        user_ctx: *anyopaque,
        callback: BootstrapCallback,
    };

    fn bootstrapReturn(ctx_ptr: *anyopaque, peer: *rpc.peer.Peer, ret: rpc.protocol.Return, caps: *const rpc.cap_table.InboundCapTable) anyerror!void {
        const ctx: *BootstrapContext = @ptrCast(@alignCast(ctx_ptr));
        defer peer.allocator.destroy(ctx);
        var response: BootstrapResponse = undefined;
        switch (ret.tag) {
            .results => {
                const payload = ret.results orelse return error.MissingReturnPayload;
                const cap = try payload.content.getCapability();
                var mutable_caps = caps.*;
                try mutable_caps.retainCapability(cap);
                const resolved = try caps.resolveCapability(cap);
                switch (resolved) {
                    .imported => |imported| response = .{ .client = Client.init(peer, imported.id) },
                    else => return error.UnexpectedBootstrapCapability,
                }
            },
            .exception => {
                const ex = ret.exception orelse return error.MissingException;
                response = .{ .exception = ex };
            },
            .canceled => response = .canceled,
            .resultsSentElsewhere => response = .results_sent_elsewhere,
            .takeFromOtherQuestion => {
                const qid = ret.take_from_other_question orelse return error.MissingQuestionId;
                response = .{ .take_from_other_question = qid };
            },
            .awaitFromThirdParty => response = .accept_from_third_party,
        }
        try ctx.callback(ctx.user_ctx, peer, response);
    }

    pub fn bootstrap(peer: *rpc.peer.Peer, user_ctx: *anyopaque, callback: BootstrapCallback) !u32 {
        const ctx = try peer.allocator.create(BootstrapContext);
        ctx.* = .{ .user_ctx = user_ctx, .callback = callback };
        return peer.sendBootstrap(ctx, bootstrapReturn);
    }

    pub const Server = struct {
        ctx: *anyopaque,
        vtable: VTable,
    };

    pub const VTable = struct {
        save: Save.Handler,
        save_deferred: ?Save.DeferredHandler = null,
    };

    pub fn exportServer(peer: *rpc.peer.Peer, server: *Server) !u32 {
        return peer.addExport(.{ .ctx = server, .on_call = onCall });
    }

    pub fn setBootstrap(peer: *rpc.peer.Peer, server: *Server) !u32 {
        return peer.setBootstrap(.{ .ctx = server, .on_call = onCall });
    }

    fn onCall(ctx: *anyopaque, peer: *rpc.peer.Peer, call: rpc.protocol.Call, caps: *const rpc.cap_table.InboundCapTable) anyerror!void {
        const server: *Server = @ptrCast(@alignCast(ctx));
        switch (call.method_id) {
            Save.ordinal => try Save.handleCall(server, peer, call, caps),
            else => try peer.sendReturnException(call.question_id, "unknown method"),
        }
    }
};

pub const SaveParams = struct {
    const EnumListReader = message.typed_list_helpers.EnumListReader;
    const EnumListBuilder = message.typed_list_helpers.EnumListBuilder;
    const StructListReader = message.typed_list_helpers.StructListReader;
    const StructListBuilder = message.typed_list_helpers.StructListBuilder;
    const DataListReader = message.typed_list_helpers.DataListReader;
    const DataListBuilder = message.typed_list_helpers.DataListBuilder;
    const CapabilityListReader = message.typed_list_helpers.CapabilityListReader;
    const CapabilityListBuilder = message.typed_list_helpers.CapabilityListBuilder;

    pub const Reader = struct {
        _reader: message.StructReader,

        pub fn init(msg: *const message.Message) !Reader {
            const root = try msg.getRootStruct();
            return .{ ._reader = root };
        }

        pub fn wrap(reader: message.StructReader) Reader {
            return .{ ._reader = reader };
        }

        pub fn getSealFor(self: Reader) !message.AnyPointerReader {
            return try self._reader.readAnyPointer(0);
        }
    };

    pub const Builder = struct {
        _builder: message.StructBuilder,

        pub fn init(msg: *message.MessageBuilder) !Builder {
            const builder = try msg.allocateStruct(0, 1);
            return .{ ._builder = builder };
        }

        pub fn wrap(builder: message.StructBuilder) Builder {
            return .{ ._builder = builder };
        }

        pub fn initSealFor(self: *Builder) !message.AnyPointerBuilder {
            return try self._builder.getAnyPointer(0);
        }

        pub fn setSealForNull(self: *Builder) !void {
            var any = try self._builder.getAnyPointer(0);
            try any.setNull();
        }

        pub fn setSealForText(self: *Builder, value: []const u8) !void {
            var any = try self._builder.getAnyPointer(0);
            try any.setText(value);
        }

        pub fn setSealForData(self: *Builder, value: []const u8) !void {
            var any = try self._builder.getAnyPointer(0);
            try any.setData(value);
        }

        pub fn setSealForCapability(self: *Builder, cap: message.Capability) !void {
            var any = try self._builder.getAnyPointer(0);
            try any.setCapability(cap);
        }
    };
};

pub const SaveResults = struct {
    const EnumListReader = message.typed_list_helpers.EnumListReader;
    const EnumListBuilder = message.typed_list_helpers.EnumListBuilder;
    const StructListReader = message.typed_list_helpers.StructListReader;
    const StructListBuilder = message.typed_list_helpers.StructListBuilder;
    const DataListReader = message.typed_list_helpers.DataListReader;
    const DataListBuilder = message.typed_list_helpers.DataListBuilder;
    const CapabilityListReader = message.typed_list_helpers.CapabilityListReader;
    const CapabilityListBuilder = message.typed_list_helpers.CapabilityListBuilder;

    pub const Reader = struct {
        _reader: message.StructReader,

        pub fn init(msg: *const message.Message) !Reader {
            const root = try msg.getRootStruct();
            return .{ ._reader = root };
        }

        pub fn wrap(reader: message.StructReader) Reader {
            return .{ ._reader = reader };
        }

        pub fn getSturdyRef(self: Reader) !message.AnyPointerReader {
            return try self._reader.readAnyPointer(0);
        }
    };

    pub const Builder = struct {
        _builder: message.StructBuilder,

        pub fn init(msg: *message.MessageBuilder) !Builder {
            const builder = try msg.allocateStruct(0, 1);
            return .{ ._builder = builder };
        }

        pub fn wrap(builder: message.StructBuilder) Builder {
            return .{ ._builder = builder };
        }

        pub fn initSturdyRef(self: *Builder) !message.AnyPointerBuilder {
            return try self._builder.getAnyPointer(0);
        }

        pub fn setSturdyRefNull(self: *Builder) !void {
            var any = try self._builder.getAnyPointer(0);
            try any.setNull();
        }

        pub fn setSturdyRefText(self: *Builder, value: []const u8) !void {
            var any = try self._builder.getAnyPointer(0);
            try any.setText(value);
        }

        pub fn setSturdyRefData(self: *Builder, value: []const u8) !void {
            var any = try self._builder.getAnyPointer(0);
            try any.setData(value);
        }

        pub fn setSturdyRefCapability(self: *Builder, cap: message.Capability) !void {
            var any = try self._builder.getAnyPointer(0);
            try any.setCapability(cap);
        }
    };
};

pub const persistent = struct {
    pub const Type = void;
    pub const targets = .{
        .file = false,
        .@"const" = false,
        .@"enum" = false,
        .enumerant = false,
        .@"struct" = false,
        .field = true,
        .@"union" = false,
        .group = false,
        .interface = true,
        .method = false,
        .param = false,
        .annotation = false,
    };
};
