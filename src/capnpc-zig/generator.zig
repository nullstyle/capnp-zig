const std = @import("std");
const schema = @import("../serialization/schema.zig");
const StructGenerator = @import("struct_gen.zig").StructGenerator;
const types = @import("types.zig");
pub const TypeGenerator = types.TypeGenerator;

/// Code generation driver that turns a set of parsed Cap'n Proto schema nodes
/// into idiomatic Zig source code with Reader and Builder types for each struct.
pub const Generator = struct {
    allocator: std.mem.Allocator,
    nodes: []const schema.Node,
    node_map: std.AutoHashMap(schema.Id, usize),
    /// Set during generateFile to the current file's node ID.
    current_file_id: ?schema.Id = null,
    /// Maps imported file node IDs to their Zig module const names.
    import_modules: std.AutoHashMap(schema.Id, []const u8),
    /// Tracks imported files actually referenced by generated type resolution.
    used_import_file_ids: std.AutoHashMap(schema.Id, void),
    /// Emit codegen trace logs when true.
    verbose: bool = false,

    /// Build a generator from the full set of schema nodes, indexing them by ID.
    pub fn init(allocator: std.mem.Allocator, nodes: []const schema.Node) !Generator {
        var node_map = std.AutoHashMap(schema.Id, usize).init(allocator);
        errdefer node_map.deinit();

        for (nodes, 0..) |node, i| {
            try node_map.put(node.id, i);
        }

        return .{
            .allocator = allocator,
            .nodes = nodes,
            .node_map = node_map,
            .import_modules = std.AutoHashMap(schema.Id, []const u8).init(allocator),
            .used_import_file_ids = std.AutoHashMap(schema.Id, void).init(allocator),
        };
    }

    pub fn deinit(self: *Generator) void {
        self.clearImportModules();
        self.import_modules.deinit();
        self.used_import_file_ids.deinit();
        self.node_map.deinit();
    }

    /// Enable/disable verbose codegen traces.
    pub fn setVerbose(self: *Generator, verbose: bool) void {
        self.verbose = verbose;
    }

    fn clearImportModules(self: *Generator) void {
        var it = self.import_modules.valueIterator();
        while (it.next()) |v| self.allocator.free(v.*);
        self.import_modules.clearRetainingCapacity();
    }

    fn verboseLog(self: *const Generator, comptime fmt: []const u8, args: anytype) void {
        if (!self.verbose) return;
        std.debug.print(fmt, args);
    }

    /// Get a node by its ID
    pub fn getNode(self: *const Generator, id: schema.Id) ?*const schema.Node {
        const index = self.node_map.get(id) orelse return null;
        return &self.nodes[index];
    }

    /// Generate Zig source code for a single requested `.capnp` file.
    ///
    /// Walks the file node's nested declarations, emitting struct/enum/const
    /// definitions. Returns an allocator-owned byte slice containing the
    /// generated `.zig` source.
    pub fn generateFile(self: *Generator, requested_file: schema.RequestedFile) ![]const u8 {
        self.verboseLog("capnpc-zig: generating file {s}\n", .{requested_file.filename});

        // Set current file context for cross-file type resolution.
        self.current_file_id = requested_file.id;
        defer self.current_file_id = null;
        self.clearImportModules();
        self.used_import_file_ids.clearRetainingCapacity();

        const file_node = self.getNode(requested_file.id) orelse return error.FileNodeNotFound;
        const needs_rpc = try self.fileNeedsRpc(file_node);

        // Register import module aliases up-front so cross-file type resolution
        // works while generating declarations.
        for (requested_file.imports) |imp| {
            const mod_name = try self.moduleNameFromFilename(imp.name);
            errdefer self.allocator.free(mod_name);
            try self.import_modules.put(imp.id, mod_name);
        }

        // Generate declarations into a body buffer first, then emit only imports
        // that are actually referenced by generated declarations.
        var body = std.ArrayList(u8){};
        defer body.deinit(self.allocator);
        const body_writer = body.writer(self.allocator);

        try self.writeSchemaManifest(requested_file, file_node, body_writer);

        var generated = std.AutoHashMap(schema.Id, void).init(self.allocator);
        defer generated.deinit();

        // Generate code for all nested nodes (including nested definitions).
        for (file_node.nested_nodes) |nested| {
            try self.generateNodeRecursive(nested.id, &generated, &body);
        }

        var output = std.ArrayList(u8){};
        errdefer output.deinit(self.allocator);
        const writer = output.writer(self.allocator);

        // Write file header
        try writer.writeAll("// Generated by capnpc-zig\n");
        try writer.print("// Source: {f}\n\n", .{std.zig.fmtString(requested_file.filename)});
        try writer.writeAll("const std = @import(\"std\");\n");
        try writer.writeAll("const capnpc = @import(\"capnpc-zig\");\n");
        try writer.writeAll("const message = capnpc.message;\n");
        try writer.writeAll("const schema = capnpc.schema;\n");
        if (needs_rpc) {
            try writer.writeAll("const rpc = capnpc.rpc;\n");
        }

        // Emit only imports that are referenced by generated declarations.
        for (requested_file.imports) |imp| {
            if (!self.used_import_file_ids.contains(imp.id)) continue;
            const mod_name = self.import_modules.get(imp.id) orelse continue;
            const import_path = try self.importPathFromCapnpName(imp.name);
            defer self.allocator.free(import_path);
            try writer.print("const {s} = @import(\"{f}\");\n", .{ mod_name, std.zig.fmtString(import_path) });
        }
        try writer.writeByte('\n');

        try writer.writeAll(body.items);

        return output.toOwnedSlice(self.allocator);
    }

    const ManifestSerdeEntry = struct {
        id: u64,
        type_name: []const u8,
        to_json_export: []const u8,
        from_json_export: []const u8,
    };

    const ManifestSerdeJsonEntry = struct {
        id: u64,
        type_name: []const u8,
        to_json_export: []const u8,
        from_json_export: []const u8,
    };

    const SchemaManifestJson = struct {
        schema: []const u8,
        module: []const u8,
        serde: []const ManifestSerdeJsonEntry,
    };

    fn writeSchemaManifest(
        self: *Generator,
        requested_file: schema.RequestedFile,
        file_node: *const schema.Node,
        writer: anytype,
    ) !void {
        const module_name = try self.moduleNameFromFilename(requested_file.filename);
        defer self.allocator.free(module_name);

        var seen = std.AutoHashMap(schema.Id, void).init(self.allocator);
        defer seen.deinit();

        var entries = std.ArrayList(ManifestSerdeEntry){};
        defer {
            for (entries.items) |entry| {
                self.allocator.free(entry.type_name);
                self.allocator.free(entry.to_json_export);
                self.allocator.free(entry.from_json_export);
            }
            entries.deinit(self.allocator);
        }

        for (file_node.nested_nodes) |nested| {
            try self.collectManifestSerdeEntries(nested.id, module_name, &seen, &entries);
        }

        self.sortManifestSerdeEntries(entries.items);

        var json_entries = try self.allocator.alloc(ManifestSerdeJsonEntry, entries.items.len);
        defer self.allocator.free(json_entries);
        for (entries.items, 0..) |entry, i| {
            json_entries[i] = .{
                .id = entry.id,
                .type_name = entry.type_name,
                .to_json_export = entry.to_json_export,
                .from_json_export = entry.from_json_export,
            };
        }

        const manifest_json_bytes = try std.json.Stringify.valueAlloc(self.allocator, SchemaManifestJson{
            .schema = requested_file.filename,
            .module = module_name,
            .serde = json_entries,
        }, .{});
        defer self.allocator.free(manifest_json_bytes);

        try writer.print("pub const CAPNP_SCHEMA_MANIFEST_JSON: []const u8 = \"{f}\";\n", .{
            std.zig.fmtString(manifest_json_bytes),
        });
        try writer.writeAll("pub fn capnpSchemaManifestJson() []const u8 {\n");
        try writer.writeAll("    return CAPNP_SCHEMA_MANIFEST_JSON;\n");
        try writer.writeAll("}\n\n");
    }

    fn collectManifestSerdeEntries(
        self: *Generator,
        id: schema.Id,
        module_name: []const u8,
        seen: *std.AutoHashMap(schema.Id, void),
        entries: *std.ArrayList(ManifestSerdeEntry),
    ) !void {
        if (seen.contains(id)) return;
        const node = self.getNode(id) orelse return;
        try seen.put(id, {});

        if (node.kind == .@"struct") {
            const simple_name = self.getSimpleName(node);
            const type_name = try self.toZigIdentifier(simple_name);
            errdefer self.allocator.free(type_name);
            const type_export = try self.toSnakeCaseLower(simple_name);
            defer self.allocator.free(type_export);

            const to_json = try std.fmt.allocPrint(
                self.allocator,
                "capnp_{s}_{s}_to_json",
                .{ module_name, type_export },
            );
            errdefer self.allocator.free(to_json);
            const from_json = try std.fmt.allocPrint(
                self.allocator,
                "capnp_{s}_{s}_from_json",
                .{ module_name, type_export },
            );
            errdefer self.allocator.free(from_json);

            try entries.append(self.allocator, .{
                .id = node.id,
                .type_name = type_name,
                .to_json_export = to_json,
                .from_json_export = from_json,
            });
        }

        for (node.nested_nodes) |nested| {
            try self.collectManifestSerdeEntries(nested.id, module_name, seen, entries);
        }

        if (node.kind == .interface) {
            const iface = node.interface_node orelse return;
            for (iface.methods) |method| {
                try self.collectManifestSerdeEntries(method.param_struct_type, module_name, seen, entries);
                try self.collectManifestSerdeEntries(method.result_struct_type, module_name, seen, entries);
            }
            // Also include superclass method param/result types
            for (iface.superclasses) |parent_id| {
                const parent_node = self.getNode(parent_id) orelse continue;
                const parent_iface = parent_node.interface_node orelse continue;
                for (parent_iface.methods) |method| {
                    try self.collectManifestSerdeEntries(method.param_struct_type, module_name, seen, entries);
                    try self.collectManifestSerdeEntries(method.result_struct_type, module_name, seen, entries);
                }
            }
        }
    }

    fn sortManifestSerdeEntries(self: *Generator, entries: []ManifestSerdeEntry) void {
        _ = self;
        var i: usize = 1;
        while (i < entries.len) : (i += 1) {
            var j = i;
            while (j > 0 and manifestSerdeEntryLess(entries[j], entries[j - 1])) : (j -= 1) {
                std.mem.swap(ManifestSerdeEntry, &entries[j], &entries[j - 1]);
            }
        }
    }

    fn manifestSerdeEntryLess(a: ManifestSerdeEntry, b: ManifestSerdeEntry) bool {
        const type_order = std.mem.order(u8, a.type_name, b.type_name);
        if (type_order == .lt) return true;
        if (type_order == .gt) return false;
        return a.id < b.id;
    }

    /// Generate code for a single node
    fn generateNode(self: *Generator, node: *const schema.Node, output: *std.ArrayList(u8)) !void {
        self.verboseLog("capnpc-zig: generating node id=0x{x} kind={s}\n", .{ node.id, @tagName(node.kind) });
        const writer = output.writer(self.allocator);

        switch (node.kind) {
            .@"struct" => try self.generateStruct(node, writer),
            .@"enum" => try self.generateEnum(node, writer),
            .interface => try self.generateInterface(node, writer),
            .@"const" => try self.generateConst(node, writer),
            .file => {}, // File nodes are handled separately
            .annotation => try self.generateAnnotation(node, writer),
        }

        if (node.kind != .file) {
            try self.generateAnnotationUses(node, writer);
        }
    }

    fn generateNodeRecursive(
        self: *Generator,
        id: schema.Id,
        generated: *std.AutoHashMap(schema.Id, void),
        output: *std.ArrayList(u8),
    ) !void {
        if (generated.contains(id)) return;
        const node = self.getNode(id) orelse return;
        try generated.put(id, {});

        // Mark group nodes as generated so they don't get generated as top-level types
        // (they are generated inline by their parent struct)
        if (node.kind == .@"struct") {
            if (node.struct_node) |struct_node| {
                for (struct_node.fields) |field| {
                    if (field.group) |group| {
                        try generated.put(group.type_id, {});
                    }
                }
            }
        }

        try self.generateNode(node, output);
        for (node.nested_nodes) |nested| {
            try self.generateNodeRecursive(nested.id, generated, output);
        }
        if (node.kind == .interface) {
            const iface = node.interface_node orelse return;
            for (iface.methods) |method| {
                try self.generateNodeRecursive(method.param_struct_type, generated, output);
                try self.generateNodeRecursive(method.result_struct_type, generated, output);
            }
            // Also ensure superclass method param/result types are generated
            for (iface.superclasses) |parent_id| {
                const parent_node = self.getNode(parent_id) orelse continue;
                const parent_iface = parent_node.interface_node orelse continue;
                for (parent_iface.methods) |method| {
                    try self.generateNodeRecursive(method.param_struct_type, generated, output);
                    try self.generateNodeRecursive(method.result_struct_type, generated, output);
                }
            }
        }
    }

    fn fileNeedsRpc(self: *Generator, file_node: *const schema.Node) !bool {
        var visited = std.AutoHashMap(schema.Id, void).init(self.allocator);
        defer visited.deinit();

        for (file_node.nested_nodes) |nested| {
            if (try self.nodeNeedsRpcRecursive(nested.id, &visited)) return true;
        }
        return false;
    }

    fn nodeNeedsRpcRecursive(
        self: *Generator,
        id: schema.Id,
        visited: *std.AutoHashMap(schema.Id, void),
    ) !bool {
        if (visited.contains(id)) return false;
        try visited.put(id, {});

        const node = self.getNode(id) orelse return false;
        if (self.nodeNeedsRpc(node)) return true;

        for (node.nested_nodes) |nested| {
            if (try self.nodeNeedsRpcRecursive(nested.id, visited)) return true;
        }

        if (node.kind == .interface) {
            const iface = node.interface_node orelse return false;
            for (iface.methods) |method| {
                if (try self.nodeNeedsRpcRecursive(method.param_struct_type, visited)) return true;
                if (try self.nodeNeedsRpcRecursive(method.result_struct_type, visited)) return true;
            }
            for (iface.superclasses) |parent_id| {
                if (try self.nodeNeedsRpcRecursive(parent_id, visited)) return true;
            }
        }

        return false;
    }

    fn nodeNeedsRpc(self: *Generator, node: *const schema.Node) bool {
        return switch (node.kind) {
            .interface => true,
            .@"struct" => blk: {
                const struct_node = node.struct_node orelse break :blk false;
                for (struct_node.fields) |field| {
                    const slot = field.slot orelse continue;
                    if (self.typeNeedsRpc(slot.type)) break :blk true;
                }
                break :blk false;
            },
            else => false,
        };
    }

    fn typeNeedsRpc(self: *Generator, typ: schema.Type) bool {
        return switch (typ) {
            .interface => true,
            .list => |list_info| self.typeNeedsRpc(list_info.element_type.*),
            else => false,
        };
    }

    /// Generate a struct definition
    fn generateStruct(self: *Generator, node: *const schema.Node, writer: anytype) !void {
        var struct_gen = StructGenerator.initWithLookup(self.allocator, lookupNode, self);
        struct_gen.type_prefix_fn = lookupTypePrefix;
        try struct_gen.generate(node, writer);
    }

    /// Generate an enum definition
    fn generateEnum(self: *Generator, node: *const schema.Node, writer: anytype) !void {
        const enum_info = node.enum_node orelse return error.InvalidEnumNode;
        const decl_name = try self.allocTypeDeclName(node);
        defer self.allocator.free(decl_name);

        try writer.print("pub const {s} = enum(u16) {{\n", .{decl_name});

        for (enum_info.enumerants) |enumerant| {
            const zig_name = try self.toZigIdentifier(enumerant.name);
            defer self.allocator.free(zig_name);
            const escaped_name = try types.escapeZigKeyword(self.allocator, zig_name);
            defer self.allocator.free(escaped_name);
            try writer.print("    {s} = {},\n", .{ escaped_name, enumerant.code_order });
        }

        try writer.writeAll("};\n\n");
    }

    /// Info about a single ancestor interface for code generation.
    const AncestorInfo = struct {
        interface_id: u64,
        name: []const u8,
        methods: []const schema.Method,
    };

    /// Walk superclasses recursively to collect all ancestor interfaces (not including self).
    /// Deduplicates by interface_id to handle diamond inheritance.
    fn collectAncestors(self: *Generator, node: *const schema.Node) ![]AncestorInfo {
        var result = std.ArrayList(AncestorInfo){};
        errdefer {
            for (result.items) |a| self.allocator.free(a.name);
            result.deinit(self.allocator);
        }
        var seen = std.AutoHashMap(u64, void).init(self.allocator);
        defer seen.deinit();
        // Exclude self
        try seen.put(node.id, {});
        try self.collectAncestorsRecursive(node, &result, &seen);
        return result.toOwnedSlice(self.allocator);
    }

    fn collectAncestorsRecursive(
        self: *Generator,
        node: *const schema.Node,
        result: *std.ArrayList(AncestorInfo),
        seen: *std.AutoHashMap(u64, void),
    ) !void {
        const iface = node.interface_node orelse return;
        for (iface.superclasses) |parent_id| {
            if (seen.contains(parent_id)) continue;
            try seen.put(parent_id, {});
            const parent_node = self.getNode(parent_id) orelse continue;
            const parent_iface = parent_node.interface_node orelse continue;
            // Recurse into grandparents first (depth-first)
            try self.collectAncestorsRecursive(parent_node, result, seen);
            const parent_name = try self.qualifiedTypeName(parent_id);
            errdefer self.allocator.free(parent_name);
            try result.append(self.allocator, .{
                .interface_id = parent_id,
                .name = parent_name,
                .methods = parent_iface.methods,
            });
        }
    }

    fn freeAncestors(self: *Generator, ancestors: []AncestorInfo) void {
        for (ancestors) |a| self.allocator.free(a.name);
        self.allocator.free(ancestors);
    }

    /// Check whether an interface (or any ancestor) has streaming methods.
    fn hasStreamingMethods(_: *Generator, node: *const schema.Node, ancestors: []const AncestorInfo) bool {
        const iface = node.interface_node orelse return false;
        for (iface.methods) |method| {
            if (method.isStreaming()) return true;
        }
        for (ancestors) |ancestor| {
            for (ancestor.methods) |method| {
                if (method.isStreaming()) return true;
            }
        }
        return false;
    }

    /// Generate an interface definition
    fn generateInterface(self: *Generator, node: *const schema.Node, writer: anytype) !void {
        const interface_info = node.interface_node orelse return error.InvalidInterfaceNode;
        const decl_name = try self.allocTypeDeclName(node);
        defer self.allocator.free(decl_name);

        const ancestors = try self.collectAncestors(node);
        defer self.freeAncestors(ancestors);
        const has_ancestors = ancestors.len > 0;

        try writer.print("pub const {s} = struct {{\n", .{decl_name});
        try writer.print("    pub const interface_id: u64 = 0x{x};\n", .{node.id});
        try writer.writeAll("    pub const Method = enum(u16) {\n");
        for (interface_info.methods) |method| {
            const zig_name = try self.toZigIdentifier(method.name);
            defer self.allocator.free(zig_name);
            const escaped_name = try types.escapeZigKeyword(self.allocator, zig_name);
            defer self.allocator.free(escaped_name);
            try writer.print("        {s} = {},\n", .{ escaped_name, method.code_order });
        }
        try writer.writeAll("    };\n\n");

        for (interface_info.methods) |method| {
            try self.generateMethodStruct(method, writer);
        }

        // --- Client ---
        try writer.writeAll("    pub const Client = struct {\n");
        try writer.writeAll("        peer: *rpc.peer.Peer,\n");
        try writer.writeAll("        cap_id: u32,\n\n");
        try writer.writeAll("        pub fn init(peer: *rpc.peer.Peer, cap_id: u32) Client {\n");
        try writer.writeAll("            return .{ .peer = peer, .cap_id = cap_id };\n");
        try writer.writeAll("        }\n\n");

        // Own call methods
        for (interface_info.methods) |method| {
            try self.generateClientCallMethod(method, "interface_id", null, writer);
        }
        // Inherited call methods
        for (ancestors) |ancestor| {
            for (ancestor.methods) |method| {
                try self.generateClientCallMethod(method, null, ancestor.name, writer);
            }
        }

        // Generate callXxxPipelined methods for own methods with interface-typed results
        for (interface_info.methods) |method| {
            try self.generateClientPipelinedMethod(method, null, writer);
        }
        // Inherited pipelined call methods
        for (ancestors) |ancestor| {
            for (ancestor.methods) |method| {
                try self.generateClientPipelinedMethod(method, ancestor.name, writer);
            }
        }

        try writer.writeAll("        pub fn fromBootstrap(peer: *rpc.peer.Peer, user_ctx: *anyopaque, callback: BootstrapCallback) !u32 {\n");
        try writer.writeAll("            return bootstrap(peer, user_ctx, callback);\n");
        try writer.writeAll("        }\n\n");

        try writer.writeAll("    };\n\n");

        // --- StreamClient (only when interface or ancestors have streaming methods) ---
        if (self.hasStreamingMethods(node, ancestors)) {
            try self.generateStreamClient(node, interface_info, ancestors, writer);
        }

        // Generate Pipeline types for methods with interface-typed results (own methods)
        for (interface_info.methods) |method| {
            try self.generatePipelineType(method, null, writer);
        }
        // Inherited pipeline types
        for (ancestors) |ancestor| {
            for (ancestor.methods) |method| {
                try self.generatePipelineType(method, ancestor.name, writer);
            }
        }

        // --- PipelinedClient ---
        try writer.writeAll("    pub const PipelinedClient = struct {\n");
        try writer.writeAll("        peer: *rpc.peer.Peer,\n");
        try writer.writeAll("        question_id: u32,\n");
        try writer.writeAll("        pointer_index: u16,\n\n");

        // Own pipelined call methods
        for (interface_info.methods) |method| {
            try self.generatePipelinedClientCallMethod(method, "interface_id", null, writer);
        }
        // Inherited pipelined call methods
        for (ancestors) |ancestor| {
            for (ancestor.methods) |method| {
                try self.generatePipelinedClientCallMethod(method, null, ancestor.name, writer);
            }
        }

        try writer.writeAll("    };\n\n");

        // --- Bootstrap ---
        try writer.writeAll("    pub const BootstrapResponse = union(enum) {\n");
        try writer.writeAll("        client: Client,\n");
        try writer.writeAll("        exception: rpc.protocol.Exception,\n");
        try writer.writeAll("        canceled,\n");
        try writer.writeAll("        results_sent_elsewhere,\n");
        try writer.writeAll("        take_from_other_question: u32,\n");
        try writer.writeAll("        accept_from_third_party,\n");
        try writer.writeAll("    };\n");
        try writer.writeAll("    pub const BootstrapCallback = *const fn (ctx: *anyopaque, peer: *rpc.peer.Peer, response: BootstrapResponse) anyerror!void;\n\n");

        try writer.writeAll("    const BootstrapContext = struct {\n");
        try writer.writeAll("        user_ctx: *anyopaque,\n");
        try writer.writeAll("        callback: BootstrapCallback,\n");
        try writer.writeAll("    };\n\n");

        try writer.writeAll("    fn bootstrapReturn(ctx_ptr: *anyopaque, peer: *rpc.peer.Peer, ret: rpc.protocol.Return, caps: *const rpc.cap_table.InboundCapTable) anyerror!void {\n");
        try writer.writeAll("        const ctx: *BootstrapContext = @ptrCast(@alignCast(ctx_ptr));\n");
        try writer.writeAll("        defer peer.allocator.destroy(ctx);\n");
        try writer.writeAll("        var response: BootstrapResponse = undefined;\n");
        try writer.writeAll("        switch (ret.tag) {\n");
        try writer.writeAll("            .results => {\n");
        try writer.writeAll("                const payload = ret.results orelse return error.MissingReturnPayload;\n");
        try writer.writeAll("                const cap = try payload.content.getCapability();\n");
        try writer.writeAll("                var mutable_caps = caps.*;\n");
        try writer.writeAll("                try mutable_caps.retainCapability(cap);\n");
        try writer.writeAll("                const resolved = try caps.resolveCapability(cap);\n");
        try writer.writeAll("                switch (resolved) {\n");
        try writer.writeAll("                    .imported => |imported| response = .{ .client = Client.init(peer, imported.id) },\n");
        try writer.writeAll("                    else => return error.UnexpectedBootstrapCapability,\n");
        try writer.writeAll("                }\n");
        try writer.writeAll("            },\n");
        try writer.writeAll("            .exception => {\n");
        try writer.writeAll("                const ex = ret.exception orelse return error.MissingException;\n");
        try writer.writeAll("                response = .{ .exception = ex };\n");
        try writer.writeAll("            },\n");
        try writer.writeAll("            .canceled => response = .canceled,\n");
        try writer.writeAll("            .resultsSentElsewhere => response = .results_sent_elsewhere,\n");
        try writer.writeAll("            .takeFromOtherQuestion => {\n");
        try writer.writeAll("                const qid = ret.take_from_other_question orelse return error.MissingQuestionId;\n");
        try writer.writeAll("                response = .{ .take_from_other_question = qid };\n");
        try writer.writeAll("            },\n");
        try writer.writeAll("            .awaitFromThirdParty => response = .accept_from_third_party,\n");
        try writer.writeAll("        }\n");
        try writer.writeAll("        try ctx.callback(ctx.user_ctx, peer, response);\n");
        try writer.writeAll("    }\n\n");

        try writer.writeAll("    pub fn bootstrap(peer: *rpc.peer.Peer, user_ctx: *anyopaque, callback: BootstrapCallback) !u32 {\n");
        try writer.writeAll("        const ctx = try peer.allocator.create(BootstrapContext);\n");
        try writer.writeAll("        ctx.* = .{ .user_ctx = user_ctx, .callback = callback };\n");
        try writer.writeAll("        return peer.sendBootstrap(ctx, bootstrapReturn);\n");
        try writer.writeAll("    }\n\n");

        // --- Server + VTable ---
        try writer.writeAll("    pub const Server = struct {\n");
        try writer.writeAll("        ctx: *anyopaque,\n");
        try writer.writeAll("        vtable: VTable,\n");
        try writer.writeAll("    };\n\n");

        try writer.writeAll("    pub const VTable = struct {\n");
        // Own method fields
        for (interface_info.methods) |method| {
            try self.generateVTableField(method, null, writer);
        }
        // Inherited method fields
        for (ancestors) |ancestor| {
            for (ancestor.methods) |method| {
                try self.generateVTableField(method, ancestor.name, writer);
            }
        }
        try writer.writeAll("    };\n\n");

        try writer.writeAll("    pub fn exportServer(peer: *rpc.peer.Peer, server: *Server) !u32 {\n");
        try writer.writeAll("        return peer.addExport(.{ .ctx = server, .on_call = onCall });\n");
        try writer.writeAll("    }\n\n");

        try writer.writeAll("    pub fn setBootstrap(peer: *rpc.peer.Peer, server: *Server) !u32 {\n");
        try writer.writeAll("        return peer.setBootstrap(.{ .ctx = server, .on_call = onCall });\n");
        try writer.writeAll("    }\n\n");

        // --- onCall dispatch ---
        try writer.writeAll("    fn onCall(ctx: *anyopaque, peer: *rpc.peer.Peer, call: rpc.protocol.Call, caps: *const rpc.cap_table.InboundCapTable) anyerror!void {\n");
        try writer.writeAll("        const server: *Server = @ptrCast(@alignCast(ctx));\n");

        var dispatch_method_count: usize = interface_info.methods.len;
        for (ancestors) |ancestor| {
            dispatch_method_count += ancestor.methods.len;
        }
        if (dispatch_method_count == 0) {
            try writer.writeAll("        _ = server;\n");
            try writer.writeAll("        _ = caps;\n");
        }

        if (has_ancestors) {
            // Dispatch by interface_id first, then method_id
            try writer.writeAll("        if (call.interface_id == interface_id) {\n");
            try writer.writeAll("            switch (call.method_id) {\n");
            for (interface_info.methods) |method| {
                const zig_name = try self.toZigIdentifier(method.name);
                defer self.allocator.free(zig_name);
                try writer.print("                {s}.ordinal => try {s}.handleCall(server, peer, call, caps),\n", .{ zig_name, zig_name });
            }
            try writer.writeAll("                else => try peer.sendReturnException(call.question_id, \"unknown method\"),\n");
            try writer.writeAll("            }\n");

            for (ancestors) |ancestor| {
                try writer.print("        }} else if (call.interface_id == {s}.interface_id) {{\n", .{ancestor.name});
                try writer.writeAll("            switch (call.method_id) {\n");
                for (ancestor.methods) |method| {
                    const zig_name = try self.toZigIdentifier(method.name);
                    defer self.allocator.free(zig_name);
                    const method_field = try self.lowerFirst(zig_name);
                    defer self.allocator.free(method_field);
                    const escaped_field = try types.escapeZigKeyword(self.allocator, method_field);
                    defer self.allocator.free(escaped_field);
                    if (method.isStreaming()) {
                        try writer.print("                {s}.{s}.ordinal => try {s}.{s}.handleCallDirect(server.vtable.{s}, server.ctx, peer, call, caps),\n", .{
                            ancestor.name, zig_name, ancestor.name, zig_name, escaped_field,
                        });
                    } else {
                        try writer.print("                {s}.{s}.ordinal => try {s}.{s}.handleCallDirect(server.vtable.{s}, server.vtable.{s}_deferred, server.ctx, peer, call, caps),\n", .{
                            ancestor.name, zig_name, ancestor.name, zig_name, escaped_field, escaped_field,
                        });
                    }
                }
                try writer.writeAll("                else => try peer.sendReturnException(call.question_id, \"unknown method\"),\n");
                try writer.writeAll("            }\n");
            }
            try writer.writeAll("        } else {\n");
            try writer.writeAll("            try peer.sendReturnException(call.question_id, \"unknown interface\");\n");
            try writer.writeAll("        }\n");
        } else {
            // No ancestors â€” simple dispatch by method_id only (backward compatible)
            try writer.writeAll("        switch (call.method_id) {\n");
            for (interface_info.methods) |method| {
                const zig_name = try self.toZigIdentifier(method.name);
                defer self.allocator.free(zig_name);
                try writer.print("            {s}.ordinal => try {s}.handleCall(server, peer, call, caps),\n", .{ zig_name, zig_name });
            }
            try writer.writeAll("            else => try peer.sendReturnException(call.question_id, \"unknown method\"),\n");
            try writer.writeAll("        }\n");
        }

        try writer.writeAll("    }\n");

        try writer.writeAll("};\n\n");
    }

    /// Generate a single method struct inside an interface.
    fn generateMethodStruct(self: *Generator, method: schema.Method, writer: anytype) !void {
        const zig_name = try self.toZigIdentifier(method.name);
        defer self.allocator.free(zig_name);
        const escaped_zig_name = try types.escapeZigKeyword(self.allocator, zig_name);
        defer self.allocator.free(escaped_zig_name);
        const method_field = try self.lowerFirst(zig_name);
        defer self.allocator.free(method_field);
        const escaped_method_field = try types.escapeZigKeyword(self.allocator, method_field);
        defer self.allocator.free(escaped_method_field);
        const param_name = try self.resolveNodeName(method.param_struct_type);
        defer self.allocator.free(param_name);
        const result_name = try self.resolveNodeName(method.result_struct_type);
        defer self.allocator.free(result_name);

        const param_layout = self.structLayout(method.param_struct_type) orelse return error.InvalidStructNode;
        const result_layout = self.structLayout(method.result_struct_type) orelse return error.InvalidStructNode;
        const is_streaming = method.isStreaming();

        try writer.print("    pub const {s} = struct {{\n", .{escaped_zig_name});
        try writer.print("        pub const ordinal: u16 = {};\n", .{method.code_order});
        try writer.print("        pub const is_streaming: bool = {};\n", .{is_streaming});
        try writer.print("        pub const Params = {s};\n", .{param_name});
        try writer.print("        pub const Results = {s};\n", .{result_name});
        try writer.writeAll("        pub const BuildFn = *const fn (ctx: *anyopaque, params: *Params.Builder) anyerror!void;\n");

        if (is_streaming) {
            try writer.writeAll("        pub const StreamHandler = *const fn (ctx: *anyopaque, peer: *rpc.peer.Peer, params: Params.Reader, caps: *const rpc.cap_table.InboundCapTable) anyerror!void;\n");
        } else {
            try writer.writeAll("        pub const Handler = *const fn (ctx: *anyopaque, peer: *rpc.peer.Peer, params: Params.Reader, results: *Results.Builder, caps: *const rpc.cap_table.InboundCapTable) anyerror!void;\n");
            try writer.writeAll("        pub const DeferredHandler = *const fn (ctx: *anyopaque, peer: *rpc.peer.Peer, params: Params.Reader, caps: *const rpc.cap_table.InboundCapTable, sender: ReturnSender) anyerror!void;\n");
        }

        try writer.writeAll("        pub const Response = union(enum) {\n");
        try writer.writeAll("            results: Results.Reader,\n");
        try writer.writeAll("            exception: rpc.protocol.Exception,\n");
        try writer.writeAll("            canceled,\n");
        try writer.writeAll("            results_sent_elsewhere,\n");
        try writer.writeAll("            take_from_other_question: u32,\n");
        try writer.writeAll("            accept_from_third_party,\n");
        try writer.writeAll("        };\n");
        try writer.writeAll("        pub const Callback = *const fn (ctx: *anyopaque, peer: *rpc.peer.Peer, response: Response, caps: *const rpc.cap_table.InboundCapTable) anyerror!void;\n\n");

        try writer.writeAll("        const CallContext = struct {\n");
        try writer.writeAll("            user_ctx: *anyopaque,\n");
        try writer.writeAll("            build: ?BuildFn,\n");
        try writer.writeAll("            callback: Callback,\n");
        try writer.writeAll("        };\n\n");

        if (!is_streaming) {
            try writer.writeAll("        const DirectReturnContext = struct {\n");
            try writer.writeAll("            handler: Handler,\n");
            try writer.writeAll("            ctx: *anyopaque,\n");
            try writer.writeAll("            peer: *rpc.peer.Peer,\n");
            try writer.writeAll("            params: Params.Reader,\n");
            try writer.writeAll("            caps: *const rpc.cap_table.InboundCapTable,\n");
            try writer.writeAll("        };\n\n");

            try writer.writeAll("        pub const ReturnSender = struct {\n");
            try writer.writeAll("            peer: *rpc.peer.Peer,\n");
            try writer.writeAll("            question_id: u32,\n\n");
            try writer.writeAll("            pub fn sendResults(self: ReturnSender, ctx: *anyopaque, build: *const fn (ctx: *anyopaque, ret: *rpc.protocol.ReturnBuilder) anyerror!void) !void {\n");
            try writer.writeAll("                try self.peer.sendReturnResults(self.question_id, ctx, build);\n");
            try writer.writeAll("            }\n\n");
            try writer.writeAll("            pub fn sendException(self: ReturnSender, reason: []const u8) !void {\n");
            try writer.writeAll("                try self.peer.sendReturnException(self.question_id, reason);\n");
            try writer.writeAll("            }\n");
            try writer.writeAll("        };\n\n");
        }

        try writer.writeAll("        fn callBuild(ctx_ptr: *anyopaque, call: *rpc.protocol.CallBuilder) anyerror!void {\n");
        try writer.writeAll("            const ctx: *CallContext = @ptrCast(@alignCast(ctx_ptr));\n");
        try writer.writeAll("            var payload = try call.payloadTyped();\n");
        try writer.writeAll("            var params_any = try payload.initContent();\n");
        try writer.print("            const params_builder = try params_any.initStruct({}, {});\n", .{
            param_layout.data_words,
            param_layout.pointer_words,
        });
        try writer.writeAll("            var params = Params.Builder.wrap(params_builder);\n");
        try writer.writeAll("            if (ctx.build) |build_fn| {\n");
        try writer.writeAll("                try build_fn(ctx.user_ctx, &params);\n");
        try writer.writeAll("            }\n");
        try writer.writeAll("            _ = try call.initCapTableTyped(0);\n");
        try writer.writeAll("        }\n\n");

        try writer.writeAll("        fn callReturn(ctx_ptr: *anyopaque, peer: *rpc.peer.Peer, ret: rpc.protocol.Return, caps: *const rpc.cap_table.InboundCapTable) anyerror!void {\n");
        try writer.writeAll("            const ctx: *CallContext = @ptrCast(@alignCast(ctx_ptr));\n");
        try writer.writeAll("            defer peer.allocator.destroy(ctx);\n");
        try writer.writeAll("            var response: Response = undefined;\n");
        try writer.writeAll("            switch (ret.tag) {\n");
        try writer.writeAll("                .results => {\n");
        try writer.writeAll("                    const payload = ret.results orelse return error.MissingReturnPayload;\n");
        try writer.writeAll("                    const struct_reader = try payload.content.getStruct();\n");
        try writer.writeAll("                    const results = Results.Reader.wrap(struct_reader);\n");
        try writer.writeAll("                    response = .{ .results = results };\n");
        try writer.writeAll("                },\n");
        try writer.writeAll("                .exception => {\n");
        try writer.writeAll("                    const ex = ret.exception orelse return error.MissingException;\n");
        try writer.writeAll("                    response = .{ .exception = ex };\n");
        try writer.writeAll("                },\n");
        try writer.writeAll("                .canceled => response = .canceled,\n");
        try writer.writeAll("                .resultsSentElsewhere => response = .results_sent_elsewhere,\n");
        try writer.writeAll("                .takeFromOtherQuestion => {\n");
        try writer.writeAll("                    const qid = ret.take_from_other_question orelse return error.MissingQuestionId;\n");
        try writer.writeAll("                    response = .{ .take_from_other_question = qid };\n");
        try writer.writeAll("                },\n");
        try writer.writeAll("                .awaitFromThirdParty => response = .accept_from_third_party,\n");
        try writer.writeAll("            }\n");
        try writer.writeAll("            try ctx.callback(ctx.user_ctx, peer, response, caps);\n");
        try writer.writeAll("        }\n\n");

        if (is_streaming) {
            // handleCallDirect: takes StreamHandler + ctx directly
            try writer.writeAll("        pub fn handleCallDirect(handler: StreamHandler, ctx: *anyopaque, peer: *rpc.peer.Peer, call: rpc.protocol.Call, caps: *const rpc.cap_table.InboundCapTable) anyerror!void {\n");
            try writer.writeAll("            const params_struct = try call.params.content.getStruct();\n");
            try writer.writeAll("            const params = Params.Reader.wrap(params_struct);\n");
            try writer.writeAll("            try handler(ctx, peer, params, caps);\n");
            try writer.writeAll("            try peer.sendReturnEmptyStruct(call.question_id);\n");
            try writer.writeAll("        }\n\n");

            // handleCall delegates to handleCallDirect
            try writer.writeAll("        fn handleCall(server: *Server, peer: *rpc.peer.Peer, call: rpc.protocol.Call, caps: *const rpc.cap_table.InboundCapTable) anyerror!void {\n");
            try writer.print("            try handleCallDirect(server.vtable.{s}, server.ctx, peer, call, caps);\n", .{escaped_method_field});
            try writer.writeAll("        }\n\n");

            // StreamCallContext + streamCallBuild + streamCallReturn for fire-and-forget streaming
            try writer.writeAll("        pub const StreamCallContext = struct {\n");
            try writer.writeAll("            stream: *rpc.stream_state.StreamState,\n");
            try writer.writeAll("            build_ctx: *anyopaque,\n");
            try writer.writeAll("            build: ?BuildFn,\n");
            try writer.writeAll("        };\n\n");

            try writer.writeAll("        fn streamCallBuild(ctx_ptr: *anyopaque, call: *rpc.protocol.CallBuilder) anyerror!void {\n");
            try writer.writeAll("            const ctx: *StreamCallContext = @ptrCast(@alignCast(ctx_ptr));\n");
            try writer.writeAll("            var payload = try call.payloadTyped();\n");
            try writer.writeAll("            var params_any = try payload.initContent();\n");
            try writer.print("            const params_builder = try params_any.initStruct({}, {});\n", .{
                param_layout.data_words,
                param_layout.pointer_words,
            });
            try writer.writeAll("            var params = Params.Builder.wrap(params_builder);\n");
            try writer.writeAll("            if (ctx.build) |build_fn| try build_fn(ctx.build_ctx, &params);\n");
            try writer.writeAll("            _ = try call.initCapTableTyped(0);\n");
            try writer.writeAll("        }\n\n");

            try writer.writeAll("        fn streamCallReturn(ctx_ptr: *anyopaque, peer: *rpc.peer.Peer, ret: rpc.protocol.Return, caps: *const rpc.cap_table.InboundCapTable) anyerror!void {\n");
            try writer.writeAll("            const ctx: *StreamCallContext = @ptrCast(@alignCast(ctx_ptr));\n");
            try writer.writeAll("            defer peer.allocator.destroy(ctx);\n");
            try writer.writeAll("            _ = caps;\n");
            try writer.writeAll("            ctx.stream.handleReturn(ret.tag == .exception);\n");
            try writer.writeAll("        }\n");
        } else {
            // handleCallDirect: takes Handler + ?DeferredHandler + ctx directly
            try writer.writeAll("        pub fn handleCallDirect(handler: Handler, deferred_handler: ?DeferredHandler, ctx: *anyopaque, peer: *rpc.peer.Peer, call: rpc.protocol.Call, caps: *const rpc.cap_table.InboundCapTable) anyerror!void {\n");
            try writer.writeAll("            const params_struct = try call.params.content.getStruct();\n");
            try writer.writeAll("            const params = Params.Reader.wrap(params_struct);\n");
            try writer.writeAll("            if (deferred_handler) |deferred_fn| {\n");
            try writer.writeAll("                const sender = ReturnSender{ .peer = peer, .question_id = call.question_id };\n");
            try writer.writeAll("                try deferred_fn(ctx, peer, params, caps, sender);\n");
            try writer.writeAll("            } else {\n");
            try writer.writeAll("                var dctx = DirectReturnContext{\n");
            try writer.writeAll("                    .handler = handler,\n");
            try writer.writeAll("                    .ctx = ctx,\n");
            try writer.writeAll("                    .peer = peer,\n");
            try writer.writeAll("                    .params = params,\n");
            try writer.writeAll("                    .caps = caps,\n");
            try writer.writeAll("                };\n");
            try writer.writeAll("                try peer.sendReturnResults(call.question_id, &dctx, buildReturnDirect);\n");
            try writer.writeAll("            }\n");
            try writer.writeAll("        }\n\n");

            // handleCall delegates to handleCallDirect
            try writer.writeAll("        fn handleCall(server: *Server, peer: *rpc.peer.Peer, call: rpc.protocol.Call, caps: *const rpc.cap_table.InboundCapTable) anyerror!void {\n");
            try writer.print("            try handleCallDirect(server.vtable.{s}, server.vtable.{s}_deferred, server.ctx, peer, call, caps);\n", .{ escaped_method_field, escaped_method_field });
            try writer.writeAll("        }\n\n");

            try writer.writeAll("        fn buildReturnDirect(ctx_ptr: *anyopaque, ret: *rpc.protocol.ReturnBuilder) anyerror!void {\n");
            try writer.writeAll("            const dctx: *DirectReturnContext = @ptrCast(@alignCast(ctx_ptr));\n");
            try writer.writeAll("            var payload = try ret.payloadTyped();\n");
            try writer.writeAll("            var results_any = try payload.initContent();\n");
            try writer.print("            const results_builder = try results_any.initStruct({}, {});\n", .{
                result_layout.data_words,
                result_layout.pointer_words,
            });
            try writer.writeAll("            var results = Results.Builder.wrap(results_builder);\n");
            try writer.writeAll("            try dctx.handler(dctx.ctx, dctx.peer, dctx.params, &results, dctx.caps);\n");
            try writer.writeAll("            _ = try ret.initCapTableTyped(0);\n");
            try writer.writeAll("        }\n");
        }

        try writer.writeAll("    };\n\n");
    }

    /// Generate a VTable field for a method. If `ancestor_name` is set, uses the ancestor's types.
    fn generateVTableField(self: *Generator, method: schema.Method, ancestor_name: ?[]const u8, writer: anytype) !void {
        const zig_name = try self.toZigIdentifier(method.name);
        defer self.allocator.free(zig_name);
        const method_field = try self.lowerFirst(zig_name);
        defer self.allocator.free(method_field);
        const escaped_field = try types.escapeZigKeyword(self.allocator, method_field);
        defer self.allocator.free(escaped_field);
        if (ancestor_name) |aname| {
            if (method.isStreaming()) {
                try writer.print("        {s}: {s}.{s}.StreamHandler,\n", .{ escaped_field, aname, zig_name });
            } else {
                try writer.print("        {s}: {s}.{s}.Handler,\n", .{ escaped_field, aname, zig_name });
                try writer.print("        {s}_deferred: ?{s}.{s}.DeferredHandler = null,\n", .{ escaped_field, aname, zig_name });
            }
        } else {
            if (method.isStreaming()) {
                try writer.print("        {s}: {s}.StreamHandler,\n", .{ escaped_field, zig_name });
            } else {
                try writer.print("        {s}: {s}.Handler,\n", .{ escaped_field, zig_name });
                try writer.print("        {s}_deferred: ?{s}.DeferredHandler = null,\n", .{ escaped_field, zig_name });
            }
        }
    }

    /// Generate a Client call method. Uses `interface_id_expr` for own methods or ancestor_name for inherited.
    fn generateClientCallMethod(self: *Generator, method: schema.Method, interface_id_expr: ?[]const u8, ancestor_name: ?[]const u8, writer: anytype) !void {
        const zig_name = try self.toZigIdentifier(method.name);
        defer self.allocator.free(zig_name);
        const call_name = try std.fmt.allocPrint(self.allocator, "call{s}", .{zig_name});
        defer self.allocator.free(call_name);

        const method_prefix = ancestor_name orelse "";
        const dot = if (ancestor_name != null) "." else "";
        const iface_id = if (interface_id_expr) |expr| expr else blk: {
            const temp = try std.fmt.allocPrint(self.allocator, "{s}.interface_id", .{ancestor_name.?});
            break :blk temp;
        };
        const iface_id_owned = interface_id_expr == null;
        defer if (iface_id_owned) self.allocator.free(iface_id);

        try writer.print("        pub fn {s}(self: *Client, user_ctx: *anyopaque, build: ?{s}{s}{s}.BuildFn, on_return: {s}{s}{s}.Callback) !u32 {{\n", .{
            call_name, method_prefix, dot, zig_name, method_prefix, dot, zig_name,
        });
        try writer.print("            const ctx = try self.peer.allocator.create({s}{s}{s}.CallContext);\n", .{ method_prefix, dot, zig_name });
        try writer.writeAll("            ctx.* = .{ .user_ctx = user_ctx, .build = build, .callback = on_return };\n");
        try writer.print("            return self.peer.sendCall(self.cap_id, {s}, {s}{s}{s}.ordinal, ctx, {s}{s}{s}.callBuild, {s}{s}{s}.callReturn);\n", .{
            iface_id, method_prefix, dot, zig_name, method_prefix, dot, zig_name, method_prefix, dot, zig_name,
        });
        try writer.writeAll("        }\n\n");
    }

    /// Generate a StreamClient type for an interface with streaming methods.
    fn generateStreamClient(
        self: *Generator,
        node: *const schema.Node,
        interface_info: schema.InterfaceNode,
        ancestors: []const AncestorInfo,
        writer: anytype,
    ) !void {
        _ = node;
        try writer.writeAll("    pub const StreamClient = struct {\n");
        try writer.writeAll("        client: Client,\n");
        try writer.writeAll("        stream: rpc.stream_state.StreamState = .{},\n\n");

        try writer.writeAll("        pub fn init(client: Client) StreamClient {\n");
        try writer.writeAll("            return .{ .client = client };\n");
        try writer.writeAll("        }\n\n");

        // Own methods
        for (interface_info.methods) |method| {
            try self.generateStreamClientCallMethod(method, "interface_id", null, writer);
        }
        // Inherited methods
        for (ancestors) |ancestor| {
            for (ancestor.methods) |method| {
                try self.generateStreamClientCallMethod(method, null, ancestor.name, writer);
            }
        }

        try writer.writeAll("        pub fn waitStreaming(self: *StreamClient, ctx: *anyopaque, callback: rpc.stream_state.StreamState.DrainCallback) void {\n");
        try writer.writeAll("            self.stream.waitStreaming(ctx, callback);\n");
        try writer.writeAll("        }\n");

        try writer.writeAll("    };\n\n");
    }

    /// Generate a single StreamClient call method. Streaming methods become
    /// fire-and-forget; non-streaming methods pass through to the inner Client.
    fn generateStreamClientCallMethod(
        self: *Generator,
        method: schema.Method,
        interface_id_expr: ?[]const u8,
        ancestor_name: ?[]const u8,
        writer: anytype,
    ) !void {
        const zig_name = try self.toZigIdentifier(method.name);
        defer self.allocator.free(zig_name);
        const call_name = try std.fmt.allocPrint(self.allocator, "call{s}", .{zig_name});
        defer self.allocator.free(call_name);

        const method_prefix = ancestor_name orelse "";
        const dot = if (ancestor_name != null) "." else "";
        const iface_id = if (interface_id_expr) |expr| expr else blk: {
            const temp = try std.fmt.allocPrint(self.allocator, "{s}.interface_id", .{ancestor_name.?});
            break :blk temp;
        };
        const iface_id_owned = interface_id_expr == null;
        defer if (iface_id_owned) self.allocator.free(iface_id);

        if (method.isStreaming()) {
            // Fire-and-forget streaming call
            try writer.print("        pub fn {s}(self: *StreamClient, build_ctx: *anyopaque, build: ?{s}{s}{s}.BuildFn) !void {{\n", .{
                call_name, method_prefix, dot, zig_name,
            });
            try writer.writeAll("            if (self.stream.hasFailed()) return self.stream.stream_error.?;\n");
            try writer.print("            const ctx = try self.client.peer.allocator.create({s}{s}{s}.StreamCallContext);\n", .{ method_prefix, dot, zig_name });
            try writer.writeAll("            ctx.* = .{ .stream = &self.stream, .build_ctx = build_ctx, .build = build };\n");
            try writer.writeAll("            self.stream.noteCallSent();\n");
            try writer.print("            _ = self.client.peer.sendCall(self.client.cap_id, {s}, {s}{s}{s}.ordinal, ctx, {s}{s}{s}.streamCallBuild, {s}{s}{s}.streamCallReturn) catch |err| {{\n", .{
                iface_id, method_prefix, dot, zig_name, method_prefix, dot, zig_name, method_prefix, dot, zig_name,
            });
            try writer.writeAll("                self.stream.in_flight -= 1;\n");
            try writer.writeAll("                self.client.peer.allocator.destroy(ctx);\n");
            try writer.writeAll("                return err;\n");
            try writer.writeAll("            };\n");
            try writer.writeAll("        }\n\n");
        } else {
            // Pass-through to inner Client
            try writer.print("        pub fn {s}(self: *StreamClient, user_ctx: *anyopaque, build: ?{s}{s}{s}.BuildFn, on_return: {s}{s}{s}.Callback) !u32 {{\n", .{
                call_name, method_prefix, dot, zig_name, method_prefix, dot, zig_name,
            });
            try writer.print("            return self.client.{s}(user_ctx, build, on_return);\n", .{call_name});
            try writer.writeAll("        }\n\n");
        }
    }

    /// Generate a callXxxPipelined method on Client if the method has interface-typed results.
    fn generateClientPipelinedMethod(self: *Generator, method: schema.Method, ancestor_name: ?[]const u8, writer: anytype) !void {
        const iface_fields = try self.getInterfaceFields(method.result_struct_type);
        defer self.freeInterfaceFields(iface_fields);
        if (iface_fields.len == 0) return;

        const zig_name = try self.toZigIdentifier(method.name);
        defer self.allocator.free(zig_name);

        const method_prefix = ancestor_name orelse "";
        const dot = if (ancestor_name != null) "." else "";

        try writer.print("        pub fn call{s}Pipelined(self: *Client, user_ctx: *anyopaque, build: ?{s}{s}{s}.BuildFn, on_return: {s}{s}{s}.Callback) !{s}{s}{s}.Pipeline {{\n", .{
            zig_name, method_prefix, dot, zig_name, method_prefix, dot, zig_name, method_prefix, dot, zig_name,
        });
        try writer.print("            const qid = try self.call{s}(user_ctx, build, on_return);\n", .{zig_name});
        try writer.writeAll("            return .{ .peer = self.peer, .question_id = qid };\n");
        try writer.writeAll("        }\n\n");
    }

    /// Generate a Pipeline type for a method with interface-typed results.
    fn generatePipelineType(self: *Generator, method: schema.Method, ancestor_name: ?[]const u8, writer: anytype) !void {
        const iface_fields = try self.getInterfaceFields(method.result_struct_type);
        defer self.freeInterfaceFields(iface_fields);
        if (iface_fields.len == 0) return;

        const zig_name = try self.toZigIdentifier(method.name);
        defer self.allocator.free(zig_name);

        // For inherited methods, the Pipeline type is defined on the parent interface,
        // so we don't re-generate it here. The client method references the parent's Pipeline type.
        if (ancestor_name != null) return;

        try writer.print("    pub const {s}Pipeline = struct {{\n", .{zig_name});
        try writer.writeAll("        peer: *rpc.peer.Peer,\n");
        try writer.writeAll("        question_id: u32,\n\n");

        for (iface_fields) |ifield| {
            try writer.print("        pub fn get{s}(self: @This()) {s}.PipelinedClient {{\n", .{ ifield.name, ifield.type_name });
            try writer.print("            return .{{ .peer = self.peer, .question_id = self.question_id, .pointer_index = {} }};\n", .{ifield.pointer_offset});
            try writer.writeAll("        }\n\n");
        }

        try writer.writeAll("    };\n\n");
    }

    /// Generate a PipelinedClient call method.
    fn generatePipelinedClientCallMethod(self: *Generator, method: schema.Method, interface_id_expr: ?[]const u8, ancestor_name: ?[]const u8, writer: anytype) !void {
        const zig_name = try self.toZigIdentifier(method.name);
        defer self.allocator.free(zig_name);
        const call_name = try std.fmt.allocPrint(self.allocator, "call{s}", .{zig_name});
        defer self.allocator.free(call_name);

        const method_prefix = ancestor_name orelse "";
        const dot = if (ancestor_name != null) "." else "";
        const iface_id = if (interface_id_expr) |expr| expr else blk: {
            const temp = try std.fmt.allocPrint(self.allocator, "{s}.interface_id", .{ancestor_name.?});
            break :blk temp;
        };
        const iface_id_owned = interface_id_expr == null;
        defer if (iface_id_owned) self.allocator.free(iface_id);

        try writer.print("        pub fn {s}(self: *PipelinedClient, user_ctx: *anyopaque, build: ?{s}{s}{s}.BuildFn, on_return: {s}{s}{s}.Callback) !u32 {{\n", .{
            call_name, method_prefix, dot, zig_name, method_prefix, dot, zig_name,
        });
        try writer.print("            const ctx = try self.peer.allocator.create({s}{s}{s}.CallContext);\n", .{ method_prefix, dot, zig_name });
        try writer.writeAll("            ctx.* = .{ .user_ctx = user_ctx, .build = build, .callback = on_return };\n");
        try writer.print("            return self.peer.sendCallPromisedWithOps(self.question_id, &[_]rpc.protocol.PromisedAnswerOp{{.{{ .tag = .getPointerField, .pointer_index = self.pointer_index }}}}, {s}, {s}{s}{s}.ordinal, ctx, {s}{s}{s}.callBuild, {s}{s}{s}.callReturn);\n", .{
            iface_id, method_prefix, dot, zig_name, method_prefix, dot, zig_name, method_prefix, dot, zig_name,
        });
        try writer.writeAll("        }\n\n");
    }

    /// Generate a constant definition
    fn generateConst(self: *Generator, node: *const schema.Node, writer: anytype) !void {
        const const_info = node.const_node orelse return error.InvalidConstNode;
        const name = try self.allocValueDeclName(node);
        defer self.allocator.free(name);

        switch (const_info.value) {
            .text => |text| {
                try writer.print("pub const {s}: []const u8 = \"{f}\";\n\n", .{ name, std.zig.fmtString(text) });
            },
            .data => |data| {
                try writer.print("pub const {s}: []const u8 = ", .{name});
                try self.writeByteArrayLiteral(writer, data);
                try writer.writeAll(";\n\n");
            },
            .list, .@"struct", .any_pointer => {
                try self.generatePointerConst(name, const_info.type, const_info.value, writer);
            },
            else => {
                const type_name = try self.typeNameForConst(const_info.type);
                defer self.allocator.free(type_name);

                if (try self.constValueLiteral(const_info.type, const_info.value)) |literal| {
                    try writer.print("pub const {s}: {s} = {s};\n\n", .{ name, type_name, literal });
                    self.allocator.free(literal);
                } else {
                    return error.UnsupportedConstType;
                }
            },
        }
    }

    /// Generate an annotation definition
    fn generateAnnotation(self: *Generator, node: *const schema.Node, writer: anytype) !void {
        const annotation_info = node.annotation_node orelse return error.InvalidAnnotationNode;
        const name = try self.allocValueDeclName(node);
        defer self.allocator.free(name);

        const type_name = try self.typeNameForConst(annotation_info.type);
        defer self.allocator.free(type_name);

        try writer.print("pub const {s} = struct {{\n", .{name});
        try writer.print("    pub const Type = {s};\n", .{type_name});
        try writer.writeAll("    pub const targets = .{\n");
        try writer.print("        .file = {},\n", .{annotation_info.targets_file});
        try writer.print("        .@\"const\" = {},\n", .{annotation_info.targets_const});
        try writer.print("        .@\"enum\" = {},\n", .{annotation_info.targets_enum});
        try writer.print("        .enumerant = {},\n", .{annotation_info.targets_enumerant});
        try writer.print("        .@\"struct\" = {},\n", .{annotation_info.targets_struct});
        try writer.print("        .field = {},\n", .{annotation_info.targets_field});
        try writer.print("        .@\"union\" = {},\n", .{annotation_info.targets_union});
        try writer.print("        .group = {},\n", .{annotation_info.targets_group});
        try writer.print("        .interface = {},\n", .{annotation_info.targets_interface});
        try writer.print("        .method = {},\n", .{annotation_info.targets_method});
        try writer.print("        .param = {},\n", .{annotation_info.targets_param});
        try writer.print("        .annotation = {},\n", .{annotation_info.targets_annotation});
        try writer.writeAll("    };\n");
        try writer.writeAll("};\n\n");
    }

    /// Get simple name from display name
    fn getSimpleName(self: *Generator, node: *const schema.Node) []const u8 {
        _ = self;
        const prefix_len = node.display_name_prefix_length;
        if (prefix_len >= node.display_name.len) return node.display_name;
        return node.display_name[prefix_len..];
    }

    fn allocTypeDeclName(self: *Generator, node: *const schema.Node) ![]const u8 {
        return types.normalizeAndEscapeTypeIdentifier(self.allocator, self.getSimpleName(node));
    }

    fn allocValueDeclName(self: *Generator, node: *const schema.Node) ![]const u8 {
        return types.normalizeAndEscapeValueIdentifier(self.allocator, self.getSimpleName(node));
    }

    fn allocAnnotationUseBaseName(self: *Generator, node: *const schema.Node) ![]u8 {
        return switch (node.kind) {
            .@"const", .annotation => types.identToZigValueName(self.allocator, self.getSimpleName(node)),
            else => types.identToZigTypeName(self.allocator, self.getSimpleName(node)),
        };
    }

    fn resolveNodeName(self: *Generator, id: schema.Id) ![]const u8 {
        if (self.getNode(id)) |_| {
            return self.qualifiedTypeName(id);
        }
        return try self.allocator.dupe(u8, "void");
    }

    /// Describes an interface-typed pointer field in a struct.
    const InterfaceFieldInfo = struct {
        name: []const u8,
        type_name: []const u8,
        pointer_offset: u32,
    };

    /// Return the list of interface-typed pointer fields in the given struct node.
    /// Caller must free each entry's name and type_name, as well as the returned slice.
    fn getInterfaceFields(self: *Generator, struct_id: schema.Id) ![]InterfaceFieldInfo {
        const node = self.getNode(struct_id) orelse return try self.allocator.alloc(InterfaceFieldInfo, 0);
        const struct_info = node.struct_node orelse return try self.allocator.alloc(InterfaceFieldInfo, 0);

        var result = std.ArrayList(InterfaceFieldInfo){};
        errdefer {
            for (result.items) |item| {
                self.allocator.free(item.name);
                self.allocator.free(item.type_name);
            }
            result.deinit(self.allocator);
        }

        for (struct_info.fields) |field| {
            const slot = field.slot orelse continue;
            if (slot.type != .interface) continue;
            const iface_id = slot.type.interface.type_id;
            const iface_name = try self.qualifiedTypeName(iface_id);
            errdefer self.allocator.free(iface_name);
            const field_name = try types.identToZigTypeName(self.allocator, field.name);
            errdefer self.allocator.free(field_name);
            try result.append(self.allocator, .{
                .name = field_name,
                .type_name = iface_name,
                .pointer_offset = slot.offset,
            });
        }

        return result.toOwnedSlice(self.allocator);
    }

    fn freeInterfaceFields(self: *Generator, fields: []InterfaceFieldInfo) void {
        for (fields) |item| {
            self.allocator.free(item.name);
            self.allocator.free(item.type_name);
        }
        self.allocator.free(fields);
    }

    fn structLayout(self: *Generator, id: schema.Id) ?struct { data_words: u16, pointer_words: u16 } {
        const node = self.getNode(id) orelse return null;
        if (node.kind != .@"struct") return null;
        const info = node.struct_node orelse return null;
        return .{ .data_words = info.data_word_count, .pointer_words = info.pointer_count };
    }

    fn lowerFirst(self: *Generator, name: []const u8) ![]const u8 {
        if (name.len == 0) return try self.allocator.dupe(u8, name);
        var result = try self.allocator.alloc(u8, name.len);
        result[0] = std.ascii.toLower(name[0]);
        @memcpy(result[1..], name[1..]);
        return result;
    }

    /// Convert Cap'n Proto identifier to Zig identifier
    fn toZigIdentifier(self: *Generator, name: []const u8) ![]const u8 {
        return types.identToZigTypeName(self.allocator, name);
    }

    fn moduleNameFromFilename(self: *Generator, filename: []const u8) ![]const u8 {
        const stem = std.fs.path.stem(filename);
        return self.toSnakeCaseLower(stem);
    }

    /// Derive the .zig import path from a .capnp import name.
    /// E.g., "other.capnp" â†’ "other.zig", "path/to/types.capnp" â†’ "path/to/types.zig"
    fn importPathFromCapnpName(self: *Generator, capnp_name: []const u8) ![]const u8 {
        const normalized = if (std.mem.startsWith(u8, capnp_name, "/")) capnp_name[1..] else capnp_name;
        if (std.mem.endsWith(u8, normalized, ".capnp")) {
            const base = normalized[0 .. normalized.len - 6];
            return std.fmt.allocPrint(self.allocator, "{s}.zig", .{base});
        }
        return std.fmt.allocPrint(self.allocator, "{s}.zig", .{normalized});
    }

    /// Walk the scope chain from a node to find its owning file node ID.
    fn findOwningFileId(self: *const Generator, id: schema.Id) ?schema.Id {
        var current_id = id;
        var depth: u32 = 0;
        while (depth < 64) : (depth += 1) {
            const node = self.getNode(current_id) orelse return null;
            if (node.kind == .file) return node.id;
            if (node.scope_id == current_id) return null; // self-referential, stop
            current_id = node.scope_id;
        }
        return null;
    }

    /// Return the import module name for a type if it belongs to a different file,
    /// or null if it belongs to the current file.
    fn typeModulePrefix(self: *Generator, type_id: schema.Id) !?[]const u8 {
        const current = self.current_file_id orelse return null;
        const owning_file = self.findOwningFileId(type_id) orelse return null;
        if (owning_file == current) return null;
        const prefix = self.import_modules.get(owning_file) orelse return null;
        try self.used_import_file_ids.put(owning_file, {});
        return prefix;
    }

    /// Resolve a type name, qualifying with module prefix if it's from another file.
    fn qualifiedTypeName(self: *Generator, id: schema.Id) ![]const u8 {
        const node = self.getNode(id) orelse return try self.allocator.dupe(u8, "void");
        const simple_name = self.getSimpleName(node);
        const zig_name = try types.normalizeAndEscapeTypeIdentifier(self.allocator, simple_name);

        if (try self.typeModulePrefix(id)) |prefix| {
            defer self.allocator.free(zig_name);
            return std.fmt.allocPrint(self.allocator, "{s}.{s}", .{ prefix, zig_name });
        }
        return zig_name;
    }

    fn toSnakeCaseLower(self: *Generator, name: []const u8) ![]u8 {
        var out = std.ArrayList(u8){};
        errdefer out.deinit(self.allocator);

        var prev_was_sep = false;
        for (name, 0..) |c, i| {
            if (!std.ascii.isAlphanumeric(c)) {
                if (out.items.len != 0 and !prev_was_sep) {
                    try out.append(self.allocator, '_');
                    prev_was_sep = true;
                }
                continue;
            }

            if (std.ascii.isUpper(c)) {
                if (i != 0 and out.items.len != 0 and !prev_was_sep) {
                    try out.append(self.allocator, '_');
                }
                try out.append(self.allocator, std.ascii.toLower(c));
                prev_was_sep = false;
                continue;
            }

            try out.append(self.allocator, c);
            prev_was_sep = false;
        }

        if (out.items.len == 0) {
            try out.append(self.allocator, 'x');
        }

        if (out.items[out.items.len - 1] == '_') {
            _ = out.pop();
        }

        return out.toOwnedSlice(self.allocator);
    }

    fn lookupNode(ctx: ?*anyopaque, id: schema.Id) ?*const schema.Node {
        const generator: *const Generator = @ptrCast(@alignCast(ctx.?));
        return generator.getNode(id);
    }

    fn lookupTypePrefix(ctx: ?*anyopaque, id: schema.Id) std.mem.Allocator.Error!?[]const u8 {
        const generator: *Generator = @ptrCast(@alignCast(ctx.?));
        return generator.typeModulePrefix(id);
    }

    fn typeNameForConst(self: *Generator, typ: schema.Type) ![]const u8 {
        return switch (typ) {
            .void => try self.allocator.dupe(u8, "void"),
            .bool => try self.allocator.dupe(u8, "bool"),
            .int8 => try self.allocator.dupe(u8, "i8"),
            .int16 => try self.allocator.dupe(u8, "i16"),
            .int32 => try self.allocator.dupe(u8, "i32"),
            .int64 => try self.allocator.dupe(u8, "i64"),
            .uint8 => try self.allocator.dupe(u8, "u8"),
            .uint16 => try self.allocator.dupe(u8, "u16"),
            .uint32 => try self.allocator.dupe(u8, "u32"),
            .uint64 => try self.allocator.dupe(u8, "u64"),
            .float32 => try self.allocator.dupe(u8, "f32"),
            .float64 => try self.allocator.dupe(u8, "f64"),
            .text => try self.allocator.dupe(u8, "[]const u8"),
            .data => try self.allocator.dupe(u8, "[]const u8"),
            .list => |list_info| try self.listReaderTypeString(list_info.element_type.*),
            .@"enum" => |enum_info| blk: {
                if (self.getNode(enum_info.type_id)) |node| {
                    if (node.kind == .@"enum") {
                        break :blk try self.allocTypeDeclName(node);
                    }
                }
                break :blk try self.allocator.dupe(u8, "u16");
            },
            .@"struct" => |struct_info| blk: {
                if (try self.structTypeName(struct_info.type_id)) |name| {
                    defer self.allocator.free(name);
                    break :blk try std.fmt.allocPrint(self.allocator, "{s}.Reader", .{name});
                }
                break :blk try self.allocator.dupe(u8, "message.StructReader");
            },
            .interface => try self.allocator.dupe(u8, "message.Capability"),
            .any_pointer => try self.allocator.dupe(u8, "message.AnyPointerReader"),
        };
    }

    fn constValueLiteral(self: *Generator, typ: schema.Type, value: schema.Value) !?[]const u8 {
        return switch (typ) {
            .void => if (value == .void) try self.allocator.dupe(u8, "{}") else null,
            .bool => if (value == .bool)
                try self.allocator.dupe(u8, if (value.bool) "true" else "false")
            else
                null,
            .int8 => if (value == .int8) try std.fmt.allocPrint(self.allocator, "@as(i8, {d})", .{value.int8}) else null,
            .uint8 => if (value == .uint8) try std.fmt.allocPrint(self.allocator, "@as(u8, {d})", .{value.uint8}) else null,
            .int16 => if (value == .int16) try std.fmt.allocPrint(self.allocator, "@as(i16, {d})", .{value.int16}) else null,
            .uint16 => if (value == .uint16) try std.fmt.allocPrint(self.allocator, "@as(u16, {d})", .{value.uint16}) else null,
            .int32 => if (value == .int32) try std.fmt.allocPrint(self.allocator, "@as(i32, {d})", .{value.int32}) else null,
            .uint32 => if (value == .uint32) try std.fmt.allocPrint(self.allocator, "@as(u32, {d})", .{value.uint32}) else null,
            .int64 => if (value == .int64) try std.fmt.allocPrint(self.allocator, "@as(i64, {d})", .{value.int64}) else null,
            .uint64 => if (value == .uint64) try std.fmt.allocPrint(self.allocator, "@as(u64, {d})", .{value.uint64}) else null,
            .float32 => if (value == .float32) blk: {
                const bits: u32 = @bitCast(value.float32);
                break :blk try std.fmt.allocPrint(self.allocator, "@bitCast(@as(u32, {d}))", .{bits});
            } else null,
            .float64 => if (value == .float64) blk: {
                const bits: u64 = @bitCast(value.float64);
                break :blk try std.fmt.allocPrint(self.allocator, "@bitCast(@as(u64, {d}))", .{bits});
            } else null,
            .@"enum" => if (value == .@"enum") blk: {
                const enum_val = value.@"enum";
                break :blk try std.fmt.allocPrint(self.allocator, "@enumFromInt(@as(u16, {d}))", .{enum_val});
            } else null,
            else => null,
        };
    }

    fn generateAnnotationUses(self: *Generator, node: *const schema.Node, writer: anytype) !void {
        const name = try self.allocAnnotationUseBaseName(node);
        defer self.allocator.free(name);

        if (node.annotations.len > 0) {
            try writer.print("pub const {s}_annotations = ", .{name});
            try self.writeAnnotationList(writer, node.annotations);
            try writer.writeAll(";\n\n");
        }

        switch (node.kind) {
            .@"struct" => if (node.struct_node) |struct_node| {
                var any = false;
                for (struct_node.fields) |field| {
                    if (field.annotations.len > 0) {
                        any = true;
                        break;
                    }
                }
                if (any) {
                    try writer.print(
                        "pub const {s}_field_annotations = [_]struct {{ name: []const u8, annotations: []const schema.AnnotationUse }}{{\n",
                        .{name},
                    );
                    for (struct_node.fields) |field| {
                        if (field.annotations.len == 0) continue;
                        try writer.print("    .{{ .name = \"{f}\", .annotations = ", .{std.zig.fmtString(field.name)});
                        try self.writeAnnotationList(writer, field.annotations);
                        try writer.writeAll(" },\n");
                    }
                    try writer.writeAll("};\n\n");
                }
            },
            .@"enum" => if (node.enum_node) |enum_node| {
                var any = false;
                for (enum_node.enumerants) |enumerant| {
                    if (enumerant.annotations.len > 0) {
                        any = true;
                        break;
                    }
                }
                if (any) {
                    try writer.print(
                        "pub const {s}_enumerant_annotations = [_]struct {{ name: []const u8, annotations: []const schema.AnnotationUse }}{{\n",
                        .{name},
                    );
                    for (enum_node.enumerants) |enumerant| {
                        if (enumerant.annotations.len == 0) continue;
                        try writer.print("    .{{ .name = \"{f}\", .annotations = ", .{std.zig.fmtString(enumerant.name)});
                        try self.writeAnnotationList(writer, enumerant.annotations);
                        try writer.writeAll(" },\n");
                    }
                    try writer.writeAll("};\n\n");
                }
            },
            .interface => if (node.interface_node) |interface_node| {
                var any = false;
                for (interface_node.methods) |method| {
                    if (method.annotations.len > 0) {
                        any = true;
                        break;
                    }
                }
                if (any) {
                    try writer.print(
                        "pub const {s}_method_annotations = [_]struct {{ name: []const u8, annotations: []const schema.AnnotationUse }}{{\n",
                        .{name},
                    );
                    for (interface_node.methods) |method| {
                        if (method.annotations.len == 0) continue;
                        try writer.print("    .{{ .name = \"{f}\", .annotations = ", .{std.zig.fmtString(method.name)});
                        try self.writeAnnotationList(writer, method.annotations);
                        try writer.writeAll(" },\n");
                    }
                    try writer.writeAll("};\n\n");
                }
            },
            else => {},
        }
    }

    fn writeAnnotationList(self: *Generator, writer: anytype, annotations: []const schema.AnnotationUse) !void {
        try writer.writeAll("&[_]schema.AnnotationUse{");
        for (annotations) |annotation| {
            try writer.print(".{{ .id = 0x{X}, .value = ", .{annotation.id});
            try self.writeValueLiteral(writer, annotation.value);
            try writer.writeAll(" },");
        }
        try writer.writeAll("}");
    }

    fn writeValueLiteral(self: *Generator, writer: anytype, value: schema.Value) !void {
        switch (value) {
            .void => try writer.writeAll("schema.Value{ .void = {} }"),
            .bool => |v| try writer.print("schema.Value{{ .bool = {} }}", .{v}),
            .int8 => |v| try writer.print("schema.Value{{ .int8 = @as(i8, {d}) }}", .{v}),
            .int16 => |v| try writer.print("schema.Value{{ .int16 = @as(i16, {d}) }}", .{v}),
            .int32 => |v| try writer.print("schema.Value{{ .int32 = @as(i32, {d}) }}", .{v}),
            .int64 => |v| try writer.print("schema.Value{{ .int64 = @as(i64, {d}) }}", .{v}),
            .uint8 => |v| try writer.print("schema.Value{{ .uint8 = @as(u8, {d}) }}", .{v}),
            .uint16 => |v| try writer.print("schema.Value{{ .uint16 = @as(u16, {d}) }}", .{v}),
            .uint32 => |v| try writer.print("schema.Value{{ .uint32 = @as(u32, {d}) }}", .{v}),
            .uint64 => |v| try writer.print("schema.Value{{ .uint64 = @as(u64, {d}) }}", .{v}),
            .float32 => |v| blk: {
                const bits: u32 = @bitCast(v);
                break :blk try writer.print("schema.Value{{ .float32 = @bitCast(@as(u32, {d})) }}", .{bits});
            },
            .float64 => |v| blk: {
                const bits: u64 = @bitCast(v);
                break :blk try writer.print("schema.Value{{ .float64 = @bitCast(@as(u64, {d})) }}", .{bits});
            },
            .text => |text| try writer.print("schema.Value{{ .text = \"{f}\" }}", .{std.zig.fmtString(text)}),
            .data => |data| blk: {
                try writer.writeAll("schema.Value{ .data = ");
                try self.writeByteArrayLiteral(writer, data);
                break :blk try writer.writeAll(" }");
            },
            .list => |info| blk: {
                try writer.writeAll("schema.Value{ .list = .{ .message_bytes = ");
                try self.writeByteArrayLiteral(writer, info.message_bytes);
                break :blk try writer.writeAll(" } }");
            },
            .@"enum" => |v| try writer.print("schema.Value{{ .@\"enum\" = @as(u16, {d}) }}", .{v}),
            .@"struct" => |info| blk: {
                try writer.writeAll("schema.Value{ .@\"struct\" = .{ .message_bytes = ");
                try self.writeByteArrayLiteral(writer, info.message_bytes);
                break :blk try writer.writeAll(" } }");
            },
            .interface => try writer.writeAll("schema.Value{ .interface = {} }"),
            .any_pointer => |info| blk: {
                try writer.writeAll("schema.Value{ .any_pointer = .{ .message_bytes = ");
                try self.writeByteArrayLiteral(writer, info.message_bytes);
                break :blk try writer.writeAll(" } }");
            },
        }
    }

    fn generatePointerConst(self: *Generator, name: []const u8, typ: schema.Type, value: schema.Value, writer: anytype) !void {
        const bytes = switch (value) {
            .list => |info| info.message_bytes,
            .@"struct" => |info| info.message_bytes,
            .any_pointer => |info| info.message_bytes,
            else => return,
        };

        const return_type = try self.pointerConstReturnType(typ);
        defer self.allocator.free(return_type);

        try writer.print("pub const {s} = struct {{\n", .{name});
        try writer.writeAll("    const _bytes = ");
        try self.writeByteArrayInitializer(writer, bytes);
        try writer.writeAll(";\n");
        try writer.writeAll("    const _segments = [_][]const u8{ _bytes[0..] };\n");
        try writer.writeAll(
            "    const _message = message.Message{ .allocator = std.heap.page_allocator, .segments = _segments[0..], .backing_data = null, .segments_owned = false };\n\n",
        );
        try writer.print("    pub fn get() !{s} {{\n", .{return_type});
        switch (typ) {
            .list => |list_info| {
                const elem_type = list_info.element_type.*;
                try writer.writeAll("        const root = try _message.getRootAnyPointer();\n");
                if (elem_type == .@"struct") {
                    try writer.writeAll("        const list = try root.getInlineCompositeList();\n");
                    try writer.writeAll("        return message.StructListReader{\n");
                    try writer.writeAll("            .message = &_message,\n");
                    try writer.writeAll("            .segment_id = list.segment_id,\n");
                    try writer.writeAll("            .elements_offset = list.elements_offset,\n");
                    try writer.writeAll("            .element_count = list.element_count,\n");
                    try writer.writeAll("            .data_words = list.data_words,\n");
                    try writer.writeAll("            .pointer_words = list.pointer_words,\n");
                    try writer.writeAll("        };\n");
                } else {
                    const element_size = try self.listElementSize(elem_type);
                    try writer.writeAll("        const list = try root.getList();\n");
                    try writer.print("        if (list.element_size != {}) return error.InvalidPointer;\n", .{element_size});
                    try writer.print("        return {s}{{\n", .{return_type});
                    try writer.writeAll("            .message = &_message,\n");
                    try writer.writeAll("            .segment_id = list.segment_id,\n");
                    try writer.writeAll("            .elements_offset = list.content_offset,\n");
                    try writer.writeAll("            .element_count = list.element_count,\n");
                    try writer.writeAll("        };\n");
                }
            },
            .@"struct" => |struct_info| {
                if (try self.structTypeName(struct_info.type_id)) |struct_name| {
                    defer self.allocator.free(struct_name);
                    try writer.writeAll("        const value = try _message.getRootStruct();\n");
                    try writer.print("        return {s}.Reader{{ ._reader = value }};\n", .{struct_name});
                } else {
                    try writer.writeAll("        return try _message.getRootStruct();\n");
                }
            },
            .any_pointer => {
                try writer.writeAll("        return try _message.getRootAnyPointer();\n");
            },
            else => return error.InvalidPointerConstType,
        }
        try writer.writeAll("    }\n");
        try writer.writeAll("};\n\n");
    }

    fn pointerConstReturnType(self: *Generator, typ: schema.Type) ![]const u8 {
        return switch (typ) {
            .list => |list_info| try self.listReaderTypeString(list_info.element_type.*),
            .@"struct" => |struct_info| blk: {
                if (try self.structTypeName(struct_info.type_id)) |name| {
                    defer self.allocator.free(name);
                    break :blk try std.fmt.allocPrint(self.allocator, "{s}.Reader", .{name});
                }
                break :blk try self.allocator.dupe(u8, "message.StructReader");
            },
            .any_pointer => try self.allocator.dupe(u8, "message.AnyPointerReader"),
            else => return error.InvalidPointerConstType,
        };
    }

    fn listReaderTypeString(self: *Generator, elem_type: schema.Type) ![]const u8 {
        return switch (elem_type) {
            .void => try self.allocator.dupe(u8, "message.VoidListReader"),
            .bool => try self.allocator.dupe(u8, "message.BoolListReader"),
            .int8 => try self.allocator.dupe(u8, "message.I8ListReader"),
            .uint8 => try self.allocator.dupe(u8, "message.U8ListReader"),
            .int16 => try self.allocator.dupe(u8, "message.I16ListReader"),
            .uint16 => try self.allocator.dupe(u8, "message.U16ListReader"),
            .int32 => try self.allocator.dupe(u8, "message.I32ListReader"),
            .uint32 => try self.allocator.dupe(u8, "message.U32ListReader"),
            .float32 => try self.allocator.dupe(u8, "message.F32ListReader"),
            .int64 => try self.allocator.dupe(u8, "message.I64ListReader"),
            .uint64 => try self.allocator.dupe(u8, "message.U64ListReader"),
            .float64 => try self.allocator.dupe(u8, "message.F64ListReader"),
            .text => try self.allocator.dupe(u8, "message.TextListReader"),
            .@"struct" => try self.allocator.dupe(u8, "message.StructListReader"),
            .@"enum" => try self.allocator.dupe(u8, "message.U16ListReader"),
            else => try self.allocator.dupe(u8, "message.PointerListReader"),
        };
    }

    fn listElementSize(self: *Generator, elem_type: schema.Type) !u3 {
        _ = self;
        return switch (elem_type) {
            .void => 0,
            .bool => 1,
            .int8, .uint8 => 2,
            .int16, .uint16, .@"enum" => 3,
            .int32, .uint32, .float32 => 4,
            .int64, .uint64, .float64 => 5,
            .text, .data, .list, .@"struct", .any_pointer, .interface => 6,
        };
    }

    fn structTypeName(self: *Generator, id: schema.Id) !?[]const u8 {
        const node = self.getNode(id) orelse return null;
        if (node.kind != .@"struct") return null;
        return try self.allocTypeDeclName(node);
    }

    fn writeByteArrayInitializer(self: *Generator, writer: anytype, data: []const u8) !void {
        _ = self;
        try writer.writeAll("[_]u8{");
        for (data, 0..) |byte, i| {
            if (i != 0) try writer.writeAll(", ");
            try writer.print("0x{X:0>2}", .{byte});
        }
        try writer.writeAll("}");
    }

    fn writeByteArrayLiteral(self: *Generator, writer: anytype, data: []const u8) !void {
        _ = self;
        try writer.writeAll("&[_]u8{");
        for (data, 0..) |byte, i| {
            if (i != 0) try writer.writeAll(", ");
            try writer.print("0x{X:0>2}", .{byte});
        }
        try writer.writeAll("}");
    }
};

// ---------------------------------------------------------------------------
// Inline unit tests for pure helper functions
// ---------------------------------------------------------------------------

test "Generator.toSnakeCaseLower converts camelCase" {
    const alloc = std.testing.allocator;
    var gen = Generator.init(alloc, &.{}) catch unreachable;
    defer gen.deinit();

    const r1 = try gen.toSnakeCaseLower("myFieldName");
    defer alloc.free(r1);
    try std.testing.expectEqualStrings("my_field_name", r1);
}

test "Generator.toSnakeCaseLower handles simple lowercase" {
    const alloc = std.testing.allocator;
    var gen = Generator.init(alloc, &.{}) catch unreachable;
    defer gen.deinit();

    const r = try gen.toSnakeCaseLower("simple");
    defer alloc.free(r);
    try std.testing.expectEqualStrings("simple", r);
}

test "Generator.toSnakeCaseLower converts PascalCase" {
    const alloc = std.testing.allocator;
    var gen = Generator.init(alloc, &.{}) catch unreachable;
    defer gen.deinit();

    const r = try gen.toSnakeCaseLower("PascalCase");
    defer alloc.free(r);
    try std.testing.expectEqualStrings("pascal_case", r);
}

test "Generator.toSnakeCaseLower strips non-alphanumeric separators" {
    const alloc = std.testing.allocator;
    var gen = Generator.init(alloc, &.{}) catch unreachable;
    defer gen.deinit();

    const r = try gen.toSnakeCaseLower("foo-bar.baz");
    defer alloc.free(r);
    try std.testing.expectEqualStrings("foo_bar_baz", r);
}

test "Generator.toSnakeCaseLower handles empty input" {
    const alloc = std.testing.allocator;
    var gen = Generator.init(alloc, &.{}) catch unreachable;
    defer gen.deinit();

    const r = try gen.toSnakeCaseLower("");
    defer alloc.free(r);
    try std.testing.expectEqualStrings("x", r);
}

test "Generator.toSnakeCaseLower trims trailing separator" {
    const alloc = std.testing.allocator;
    var gen = Generator.init(alloc, &.{}) catch unreachable;
    defer gen.deinit();

    const r = try gen.toSnakeCaseLower("foo-");
    defer alloc.free(r);
    try std.testing.expectEqualStrings("foo", r);
}

test "Generator.importPathFromCapnpName replaces .capnp with .zig" {
    const alloc = std.testing.allocator;
    var gen = Generator.init(alloc, &.{}) catch unreachable;
    defer gen.deinit();

    const r1 = try gen.importPathFromCapnpName("other.capnp");
    defer alloc.free(r1);
    try std.testing.expectEqualStrings("other.zig", r1);

    const r2 = try gen.importPathFromCapnpName("path/to/types.capnp");
    defer alloc.free(r2);
    try std.testing.expectEqualStrings("path/to/types.zig", r2);

    const r3 = try gen.importPathFromCapnpName("/capnp/stream.capnp");
    defer alloc.free(r3);
    try std.testing.expectEqualStrings("capnp/stream.zig", r3);
}

test "Generator.importPathFromCapnpName appends .zig for non-.capnp" {
    const alloc = std.testing.allocator;
    var gen = Generator.init(alloc, &.{}) catch unreachable;
    defer gen.deinit();

    const r = try gen.importPathFromCapnpName("something_else");
    defer alloc.free(r);
    try std.testing.expectEqualStrings("something_else.zig", r);
}

test "Generator.lowerFirst lowercases first character" {
    const alloc = std.testing.allocator;
    var gen = Generator.init(alloc, &.{}) catch unreachable;
    defer gen.deinit();

    const r1 = try gen.lowerFirst("FooBar");
    defer alloc.free(r1);
    try std.testing.expectEqualStrings("fooBar", r1);

    const r2 = try gen.lowerFirst("already");
    defer alloc.free(r2);
    try std.testing.expectEqualStrings("already", r2);
}

test "Generator.lowerFirst handles empty string" {
    const alloc = std.testing.allocator;
    var gen = Generator.init(alloc, &.{}) catch unreachable;
    defer gen.deinit();

    const r = try gen.lowerFirst("");
    defer alloc.free(r);
    try std.testing.expectEqualStrings("", r);
}

test "Generator.lowerFirst handles single character" {
    const alloc = std.testing.allocator;
    var gen = Generator.init(alloc, &.{}) catch unreachable;
    defer gen.deinit();

    const r = try gen.lowerFirst("X");
    defer alloc.free(r);
    try std.testing.expectEqualStrings("x", r);
}

test "Generator.listElementSize returns correct Cap'n Proto element sizes" {
    const alloc = std.testing.allocator;
    var gen = Generator.init(alloc, &.{}) catch unreachable;
    defer gen.deinit();

    try std.testing.expectEqual(@as(u3, 0), try gen.listElementSize(.void));
    try std.testing.expectEqual(@as(u3, 1), try gen.listElementSize(.bool));
    try std.testing.expectEqual(@as(u3, 2), try gen.listElementSize(.int8));
    try std.testing.expectEqual(@as(u3, 2), try gen.listElementSize(.uint8));
    try std.testing.expectEqual(@as(u3, 3), try gen.listElementSize(.int16));
    try std.testing.expectEqual(@as(u3, 3), try gen.listElementSize(.uint16));
    try std.testing.expectEqual(@as(u3, 4), try gen.listElementSize(.int32));
    try std.testing.expectEqual(@as(u3, 4), try gen.listElementSize(.uint32));
    try std.testing.expectEqual(@as(u3, 4), try gen.listElementSize(.float32));
    try std.testing.expectEqual(@as(u3, 5), try gen.listElementSize(.int64));
    try std.testing.expectEqual(@as(u3, 5), try gen.listElementSize(.uint64));
    try std.testing.expectEqual(@as(u3, 5), try gen.listElementSize(.float64));
    try std.testing.expectEqual(@as(u3, 6), try gen.listElementSize(.text));
    try std.testing.expectEqual(@as(u3, 6), try gen.listElementSize(.data));
    try std.testing.expectEqual(@as(u3, 6), try gen.listElementSize(.any_pointer));
}

test "Generator.moduleNameFromFilename extracts snake_case module name" {
    const alloc = std.testing.allocator;
    var gen = Generator.init(alloc, &.{}) catch unreachable;
    defer gen.deinit();

    const r1 = try gen.moduleNameFromFilename("MySchema.capnp");
    defer alloc.free(r1);
    try std.testing.expectEqualStrings("my_schema", r1);

    const r2 = try gen.moduleNameFromFilename("path/to/types.capnp");
    defer alloc.free(r2);
    try std.testing.expectEqualStrings("types", r2);

    const r3 = try gen.moduleNameFromFilename("simple.capnp");
    defer alloc.free(r3);
    try std.testing.expectEqualStrings("simple", r3);
}

test "Generator.getSimpleName extracts name after prefix" {
    const alloc = std.testing.allocator;
    var gen = Generator.init(alloc, &.{}) catch unreachable;
    defer gen.deinit();

    const node1 = schema.Node{
        .id = 1,
        .display_name = "test.capnp:MyStruct",
        .display_name_prefix_length = 11,
        .scope_id = 0,
        .kind = .file,
        .nested_nodes = &.{},
        .annotations = &.{},
        .struct_node = null,
        .enum_node = null,
        .interface_node = null,
        .const_node = null,
        .annotation_node = null,
    };
    try std.testing.expectEqualStrings("MyStruct", gen.getSimpleName(&node1));

    const node2 = schema.Node{
        .id = 2,
        .display_name = "Standalone",
        .display_name_prefix_length = 0,
        .scope_id = 0,
        .kind = .file,
        .nested_nodes = &.{},
        .annotations = &.{},
        .struct_node = null,
        .enum_node = null,
        .interface_node = null,
        .const_node = null,
        .annotation_node = null,
    };
    try std.testing.expectEqualStrings("Standalone", gen.getSimpleName(&node2));

    // Prefix length exceeds display_name length -- should return entire display_name
    const node3 = schema.Node{
        .id = 3,
        .display_name = "short",
        .display_name_prefix_length = 100,
        .scope_id = 0,
        .kind = .file,
        .nested_nodes = &.{},
        .annotations = &.{},
        .struct_node = null,
        .enum_node = null,
        .interface_node = null,
        .const_node = null,
        .annotation_node = null,
    };
    try std.testing.expectEqualStrings("short", gen.getSimpleName(&node3));
}

test "Generator.getNode returns null for unknown ID" {
    const alloc = std.testing.allocator;
    var gen = Generator.init(alloc, &.{}) catch unreachable;
    defer gen.deinit();

    try std.testing.expect(gen.getNode(12345) == null);
}

test "Generator.getNode returns node by ID" {
    const alloc = std.testing.allocator;
    const nodes = [_]schema.Node{
        .{
            .id = 0xABCD,
            .display_name = "test",
            .display_name_prefix_length = 0,
            .scope_id = 0,
            .kind = .file,
            .nested_nodes = &.{},
            .annotations = &.{},
            .struct_node = null,
            .enum_node = null,
            .interface_node = null,
            .const_node = null,
            .annotation_node = null,
        },
    };
    var gen = try Generator.init(alloc, &nodes);
    defer gen.deinit();

    const found = gen.getNode(0xABCD);
    try std.testing.expect(found != null);
    try std.testing.expectEqualStrings("test", found.?.display_name);
    try std.testing.expect(gen.getNode(0xDEAD) == null);
}

test "Generator.writeByteArrayLiteral formats bytes" {
    const alloc = std.testing.allocator;
    var gen = Generator.init(alloc, &.{}) catch unreachable;
    defer gen.deinit();

    var buf = std.ArrayList(u8){};
    defer buf.deinit(alloc);
    const writer = buf.writer(alloc);

    try gen.writeByteArrayLiteral(writer, &[_]u8{ 0x00, 0xFF, 0x42 });
    try std.testing.expectEqualStrings("&[_]u8{0x00, 0xFF, 0x42}", buf.items);
}

test "Generator.writeByteArrayLiteral handles empty data" {
    const alloc = std.testing.allocator;
    var gen = Generator.init(alloc, &.{}) catch unreachable;
    defer gen.deinit();

    var buf = std.ArrayList(u8){};
    defer buf.deinit(alloc);
    const writer = buf.writer(alloc);

    try gen.writeByteArrayLiteral(writer, &[_]u8{});
    try std.testing.expectEqualStrings("&[_]u8{}", buf.items);
}
