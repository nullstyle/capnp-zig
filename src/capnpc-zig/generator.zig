const std = @import("std");
const schema = @import("../schema.zig");
const StructGenerator = @import("struct_gen.zig").StructGenerator;
pub const TypeGenerator = @import("types.zig").TypeGenerator;

/// Code generation driver that turns a set of parsed Cap'n Proto schema nodes
/// into idiomatic Zig source code with Reader and Builder types for each struct.
pub const Generator = struct {
    allocator: std.mem.Allocator,
    nodes: []const schema.Node,
    node_map: std.AutoHashMap(schema.Id, usize),

    /// Build a generator from the full set of schema nodes, indexing them by ID.
    pub fn init(allocator: std.mem.Allocator, nodes: []const schema.Node) !Generator {
        var node_map = std.AutoHashMap(schema.Id, usize).init(allocator);
        errdefer node_map.deinit();

        for (nodes, 0..) |node, i| {
            try node_map.put(node.id, i);
        }

        return .{
            .allocator = allocator,
            .nodes = nodes,
            .node_map = node_map,
        };
    }

    pub fn deinit(self: *Generator) void {
        self.node_map.deinit();
    }

    /// Get a node by its ID
    pub fn getNode(self: *const Generator, id: schema.Id) ?*const schema.Node {
        const index = self.node_map.get(id) orelse return null;
        return &self.nodes[index];
    }

    /// Generate Zig source code for a single requested `.capnp` file.
    ///
    /// Walks the file node's nested declarations, emitting struct/enum/const
    /// definitions. Returns an allocator-owned byte slice containing the
    /// generated `.zig` source.
    pub fn generateFile(self: *Generator, requested_file: schema.RequestedFile) ![]const u8 {
        var output = std.ArrayList(u8){};
        errdefer output.deinit(self.allocator);

        const writer = output.writer(self.allocator);

        // Write file header
        try writer.writeAll("// Generated by capnpc-zig\n");
        try writer.print("// Source: {s}\n\n", .{requested_file.filename});
        try writer.writeAll("const std = @import(\"std\");\n");
        try writer.writeAll("const capnpc = @import(\"capnpc-zig\");\n");
        try writer.writeAll("const message = capnpc.message;\n");
        try writer.writeAll("const schema = capnpc.schema;\n");
        try writer.writeAll("const rpc = capnpc.rpc;\n\n");

        // Find the file node
        const file_node = self.getNode(requested_file.id) orelse return error.FileNodeNotFound;
        try self.writeSchemaManifest(requested_file, file_node, writer);

        var generated = std.AutoHashMap(schema.Id, void).init(self.allocator);
        defer generated.deinit();

        // Generate code for all nested nodes (including nested definitions).
        for (file_node.nested_nodes) |nested| {
            try self.generateNodeRecursive(nested.id, &generated, &output);
        }

        return output.toOwnedSlice(self.allocator);
    }

    const ManifestSerdeEntry = struct {
        id: u64,
        type_name: []const u8,
        to_json_export: []const u8,
        from_json_export: []const u8,
    };

    const ManifestSerdeJsonEntry = struct {
        id: u64,
        type_name: []const u8,
        to_json_export: []const u8,
        from_json_export: []const u8,
    };

    const SchemaManifestJson = struct {
        schema: []const u8,
        module: []const u8,
        serde: []const ManifestSerdeJsonEntry,
    };

    fn writeSchemaManifest(
        self: *Generator,
        requested_file: schema.RequestedFile,
        file_node: *const schema.Node,
        writer: anytype,
    ) !void {
        const module_name = try self.moduleNameFromFilename(requested_file.filename);
        defer self.allocator.free(module_name);

        var seen = std.AutoHashMap(schema.Id, void).init(self.allocator);
        defer seen.deinit();

        var entries = std.ArrayList(ManifestSerdeEntry){};
        defer {
            for (entries.items) |entry| {
                self.allocator.free(entry.type_name);
                self.allocator.free(entry.to_json_export);
                self.allocator.free(entry.from_json_export);
            }
            entries.deinit(self.allocator);
        }

        for (file_node.nested_nodes) |nested| {
            try self.collectManifestSerdeEntries(nested.id, module_name, &seen, &entries);
        }

        self.sortManifestSerdeEntries(entries.items);

        var json_entries = try self.allocator.alloc(ManifestSerdeJsonEntry, entries.items.len);
        defer self.allocator.free(json_entries);
        for (entries.items, 0..) |entry, i| {
            json_entries[i] = .{
                .id = entry.id,
                .type_name = entry.type_name,
                .to_json_export = entry.to_json_export,
                .from_json_export = entry.from_json_export,
            };
        }

        const manifest_json_bytes = try std.json.Stringify.valueAlloc(self.allocator, SchemaManifestJson{
            .schema = requested_file.filename,
            .module = module_name,
            .serde = json_entries,
        }, .{});
        defer self.allocator.free(manifest_json_bytes);

        try writer.print("pub const CAPNP_SCHEMA_MANIFEST_JSON: []const u8 = \"{f}\";\n", .{
            std.zig.fmtString(manifest_json_bytes),
        });
        try writer.writeAll("pub fn capnpSchemaManifestJson() []const u8 {\n");
        try writer.writeAll("    return CAPNP_SCHEMA_MANIFEST_JSON;\n");
        try writer.writeAll("}\n\n");
    }

    fn collectManifestSerdeEntries(
        self: *Generator,
        id: schema.Id,
        module_name: []const u8,
        seen: *std.AutoHashMap(schema.Id, void),
        entries: *std.ArrayList(ManifestSerdeEntry),
    ) !void {
        if (seen.contains(id)) return;
        const node = self.getNode(id) orelse return;
        try seen.put(id, {});

        if (node.kind == .@"struct") {
            const simple_name = self.getSimpleName(node);
            const type_name = try self.toZigIdentifier(simple_name);
            const type_export = try self.toSnakeCaseLower(simple_name);
            defer self.allocator.free(type_export);

            try entries.append(self.allocator, .{
                .id = node.id,
                .type_name = type_name,
                .to_json_export = try std.fmt.allocPrint(
                    self.allocator,
                    "capnp_{s}_{s}_to_json",
                    .{ module_name, type_export },
                ),
                .from_json_export = try std.fmt.allocPrint(
                    self.allocator,
                    "capnp_{s}_{s}_from_json",
                    .{ module_name, type_export },
                ),
            });
        }

        for (node.nested_nodes) |nested| {
            try self.collectManifestSerdeEntries(nested.id, module_name, seen, entries);
        }

        if (node.kind == .interface) {
            const iface = node.interface_node orelse return;
            for (iface.methods) |method| {
                try self.collectManifestSerdeEntries(method.param_struct_type, module_name, seen, entries);
                try self.collectManifestSerdeEntries(method.result_struct_type, module_name, seen, entries);
            }
        }
    }

    fn sortManifestSerdeEntries(self: *Generator, entries: []ManifestSerdeEntry) void {
        _ = self;
        var i: usize = 1;
        while (i < entries.len) : (i += 1) {
            var j = i;
            while (j > 0 and manifestSerdeEntryLess(entries[j], entries[j - 1])) : (j -= 1) {
                std.mem.swap(ManifestSerdeEntry, &entries[j], &entries[j - 1]);
            }
        }
    }

    fn manifestSerdeEntryLess(a: ManifestSerdeEntry, b: ManifestSerdeEntry) bool {
        const type_order = std.mem.order(u8, a.type_name, b.type_name);
        if (type_order == .lt) return true;
        if (type_order == .gt) return false;
        return a.id < b.id;
    }

    /// Generate code for a single node
    fn generateNode(self: *Generator, node: *const schema.Node, output: *std.ArrayList(u8)) !void {
        const writer = output.writer(self.allocator);

        switch (node.kind) {
            .@"struct" => try self.generateStruct(node, writer),
            .@"enum" => try self.generateEnum(node, writer),
            .interface => try self.generateInterface(node, writer),
            .@"const" => try self.generateConst(node, writer),
            .file => {}, // File nodes are handled separately
            .annotation => try self.generateAnnotation(node, writer),
        }

        if (node.kind != .file) {
            try self.generateAnnotationUses(node, writer);
        }
    }

    fn generateNodeRecursive(
        self: *Generator,
        id: schema.Id,
        generated: *std.AutoHashMap(schema.Id, void),
        output: *std.ArrayList(u8),
    ) !void {
        if (generated.contains(id)) return;
        const node = self.getNode(id) orelse return;
        try generated.put(id, {});

        // Mark group nodes as generated so they don't get generated as top-level types
        // (they are generated inline by their parent struct)
        if (node.kind == .@"struct") {
            if (node.struct_node) |struct_node| {
                for (struct_node.fields) |field| {
                    if (field.group) |group| {
                        try generated.put(group.type_id, {});
                    }
                }
            }
        }

        try self.generateNode(node, output);
        for (node.nested_nodes) |nested| {
            try self.generateNodeRecursive(nested.id, generated, output);
        }
        if (node.kind == .interface) {
            const iface = node.interface_node orelse return;
            for (iface.methods) |method| {
                try self.generateNodeRecursive(method.param_struct_type, generated, output);
                try self.generateNodeRecursive(method.result_struct_type, generated, output);
            }
        }
    }

    /// Generate a struct definition
    fn generateStruct(self: *Generator, node: *const schema.Node, writer: anytype) !void {
        var struct_gen = StructGenerator.initWithLookup(self.allocator, lookupNode, self);
        try struct_gen.generate(node, writer);
    }

    /// Generate an enum definition
    fn generateEnum(self: *Generator, node: *const schema.Node, writer: anytype) !void {
        const enum_info = node.enum_node orelse return error.InvalidEnumNode;

        const name = self.getSimpleName(node);

        try writer.print("pub const {s} = enum(u16) {{\n", .{name});

        for (enum_info.enumerants) |enumerant| {
            const zig_name = try self.toZigIdentifier(enumerant.name);
            defer self.allocator.free(zig_name);
            try writer.print("    {s} = {},\n", .{ zig_name, enumerant.code_order });
        }

        try writer.writeAll("};\n\n");
    }

    /// Generate an interface definition
    fn generateInterface(self: *Generator, node: *const schema.Node, writer: anytype) !void {
        const interface_info = node.interface_node orelse return error.InvalidInterfaceNode;
        const name = self.getSimpleName(node);

        try writer.print("pub const {s} = struct {{\n", .{name});
        try writer.print("    pub const interface_id: u64 = 0x{x};\n", .{node.id});
        try writer.writeAll("    pub const Method = enum(u16) {\n");
        for (interface_info.methods) |method| {
            const zig_name = try self.toZigIdentifier(method.name);
            defer self.allocator.free(zig_name);
            try writer.print("        {s} = {},\n", .{ zig_name, method.code_order });
        }
        try writer.writeAll("    };\n\n");

        for (interface_info.methods) |method| {
            const zig_name = try self.toZigIdentifier(method.name);
            defer self.allocator.free(zig_name);
            const method_field = try self.lowerFirst(zig_name);
            defer self.allocator.free(method_field);
            const param_name = try self.resolveNodeName(method.param_struct_type);
            defer self.allocator.free(param_name);
            const result_name = try self.resolveNodeName(method.result_struct_type);
            defer self.allocator.free(result_name);

            const param_layout = self.structLayout(method.param_struct_type) orelse return error.InvalidStructNode;
            const result_layout = self.structLayout(method.result_struct_type) orelse return error.InvalidStructNode;

            try writer.print("    pub const {s} = struct {{\n", .{zig_name});
            try writer.print("        pub const ordinal: u16 = {};\n", .{method.code_order});
            try writer.print("        pub const Params = {s};\n", .{param_name});
            try writer.print("        pub const Results = {s};\n", .{result_name});
            try writer.writeAll("        pub const BuildFn = *const fn (ctx: *anyopaque, params: *Params.Builder) anyerror!void;\n");
            try writer.writeAll("        pub const Handler = *const fn (ctx: *anyopaque, peer: *rpc.peer.Peer, params: Params.Reader, results: *Results.Builder, caps: *const rpc.cap_table.InboundCapTable) anyerror!void;\n");
            try writer.writeAll("        pub const Response = union(enum) {\n");
            try writer.writeAll("            results: Results.Reader,\n");
            try writer.writeAll("            exception: rpc.protocol.Exception,\n");
            try writer.writeAll("            canceled,\n");
            try writer.writeAll("            results_sent_elsewhere,\n");
            try writer.writeAll("            take_from_other_question: u32,\n");
            try writer.writeAll("            accept_from_third_party,\n");
            try writer.writeAll("        };\n");
            try writer.writeAll("        pub const Callback = *const fn (ctx: *anyopaque, peer: *rpc.peer.Peer, response: Response, caps: *const rpc.cap_table.InboundCapTable) anyerror!void;\n\n");

            try writer.writeAll("        const CallContext = struct {\n");
            try writer.writeAll("            user_ctx: *anyopaque,\n");
            try writer.writeAll("            build: ?BuildFn,\n");
            try writer.writeAll("            callback: Callback,\n");
            try writer.writeAll("        };\n\n");

            try writer.writeAll("        const ReturnContext = struct {\n");
            try writer.writeAll("            server: *Server,\n");
            try writer.writeAll("            peer: *rpc.peer.Peer,\n");
            try writer.writeAll("            params: Params.Reader,\n");
            try writer.writeAll("            caps: *const rpc.cap_table.InboundCapTable,\n");
            try writer.writeAll("        };\n\n");

            try writer.writeAll("        fn callBuild(ctx_ptr: *anyopaque, call: *rpc.protocol.CallBuilder) anyerror!void {\n");
            try writer.writeAll("            const ctx: *CallContext = @ptrCast(@alignCast(ctx_ptr));\n");
            try writer.print("            const params_builder = try call.initParamsStruct({}, {});\n", .{
                param_layout.data_words,
                param_layout.pointer_words,
            });
            try writer.writeAll("            var params = Params.Builder.wrap(params_builder);\n");
            try writer.writeAll("            if (ctx.build) |build_fn| {\n");
            try writer.writeAll("                try build_fn(ctx.user_ctx, &params);\n");
            try writer.writeAll("            }\n");
            try writer.writeAll("            try call.setEmptyCapTable();\n");
            try writer.writeAll("        }\n\n");

            try writer.writeAll("        fn callReturn(ctx_ptr: *anyopaque, peer: *rpc.peer.Peer, ret: rpc.protocol.Return, caps: *const rpc.cap_table.InboundCapTable) anyerror!void {\n");
            try writer.writeAll("            const ctx: *CallContext = @ptrCast(@alignCast(ctx_ptr));\n");
            try writer.writeAll("            defer peer.allocator.destroy(ctx);\n");
            try writer.writeAll("            var response: Response = undefined;\n");
            try writer.writeAll("            switch (ret.tag) {\n");
            try writer.writeAll("                .results => {\n");
            try writer.writeAll("                    const payload = ret.results orelse return error.MissingReturnPayload;\n");
            try writer.writeAll("                    const struct_reader = try payload.content.getStruct();\n");
            try writer.writeAll("                    const results = Results.Reader.wrap(struct_reader);\n");
            try writer.writeAll("                    response = .{ .results = results };\n");
            try writer.writeAll("                },\n");
            try writer.writeAll("                .exception => {\n");
            try writer.writeAll("                    const ex = ret.exception orelse return error.MissingException;\n");
            try writer.writeAll("                    response = .{ .exception = ex };\n");
            try writer.writeAll("                },\n");
            try writer.writeAll("                .canceled => response = .canceled,\n");
            try writer.writeAll("                .results_sent_elsewhere => response = .results_sent_elsewhere,\n");
            try writer.writeAll("                .take_from_other_question => {\n");
            try writer.writeAll("                    const qid = ret.take_from_other_question orelse return error.MissingQuestionId;\n");
            try writer.writeAll("                    response = .{ .take_from_other_question = qid };\n");
            try writer.writeAll("                },\n");
            try writer.writeAll("                .accept_from_third_party => response = .accept_from_third_party,\n");
            try writer.writeAll("            }\n");
            try writer.writeAll("            try ctx.callback(ctx.user_ctx, peer, response, caps);\n");
            try writer.writeAll("        }\n\n");

            try writer.writeAll("        fn handleCall(server: *Server, peer: *rpc.peer.Peer, call: rpc.protocol.Call, caps: *const rpc.cap_table.InboundCapTable) anyerror!void {\n");
            try writer.writeAll("            const params_struct = try call.params.content.getStruct();\n");
            try writer.writeAll("            const params = Params.Reader.wrap(params_struct);\n");
            try writer.writeAll("            var ctx = ReturnContext{\n");
            try writer.writeAll("                .server = server,\n");
            try writer.writeAll("                .peer = peer,\n");
            try writer.writeAll("                .params = params,\n");
            try writer.writeAll("                .caps = caps,\n");
            try writer.writeAll("            };\n");
            try writer.writeAll("            try peer.sendReturnResults(call.question_id, &ctx, buildReturn);\n");
            try writer.writeAll("        }\n\n");

            try writer.writeAll("        fn buildReturn(ctx_ptr: *anyopaque, ret: *rpc.protocol.ReturnBuilder) anyerror!void {\n");
            try writer.writeAll("            const ctx: *ReturnContext = @ptrCast(@alignCast(ctx_ptr));\n");
            try writer.print("            const results_builder = try ret.initResultsStruct({}, {});\n", .{
                result_layout.data_words,
                result_layout.pointer_words,
            });
            try writer.writeAll("            var results = Results.Builder.wrap(results_builder);\n");
            try writer.print("            try ctx.server.vtable.{s}(ctx.server.ctx, ctx.peer, ctx.params, &results, ctx.caps);\n", .{method_field});
            try writer.writeAll("            try ret.setEmptyCapTable();\n");
            try writer.writeAll("        }\n");

            try writer.writeAll("    };\n\n");
        }

        try writer.writeAll("    pub const Client = struct {\n");
        try writer.writeAll("        peer: *rpc.peer.Peer,\n");
        try writer.writeAll("        cap_id: u32,\n\n");
        try writer.writeAll("        pub fn init(peer: *rpc.peer.Peer, cap_id: u32) Client {\n");
        try writer.writeAll("            return .{ .peer = peer, .cap_id = cap_id };\n");
        try writer.writeAll("        }\n\n");

        for (interface_info.methods) |method| {
            const zig_name = try self.toZigIdentifier(method.name);
            defer self.allocator.free(zig_name);
            const call_name = try std.fmt.allocPrint(self.allocator, "call{s}", .{zig_name});
            defer self.allocator.free(call_name);

            try writer.print("        pub fn {s}(self: *Client, user_ctx: *anyopaque, build: ?{s}.BuildFn, on_return: {s}.Callback) !u32 {{\n", .{
                call_name,
                zig_name,
                zig_name,
            });
            try writer.print("            const ctx = try self.peer.allocator.create({s}.CallContext);\n", .{zig_name});
            try writer.writeAll("            ctx.* = .{ .user_ctx = user_ctx, .build = build, .callback = on_return };\n");
            try writer.print("            return self.peer.sendCall(self.cap_id, interface_id, {s}.ordinal, ctx, {s}.callBuild, {s}.callReturn);\n", .{
                zig_name,
                zig_name,
                zig_name,
            });
            try writer.writeAll("        }\n\n");
        }

        try writer.writeAll("        pub fn fromBootstrap(peer: *rpc.peer.Peer, user_ctx: *anyopaque, callback: BootstrapCallback) !u32 {\n");
        try writer.writeAll("            return bootstrap(peer, user_ctx, callback);\n");
        try writer.writeAll("        }\n\n");

        try writer.writeAll("    };\n\n");

        try writer.writeAll("    pub const BootstrapResponse = union(enum) {\n");
        try writer.writeAll("        client: Client,\n");
        try writer.writeAll("        exception: rpc.protocol.Exception,\n");
        try writer.writeAll("        canceled,\n");
        try writer.writeAll("        results_sent_elsewhere,\n");
        try writer.writeAll("        take_from_other_question: u32,\n");
        try writer.writeAll("        accept_from_third_party,\n");
        try writer.writeAll("    };\n");
        try writer.writeAll("    pub const BootstrapCallback = *const fn (ctx: *anyopaque, peer: *rpc.peer.Peer, response: BootstrapResponse) anyerror!void;\n\n");

        try writer.writeAll("    const BootstrapContext = struct {\n");
        try writer.writeAll("        user_ctx: *anyopaque,\n");
        try writer.writeAll("        callback: BootstrapCallback,\n");
        try writer.writeAll("    };\n\n");

        try writer.writeAll("    fn bootstrapReturn(ctx_ptr: *anyopaque, peer: *rpc.peer.Peer, ret: rpc.protocol.Return, caps: *const rpc.cap_table.InboundCapTable) anyerror!void {\n");
        try writer.writeAll("        const ctx: *BootstrapContext = @ptrCast(@alignCast(ctx_ptr));\n");
        try writer.writeAll("        defer peer.allocator.destroy(ctx);\n");
        try writer.writeAll("        var response: BootstrapResponse = undefined;\n");
        try writer.writeAll("        switch (ret.tag) {\n");
        try writer.writeAll("            .results => {\n");
        try writer.writeAll("                const payload = ret.results orelse return error.MissingReturnPayload;\n");
        try writer.writeAll("                const cap = try payload.content.getCapability();\n");
        try writer.writeAll("                const resolved = try caps.resolveCapability(cap);\n");
        try writer.writeAll("                switch (resolved) {\n");
        try writer.writeAll("                    .imported => |imported| response = .{ .client = Client.init(peer, imported.id) },\n");
        try writer.writeAll("                    else => return error.UnexpectedBootstrapCapability,\n");
        try writer.writeAll("                }\n");
        try writer.writeAll("            },\n");
        try writer.writeAll("            .exception => {\n");
        try writer.writeAll("                const ex = ret.exception orelse return error.MissingException;\n");
        try writer.writeAll("                response = .{ .exception = ex };\n");
        try writer.writeAll("            },\n");
        try writer.writeAll("            .canceled => response = .canceled,\n");
        try writer.writeAll("            .results_sent_elsewhere => response = .results_sent_elsewhere,\n");
        try writer.writeAll("            .take_from_other_question => {\n");
        try writer.writeAll("                const qid = ret.take_from_other_question orelse return error.MissingQuestionId;\n");
        try writer.writeAll("                response = .{ .take_from_other_question = qid };\n");
        try writer.writeAll("            },\n");
        try writer.writeAll("            .accept_from_third_party => response = .accept_from_third_party,\n");
        try writer.writeAll("        }\n");
        try writer.writeAll("        try ctx.callback(ctx.user_ctx, peer, response);\n");
        try writer.writeAll("    }\n\n");

        try writer.writeAll("    pub fn bootstrap(peer: *rpc.peer.Peer, user_ctx: *anyopaque, callback: BootstrapCallback) !u32 {\n");
        try writer.writeAll("        const ctx = try peer.allocator.create(BootstrapContext);\n");
        try writer.writeAll("        ctx.* = .{ .user_ctx = user_ctx, .callback = callback };\n");
        try writer.writeAll("        return peer.sendBootstrap(ctx, bootstrapReturn);\n");
        try writer.writeAll("    }\n\n");

        try writer.writeAll("    pub const Server = struct {\n");
        try writer.writeAll("        ctx: *anyopaque,\n");
        try writer.writeAll("        vtable: VTable,\n");
        try writer.writeAll("    };\n\n");

        try writer.writeAll("    pub const VTable = struct {\n");
        for (interface_info.methods) |method| {
            const zig_name = try self.toZigIdentifier(method.name);
            defer self.allocator.free(zig_name);
            const method_field = try self.lowerFirst(zig_name);
            defer self.allocator.free(method_field);
            try writer.print("        {s}: {s}.Handler,\n", .{ method_field, zig_name });
        }
        try writer.writeAll("    };\n\n");

        try writer.writeAll("    pub fn exportServer(peer: *rpc.peer.Peer, server: *Server) !u32 {\n");
        try writer.writeAll("        return peer.addExport(.{ .ctx = server, .on_call = onCall });\n");
        try writer.writeAll("    }\n\n");

        try writer.writeAll("    pub fn setBootstrap(peer: *rpc.peer.Peer, server: *Server) !u32 {\n");
        try writer.writeAll("        return peer.setBootstrap(.{ .ctx = server, .on_call = onCall });\n");
        try writer.writeAll("    }\n\n");

        try writer.writeAll("    fn onCall(ctx: *anyopaque, peer: *rpc.peer.Peer, call: rpc.protocol.Call, caps: *const rpc.cap_table.InboundCapTable) anyerror!void {\n");
        try writer.writeAll("        const server: *Server = @ptrCast(@alignCast(ctx));\n");
        try writer.writeAll("        _ = server;\n");
        try writer.writeAll("        _ = caps;\n");
        try writer.writeAll("        switch (call.method_id) {\n");
        for (interface_info.methods) |method| {
            const zig_name = try self.toZigIdentifier(method.name);
            defer self.allocator.free(zig_name);
            try writer.print("            {s}.ordinal => try {s}.handleCall(server, peer, call, caps),\n", .{ zig_name, zig_name });
        }
        try writer.writeAll("            else => try peer.sendReturnException(call.question_id, \"unknown method\"),\n");
        try writer.writeAll("        }\n");
        try writer.writeAll("    }\n");

        try writer.writeAll("};\n\n");
    }

    /// Generate a constant definition
    fn generateConst(self: *Generator, node: *const schema.Node, writer: anytype) !void {
        const const_info = node.const_node orelse return error.InvalidConstNode;
        const name = self.getSimpleName(node);

        switch (const_info.value) {
            .text => |text| {
                try writer.print("pub const {s}: []const u8 = \"{f}\";\n\n", .{ name, std.zig.fmtString(text) });
            },
            .data => |data| {
                try writer.print("pub const {s}: []const u8 = ", .{name});
                try self.writeByteArrayLiteral(writer, data);
                try writer.writeAll(";\n\n");
            },
            .list, .@"struct", .any_pointer => {
                try self.generatePointerConst(name, const_info.type, const_info.value, writer);
            },
            else => {
                const type_name = try self.typeNameForConst(const_info.type);
                defer self.allocator.free(type_name);

                if (try self.constValueLiteral(const_info.type, const_info.value)) |literal| {
                    try writer.print("pub const {s}: {s} = {s};\n\n", .{ name, type_name, literal });
                    self.allocator.free(literal);
                } else {
                    return error.UnsupportedConstType;
                }
            },
        }
    }

    /// Generate an annotation definition
    fn generateAnnotation(self: *Generator, node: *const schema.Node, writer: anytype) !void {
        const annotation_info = node.annotation_node orelse return error.InvalidAnnotationNode;
        const name = self.getSimpleName(node);

        const type_name = try self.typeNameForConst(annotation_info.type);
        defer self.allocator.free(type_name);

        try writer.print("pub const {s} = struct {{\n", .{name});
        try writer.print("    pub const Type = {s};\n", .{type_name});
        try writer.writeAll("    pub const targets = .{\n");
        try writer.print("        .file = {},\n", .{annotation_info.targets_file});
        try writer.print("        .const = {},\n", .{annotation_info.targets_const});
        try writer.print("        .enum = {},\n", .{annotation_info.targets_enum});
        try writer.print("        .enumerant = {},\n", .{annotation_info.targets_enumerant});
        try writer.print("        .struct = {},\n", .{annotation_info.targets_struct});
        try writer.print("        .field = {},\n", .{annotation_info.targets_field});
        try writer.print("        .union = {},\n", .{annotation_info.targets_union});
        try writer.print("        .group = {},\n", .{annotation_info.targets_group});
        try writer.print("        .interface = {},\n", .{annotation_info.targets_interface});
        try writer.print("        .method = {},\n", .{annotation_info.targets_method});
        try writer.print("        .param = {},\n", .{annotation_info.targets_param});
        try writer.print("        .annotation = {},\n", .{annotation_info.targets_annotation});
        try writer.writeAll("    };\n");
        try writer.writeAll("};\n\n");
    }

    /// Get simple name from display name
    fn getSimpleName(self: *Generator, node: *const schema.Node) []const u8 {
        _ = self;
        const prefix_len = node.display_name_prefix_length;
        if (prefix_len >= node.display_name.len) return node.display_name;
        return node.display_name[prefix_len..];
    }

    fn resolveNodeName(self: *Generator, id: schema.Id) ![]const u8 {
        if (self.getNode(id)) |node| {
            const name = self.getSimpleName(node);
            return self.toZigIdentifier(name);
        }
        return try self.allocator.dupe(u8, "void");
    }

    fn structLayout(self: *Generator, id: schema.Id) ?struct { data_words: u16, pointer_words: u16 } {
        const node = self.getNode(id) orelse return null;
        if (node.kind != .@"struct") return null;
        const info = node.struct_node orelse return null;
        return .{ .data_words = info.data_word_count, .pointer_words = info.pointer_count };
    }

    fn lowerFirst(self: *Generator, name: []const u8) ![]const u8 {
        if (name.len == 0) return try self.allocator.dupe(u8, name);
        var result = try self.allocator.alloc(u8, name.len);
        result[0] = std.ascii.toLower(name[0]);
        @memcpy(result[1..], name[1..]);
        return result;
    }

    /// Convert Cap'n Proto identifier to Zig identifier
    fn toZigIdentifier(self: *Generator, name: []const u8) ![]const u8 {
        var result = try std.ArrayList(u8).initCapacity(self.allocator, name.len);
        errdefer result.deinit(self.allocator);

        var capitalize_next = true;
        for (name) |c| {
            if (c == '_' or c == '$') {
                capitalize_next = true;
                continue;
            }

            if (capitalize_next) {
                try result.append(self.allocator, std.ascii.toUpper(c));
                capitalize_next = false;
            } else {
                try result.append(self.allocator, c);
            }
        }

        return result.toOwnedSlice(self.allocator);
    }

    fn moduleNameFromFilename(self: *Generator, filename: []const u8) ![]const u8 {
        const stem = std.fs.path.stem(filename);
        return self.toSnakeCaseLower(stem);
    }

    fn toSnakeCaseLower(self: *Generator, name: []const u8) ![]u8 {
        var out = std.ArrayList(u8){};
        errdefer out.deinit(self.allocator);

        var prev_was_sep = false;
        for (name, 0..) |c, i| {
            if (!std.ascii.isAlphanumeric(c)) {
                if (out.items.len != 0 and !prev_was_sep) {
                    try out.append(self.allocator, '_');
                    prev_was_sep = true;
                }
                continue;
            }

            if (std.ascii.isUpper(c)) {
                if (i != 0 and out.items.len != 0 and !prev_was_sep) {
                    try out.append(self.allocator, '_');
                }
                try out.append(self.allocator, std.ascii.toLower(c));
                prev_was_sep = false;
                continue;
            }

            try out.append(self.allocator, c);
            prev_was_sep = false;
        }

        if (out.items.len == 0) {
            try out.append(self.allocator, 'x');
        }

        if (out.items[out.items.len - 1] == '_') {
            _ = out.pop();
        }

        return out.toOwnedSlice(self.allocator);
    }

    fn lookupNode(ctx: ?*const anyopaque, id: schema.Id) ?*const schema.Node {
        const generator: *const Generator = @ptrCast(@alignCast(ctx.?));
        return generator.getNode(id);
    }

    fn typeNameForConst(self: *Generator, typ: schema.Type) ![]const u8 {
        return switch (typ) {
            .void => try self.allocator.dupe(u8, "void"),
            .bool => try self.allocator.dupe(u8, "bool"),
            .int8 => try self.allocator.dupe(u8, "i8"),
            .int16 => try self.allocator.dupe(u8, "i16"),
            .int32 => try self.allocator.dupe(u8, "i32"),
            .int64 => try self.allocator.dupe(u8, "i64"),
            .uint8 => try self.allocator.dupe(u8, "u8"),
            .uint16 => try self.allocator.dupe(u8, "u16"),
            .uint32 => try self.allocator.dupe(u8, "u32"),
            .uint64 => try self.allocator.dupe(u8, "u64"),
            .float32 => try self.allocator.dupe(u8, "f32"),
            .float64 => try self.allocator.dupe(u8, "f64"),
            .text => try self.allocator.dupe(u8, "[]const u8"),
            .data => try self.allocator.dupe(u8, "[]const u8"),
            .list => |list_info| try self.listReaderTypeString(list_info.element_type.*),
            .@"enum" => |enum_info| blk: {
                if (self.getNode(enum_info.type_id)) |node| {
                    if (node.kind == .@"enum") {
                        const name = self.getSimpleName(node);
                        break :blk try self.allocator.dupe(u8, name);
                    }
                }
                break :blk try self.allocator.dupe(u8, "u16");
            },
            .@"struct" => |struct_info| blk: {
                if (self.structTypeName(struct_info.type_id)) |name| {
                    defer self.allocator.free(name);
                    break :blk try std.fmt.allocPrint(self.allocator, "{s}.Reader", .{name});
                }
                break :blk try self.allocator.dupe(u8, "message.StructReader");
            },
            .interface => try self.allocator.dupe(u8, "message.Capability"),
            .any_pointer => try self.allocator.dupe(u8, "message.AnyPointerReader"),
        };
    }

    fn constValueLiteral(self: *Generator, typ: schema.Type, value: schema.Value) !?[]const u8 {
        return switch (typ) {
            .void => if (value == .void) try self.allocator.dupe(u8, "{}") else null,
            .bool => if (value == .bool)
                try self.allocator.dupe(u8, if (value.bool) "true" else "false")
            else
                null,
            .int8 => if (value == .int8) try std.fmt.allocPrint(self.allocator, "@as(i8, {d})", .{value.int8}) else null,
            .uint8 => if (value == .uint8) try std.fmt.allocPrint(self.allocator, "@as(u8, {d})", .{value.uint8}) else null,
            .int16 => if (value == .int16) try std.fmt.allocPrint(self.allocator, "@as(i16, {d})", .{value.int16}) else null,
            .uint16 => if (value == .uint16) try std.fmt.allocPrint(self.allocator, "@as(u16, {d})", .{value.uint16}) else null,
            .int32 => if (value == .int32) try std.fmt.allocPrint(self.allocator, "@as(i32, {d})", .{value.int32}) else null,
            .uint32 => if (value == .uint32) try std.fmt.allocPrint(self.allocator, "@as(u32, {d})", .{value.uint32}) else null,
            .int64 => if (value == .int64) try std.fmt.allocPrint(self.allocator, "@as(i64, {d})", .{value.int64}) else null,
            .uint64 => if (value == .uint64) try std.fmt.allocPrint(self.allocator, "@as(u64, {d})", .{value.uint64}) else null,
            .float32 => if (value == .float32) blk: {
                const bits: u32 = @bitCast(value.float32);
                break :blk try std.fmt.allocPrint(self.allocator, "@bitCast(@as(u32, {d}))", .{bits});
            } else null,
            .float64 => if (value == .float64) blk: {
                const bits: u64 = @bitCast(value.float64);
                break :blk try std.fmt.allocPrint(self.allocator, "@bitCast(@as(u64, {d}))", .{bits});
            } else null,
            .@"enum" => if (value == .@"enum") blk: {
                const enum_val = value.@"enum";
                break :blk try std.fmt.allocPrint(self.allocator, "@enumFromInt(@as(u16, {d}))", .{enum_val});
            } else null,
            else => null,
        };
    }

    fn generateAnnotationUses(self: *Generator, node: *const schema.Node, writer: anytype) !void {
        const name = self.getSimpleName(node);

        if (node.annotations.len > 0) {
            try writer.print("pub const {s}_annotations = ", .{name});
            try self.writeAnnotationList(writer, node.annotations);
            try writer.writeAll(";\n\n");
        }

        switch (node.kind) {
            .@"struct" => if (node.struct_node) |struct_node| {
                var any = false;
                for (struct_node.fields) |field| {
                    if (field.annotations.len > 0) {
                        any = true;
                        break;
                    }
                }
                if (any) {
                    try writer.print(
                        "pub const {s}_field_annotations = [_]struct {{ name: []const u8, annotations: []const schema.AnnotationUse }}{{\n",
                        .{name},
                    );
                    for (struct_node.fields) |field| {
                        if (field.annotations.len == 0) continue;
                        try writer.print("    .{{ .name = \"{f}\", .annotations = ", .{std.zig.fmtString(field.name)});
                        try self.writeAnnotationList(writer, field.annotations);
                        try writer.writeAll(" },\n");
                    }
                    try writer.writeAll("};\n\n");
                }
            },
            .@"enum" => if (node.enum_node) |enum_node| {
                var any = false;
                for (enum_node.enumerants) |enumerant| {
                    if (enumerant.annotations.len > 0) {
                        any = true;
                        break;
                    }
                }
                if (any) {
                    try writer.print(
                        "pub const {s}_enumerant_annotations = [_]struct {{ name: []const u8, annotations: []const schema.AnnotationUse }}{{\n",
                        .{name},
                    );
                    for (enum_node.enumerants) |enumerant| {
                        if (enumerant.annotations.len == 0) continue;
                        try writer.print("    .{{ .name = \"{f}\", .annotations = ", .{std.zig.fmtString(enumerant.name)});
                        try self.writeAnnotationList(writer, enumerant.annotations);
                        try writer.writeAll(" },\n");
                    }
                    try writer.writeAll("};\n\n");
                }
            },
            .interface => if (node.interface_node) |interface_node| {
                var any = false;
                for (interface_node.methods) |method| {
                    if (method.annotations.len > 0) {
                        any = true;
                        break;
                    }
                }
                if (any) {
                    try writer.print(
                        "pub const {s}_method_annotations = [_]struct {{ name: []const u8, annotations: []const schema.AnnotationUse }}{{\n",
                        .{name},
                    );
                    for (interface_node.methods) |method| {
                        if (method.annotations.len == 0) continue;
                        try writer.print("    .{{ .name = \"{f}\", .annotations = ", .{std.zig.fmtString(method.name)});
                        try self.writeAnnotationList(writer, method.annotations);
                        try writer.writeAll(" },\n");
                    }
                    try writer.writeAll("};\n\n");
                }
            },
            else => {},
        }
    }

    fn writeAnnotationList(self: *Generator, writer: anytype, annotations: []const schema.AnnotationUse) !void {
        try writer.writeAll("&[_]schema.AnnotationUse{");
        for (annotations) |annotation| {
            try writer.print(".{{ .id = 0x{X}, .value = ", .{annotation.id});
            try self.writeValueLiteral(writer, annotation.value);
            try writer.writeAll(" },");
        }
        try writer.writeAll("}");
    }

    fn writeValueLiteral(self: *Generator, writer: anytype, value: schema.Value) !void {
        switch (value) {
            .void => try writer.writeAll("schema.Value{ .void = {} }"),
            .bool => |v| try writer.print("schema.Value{{ .bool = {} }}", .{v}),
            .int8 => |v| try writer.print("schema.Value{{ .int8 = @as(i8, {d}) }}", .{v}),
            .int16 => |v| try writer.print("schema.Value{{ .int16 = @as(i16, {d}) }}", .{v}),
            .int32 => |v| try writer.print("schema.Value{{ .int32 = @as(i32, {d}) }}", .{v}),
            .int64 => |v| try writer.print("schema.Value{{ .int64 = @as(i64, {d}) }}", .{v}),
            .uint8 => |v| try writer.print("schema.Value{{ .uint8 = @as(u8, {d}) }}", .{v}),
            .uint16 => |v| try writer.print("schema.Value{{ .uint16 = @as(u16, {d}) }}", .{v}),
            .uint32 => |v| try writer.print("schema.Value{{ .uint32 = @as(u32, {d}) }}", .{v}),
            .uint64 => |v| try writer.print("schema.Value{{ .uint64 = @as(u64, {d}) }}", .{v}),
            .float32 => |v| blk: {
                const bits: u32 = @bitCast(v);
                break :blk try writer.print("schema.Value{{ .float32 = @bitCast(@as(u32, {d})) }}", .{bits});
            },
            .float64 => |v| blk: {
                const bits: u64 = @bitCast(v);
                break :blk try writer.print("schema.Value{{ .float64 = @bitCast(@as(u64, {d})) }}", .{bits});
            },
            .text => |text| try writer.print("schema.Value{{ .text = \"{f}\" }}", .{std.zig.fmtString(text)}),
            .data => |data| blk: {
                try writer.writeAll("schema.Value{ .data = ");
                try self.writeByteArrayLiteral(writer, data);
                break :blk try writer.writeAll(" }");
            },
            .list => |info| blk: {
                try writer.writeAll("schema.Value{ .list = .{ .message_bytes = ");
                try self.writeByteArrayLiteral(writer, info.message_bytes);
                break :blk try writer.writeAll(" } }");
            },
            .@"enum" => |v| try writer.print("schema.Value{{ .@\"enum\" = @as(u16, {d}) }}", .{v}),
            .@"struct" => |info| blk: {
                try writer.writeAll("schema.Value{ .@\"struct\" = .{ .message_bytes = ");
                try self.writeByteArrayLiteral(writer, info.message_bytes);
                break :blk try writer.writeAll(" } }");
            },
            .interface => try writer.writeAll("schema.Value{ .interface = {} }"),
            .any_pointer => |info| blk: {
                try writer.writeAll("schema.Value{ .any_pointer = .{ .message_bytes = ");
                try self.writeByteArrayLiteral(writer, info.message_bytes);
                break :blk try writer.writeAll(" } }");
            },
        }
    }

    fn generatePointerConst(self: *Generator, name: []const u8, typ: schema.Type, value: schema.Value, writer: anytype) !void {
        const bytes = switch (value) {
            .list => |info| info.message_bytes,
            .@"struct" => |info| info.message_bytes,
            .any_pointer => |info| info.message_bytes,
            else => return,
        };

        const return_type = try self.pointerConstReturnType(typ);
        defer self.allocator.free(return_type);

        try writer.print("pub const {s} = struct {{\n", .{name});
        try writer.writeAll("    const _bytes = ");
        try self.writeByteArrayInitializer(writer, bytes);
        try writer.writeAll(";\n");
        try writer.writeAll("    const _segments = [_][]const u8{ _bytes[0..] };\n");
        try writer.writeAll(
            "    const _message = message.Message{ .allocator = std.heap.page_allocator, .segments = _segments[0..], .backing_data = null, .segments_owned = false };\n\n",
        );
        try writer.print("    pub fn get() !{s} {{\n", .{return_type});
        switch (typ) {
            .list => |list_info| {
                const elem_type = list_info.element_type.*;
                try writer.writeAll("        const root = try _message.getRootAnyPointer();\n");
                if (elem_type == .@"struct") {
                    try writer.writeAll("        const list = try root.getInlineCompositeList();\n");
                    try writer.writeAll("        return message.StructListReader{\n");
                    try writer.writeAll("            .message = &_message,\n");
                    try writer.writeAll("            .segment_id = list.segment_id,\n");
                    try writer.writeAll("            .elements_offset = list.elements_offset,\n");
                    try writer.writeAll("            .element_count = list.element_count,\n");
                    try writer.writeAll("            .data_words = list.data_words,\n");
                    try writer.writeAll("            .pointer_words = list.pointer_words,\n");
                    try writer.writeAll("        };\n");
                } else {
                    const element_size = try self.listElementSize(elem_type);
                    try writer.writeAll("        const list = try root.getList();\n");
                    try writer.print("        if (list.element_size != {}) return error.InvalidPointer;\n", .{element_size});
                    try writer.print("        return {s}{{\n", .{return_type});
                    try writer.writeAll("            .message = &_message,\n");
                    try writer.writeAll("            .segment_id = list.segment_id,\n");
                    try writer.writeAll("            .elements_offset = list.content_offset,\n");
                    try writer.writeAll("            .element_count = list.element_count,\n");
                    try writer.writeAll("        };\n");
                }
            },
            .@"struct" => |struct_info| {
                if (self.structTypeName(struct_info.type_id)) |struct_name| {
                    defer self.allocator.free(struct_name);
                    try writer.writeAll("        const value = try _message.getRootStruct();\n");
                    try writer.print("        return {s}.Reader{{ ._reader = value }};\n", .{struct_name});
                } else {
                    try writer.writeAll("        return try _message.getRootStruct();\n");
                }
            },
            .any_pointer => {
                try writer.writeAll("        return try _message.getRootAnyPointer();\n");
            },
            else => return error.InvalidPointerConstType,
        }
        try writer.writeAll("    }\n");
        try writer.writeAll("};\n\n");
    }

    fn pointerConstReturnType(self: *Generator, typ: schema.Type) ![]const u8 {
        return switch (typ) {
            .list => |list_info| try self.listReaderTypeString(list_info.element_type.*),
            .@"struct" => |struct_info| blk: {
                if (self.structTypeName(struct_info.type_id)) |name| {
                    defer self.allocator.free(name);
                    break :blk try std.fmt.allocPrint(self.allocator, "{s}.Reader", .{name});
                }
                break :blk try self.allocator.dupe(u8, "message.StructReader");
            },
            .any_pointer => try self.allocator.dupe(u8, "message.AnyPointerReader"),
            else => return error.InvalidPointerConstType,
        };
    }

    fn listReaderTypeString(self: *Generator, elem_type: schema.Type) ![]const u8 {
        return switch (elem_type) {
            .void => try self.allocator.dupe(u8, "message.VoidListReader"),
            .bool => try self.allocator.dupe(u8, "message.BoolListReader"),
            .int8 => try self.allocator.dupe(u8, "message.I8ListReader"),
            .uint8 => try self.allocator.dupe(u8, "message.U8ListReader"),
            .int16 => try self.allocator.dupe(u8, "message.I16ListReader"),
            .uint16 => try self.allocator.dupe(u8, "message.U16ListReader"),
            .int32 => try self.allocator.dupe(u8, "message.I32ListReader"),
            .uint32 => try self.allocator.dupe(u8, "message.U32ListReader"),
            .float32 => try self.allocator.dupe(u8, "message.F32ListReader"),
            .int64 => try self.allocator.dupe(u8, "message.I64ListReader"),
            .uint64 => try self.allocator.dupe(u8, "message.U64ListReader"),
            .float64 => try self.allocator.dupe(u8, "message.F64ListReader"),
            .text => try self.allocator.dupe(u8, "message.TextListReader"),
            .@"struct" => try self.allocator.dupe(u8, "message.StructListReader"),
            .@"enum" => try self.allocator.dupe(u8, "message.U16ListReader"),
            else => try self.allocator.dupe(u8, "message.PointerListReader"),
        };
    }

    fn listElementSize(self: *Generator, elem_type: schema.Type) !u3 {
        _ = self;
        return switch (elem_type) {
            .void => 0,
            .bool => 1,
            .int8, .uint8 => 2,
            .int16, .uint16, .@"enum" => 3,
            .int32, .uint32, .float32 => 4,
            .int64, .uint64, .float64 => 5,
            .text, .data, .list, .@"struct", .any_pointer, .interface => 6,
        };
    }

    fn structTypeName(self: *Generator, id: schema.Id) ?[]const u8 {
        const node = self.getNode(id) orelse return null;
        if (node.kind != .@"struct") return null;
        const name = self.getSimpleName(node);
        return self.allocator.dupe(u8, name) catch null;
    }

    fn writeByteArrayInitializer(self: *Generator, writer: anytype, data: []const u8) !void {
        _ = self;
        try writer.writeAll("[_]u8{");
        for (data, 0..) |byte, i| {
            if (i != 0) try writer.writeAll(", ");
            try writer.print("0x{X:0>2}", .{byte});
        }
        try writer.writeAll("}");
    }

    fn writeByteArrayLiteral(self: *Generator, writer: anytype, data: []const u8) !void {
        _ = self;
        try writer.writeAll("&[_]u8{");
        for (data, 0..) |byte, i| {
            if (i != 0) try writer.writeAll(", ");
            try writer.print("0x{X:0>2}", .{byte});
        }
        try writer.writeAll("}");
    }
};
