const std = @import("std");
const schema = @import("../schema.zig");
const StructGenerator = @import("struct_gen.zig").StructGenerator;

pub const Generator = struct {
    allocator: std.mem.Allocator,
    nodes: []const schema.Node,
    node_map: std.AutoHashMap(schema.Id, usize),

    pub fn init(allocator: std.mem.Allocator, nodes: []const schema.Node) !Generator {
        var node_map = std.AutoHashMap(schema.Id, usize).init(allocator);
        errdefer node_map.deinit();

        for (nodes, 0..) |node, i| {
            try node_map.put(node.id, i);
        }

        return .{
            .allocator = allocator,
            .nodes = nodes,
            .node_map = node_map,
        };
    }

    pub fn deinit(self: *Generator) void {
        self.node_map.deinit();
    }

    /// Get a node by its ID
    pub fn getNode(self: *const Generator, id: schema.Id) ?*const schema.Node {
        const index = self.node_map.get(id) orelse return null;
        return &self.nodes[index];
    }

    /// Generate code for a requested file
    pub fn generateFile(self: *Generator, requested_file: schema.RequestedFile) ![]const u8 {
        var output = std.ArrayList(u8){};
        errdefer output.deinit(self.allocator);

        const writer = output.writer(self.allocator);

        // Write file header
        try writer.writeAll("// Generated by capnpc-zig\n");
        try writer.print("// Source: {s}\n\n", .{requested_file.filename});
        try writer.writeAll("const std = @import(\"std\");\n");
        try writer.writeAll("const message = @import(\"message.zig\");\n");
        try writer.writeAll("const schema = @import(\"schema.zig\");\n\n");

        // Find the file node
        const file_node = self.getNode(requested_file.id) orelse return error.FileNodeNotFound;

        // Generate code for all nested nodes
        for (file_node.nested_nodes) |nested| {
            const node = self.getNode(nested.id) orelse continue;
            try self.generateNode(node, &output);
        }

        return output.toOwnedSlice(self.allocator);
    }

    /// Generate code for a single node
    fn generateNode(self: *Generator, node: *const schema.Node, output: *std.ArrayList(u8)) !void {
        const writer = output.writer(self.allocator);

        switch (node.kind) {
            .@"struct" => try self.generateStruct(node, writer),
            .@"enum" => try self.generateEnum(node, writer),
            .interface => try self.generateInterface(node, writer),
            .@"const" => try self.generateConst(node, writer),
            .file => {}, // File nodes are handled separately
            .annotation => try self.generateAnnotation(node, writer),
        }

        if (node.kind != .file) {
            try self.generateAnnotationUses(node, writer);
        }
    }

    /// Generate a struct definition
    fn generateStruct(self: *Generator, node: *const schema.Node, writer: anytype) !void {
        var struct_gen = StructGenerator.initWithLookup(self.allocator, lookupNode, self);
        try struct_gen.generate(node, writer);
    }

    /// Generate field accessor
    fn generateFieldAccessor(self: *Generator, field: schema.Field, writer: anytype) !void {
        const slot = field.slot orelse return;

        const zig_name = try self.toZigIdentifier(field.name);
        defer self.allocator.free(zig_name);

        const zig_type = try self.typeToZig(slot.type);
        defer self.allocator.free(zig_type);

        try writer.print("        pub fn get{s}(self: Reader) {s} {{\n", .{ zig_name, zig_type });

        // Generate accessor based on type
        switch (slot.type) {
            .void => try writer.writeAll("            return {};\n"),
            .bool => try writer.print("            const byte_offset = {};\n            const bit_offset = {};\n            if (byte_offset >= self.data.len) return false;\n            const byte = self.data[byte_offset];\n            return (byte & (@as(u8, 1) << bit_offset)) != 0;\n", .{ slot.offset / 8, slot.offset % 8 }),
            .int8, .int16, .int32, .int64, .uint8, .uint16, .uint32, .uint64, .float32, .float64 => {
                const type_name = try self.typeToZig(slot.type);
                defer self.allocator.free(type_name);
                try writer.print("            const offset = {};\n", .{slot.offset});
                try writer.print("            const byte_offset = offset * @sizeOf({s});\n", .{type_name});
                try writer.print("            if (byte_offset + @sizeOf({s}) > self.data.len) return 0;\n", .{type_name});
                try writer.print("            return std.mem.readInt({s}, self.data[byte_offset..][0..@sizeOf({s})], .little);\n", .{ type_name, type_name });
            },
            .text => try writer.print("            // TODO: Implement text field accessor\n            _ = self;\n            return \"\";\n", .{}),
            .data => try writer.print("            // TODO: Implement data field accessor\n            _ = self;\n            return &[_]u8{{}};\n", .{}),
            else => try writer.writeAll("            // TODO: Implement complex type accessor\n            _ = self;\n            return undefined;\n"),
        }

        try writer.writeAll("        }\n\n");
    }

    /// Generate an enum definition
    fn generateEnum(self: *Generator, node: *const schema.Node, writer: anytype) !void {
        const enum_info = node.enum_node orelse return error.InvalidEnumNode;

        const name = self.getSimpleName(node);

        try writer.print("pub const {s} = enum(u16) {{\n", .{name});

        for (enum_info.enumerants) |enumerant| {
            const zig_name = try self.toZigIdentifier(enumerant.name);
            defer self.allocator.free(zig_name);
            try writer.print("    {s} = {},\n", .{ zig_name, enumerant.code_order });
        }

        try writer.writeAll("};\n\n");
    }

    /// Generate an interface definition
    fn generateInterface(self: *Generator, node: *const schema.Node, writer: anytype) !void {
        _ = self;
        const name = node.display_name;
        try writer.print("// TODO: Interface {s}\n\n", .{name});
    }

    /// Generate a constant definition
    fn generateConst(self: *Generator, node: *const schema.Node, writer: anytype) !void {
        const const_info = node.const_node orelse return error.InvalidConstNode;
        const name = self.getSimpleName(node);

        switch (const_info.value) {
            .text => |text| {
                try writer.print("pub const {s}: []const u8 = \"{f}\";\n\n", .{ name, std.zig.fmtString(text) });
            },
            .data => |data| {
                try writer.print("pub const {s}: []const u8 = ", .{name});
                try self.writeByteArrayLiteral(writer, data);
                try writer.writeAll(";\n\n");
            },
            .list, .@"struct", .any_pointer => {
                try self.generatePointerConst(name, const_info.type, const_info.value, writer);
            },
            else => {
                const type_name = try self.typeNameForConst(const_info.type);
                defer self.allocator.free(type_name);

                if (try self.constValueLiteral(const_info.type, const_info.value)) |literal| {
                    try writer.print("pub const {s}: {s} = {s};\n\n", .{ name, type_name, literal });
                    self.allocator.free(literal);
                } else {
                    try writer.print("// TODO: Const {s} (unsupported type)\n\n", .{name});
                }
            },
        }
    }

    /// Generate an annotation definition
    fn generateAnnotation(self: *Generator, node: *const schema.Node, writer: anytype) !void {
        const annotation_info = node.annotation_node orelse return error.InvalidAnnotationNode;
        const name = self.getSimpleName(node);

        const type_name = try self.typeNameForConst(annotation_info.type);
        defer self.allocator.free(type_name);

        try writer.print("pub const {s} = struct {{\n", .{name});
        try writer.print("    pub const Type = {s};\n", .{type_name});
        try writer.writeAll("    pub const targets = .{\n");
        try writer.print("        .file = {},\n", .{annotation_info.targets_file});
        try writer.print("        .const = {},\n", .{annotation_info.targets_const});
        try writer.print("        .enum = {},\n", .{annotation_info.targets_enum});
        try writer.print("        .enumerant = {},\n", .{annotation_info.targets_enumerant});
        try writer.print("        .struct = {},\n", .{annotation_info.targets_struct});
        try writer.print("        .field = {},\n", .{annotation_info.targets_field});
        try writer.print("        .union = {},\n", .{annotation_info.targets_union});
        try writer.print("        .group = {},\n", .{annotation_info.targets_group});
        try writer.print("        .interface = {},\n", .{annotation_info.targets_interface});
        try writer.print("        .method = {},\n", .{annotation_info.targets_method});
        try writer.print("        .param = {},\n", .{annotation_info.targets_param});
        try writer.print("        .annotation = {},\n", .{annotation_info.targets_annotation});
        try writer.writeAll("    };\n");
        try writer.writeAll("};\n\n");
    }

    /// Get simple name from display name
    fn getSimpleName(self: *Generator, node: *const schema.Node) []const u8 {
        _ = self;
        const prefix_len = node.display_name_prefix_length;
        if (prefix_len >= node.display_name.len) return node.display_name;
        return node.display_name[prefix_len..];
    }

    /// Convert Cap'n Proto identifier to Zig identifier
    fn toZigIdentifier(self: *Generator, name: []const u8) ![]const u8 {
        var result = try std.ArrayList(u8).initCapacity(self.allocator, name.len);
        errdefer result.deinit(self.allocator);

        var capitalize_next = true;
        for (name) |c| {
            if (c == '_') {
                capitalize_next = true;
                continue;
            }

            if (capitalize_next) {
                try result.append(self.allocator, std.ascii.toUpper(c));
                capitalize_next = false;
            } else {
                try result.append(self.allocator, c);
            }
        }

        return result.toOwnedSlice(self.allocator);
    }

    /// Convert Cap'n Proto type to Zig type string
    fn typeToZig(self: *Generator, typ: schema.Type) ![]const u8 {
        return switch (typ) {
            .void => try self.allocator.dupe(u8, "void"),
            .bool => try self.allocator.dupe(u8, "bool"),
            .int8 => try self.allocator.dupe(u8, "i8"),
            .int16 => try self.allocator.dupe(u8, "i16"),
            .int32 => try self.allocator.dupe(u8, "i32"),
            .int64 => try self.allocator.dupe(u8, "i64"),
            .uint8 => try self.allocator.dupe(u8, "u8"),
            .uint16 => try self.allocator.dupe(u8, "u16"),
            .uint32 => try self.allocator.dupe(u8, "u32"),
            .uint64 => try self.allocator.dupe(u8, "u64"),
            .float32 => try self.allocator.dupe(u8, "f32"),
            .float64 => try self.allocator.dupe(u8, "f64"),
            .text => try self.allocator.dupe(u8, "[]const u8"),
            .data => try self.allocator.dupe(u8, "[]const u8"),
            .list => try self.allocator.dupe(u8, "[]const u8"), // TODO: Proper list types
            .@"enum" => try self.allocator.dupe(u8, "u16"), // TODO: Proper enum types
            .@"struct" => try self.allocator.dupe(u8, "[]const u8"), // TODO: Proper struct types
            .interface => try self.allocator.dupe(u8, "void"), // TODO: Proper interface types
            .any_pointer => try self.allocator.dupe(u8, "[]const u8"),
        };
    }

    fn lookupNode(ctx: ?*const anyopaque, id: schema.Id) ?*const schema.Node {
        const generator: *const Generator = @ptrCast(@alignCast(ctx.?));
        return generator.getNode(id);
    }

    fn typeNameForConst(self: *Generator, typ: schema.Type) ![]const u8 {
        return switch (typ) {
            .void => try self.allocator.dupe(u8, "void"),
            .bool => try self.allocator.dupe(u8, "bool"),
            .int8 => try self.allocator.dupe(u8, "i8"),
            .int16 => try self.allocator.dupe(u8, "i16"),
            .int32 => try self.allocator.dupe(u8, "i32"),
            .int64 => try self.allocator.dupe(u8, "i64"),
            .uint8 => try self.allocator.dupe(u8, "u8"),
            .uint16 => try self.allocator.dupe(u8, "u16"),
            .uint32 => try self.allocator.dupe(u8, "u32"),
            .uint64 => try self.allocator.dupe(u8, "u64"),
            .float32 => try self.allocator.dupe(u8, "f32"),
            .float64 => try self.allocator.dupe(u8, "f64"),
            .text => try self.allocator.dupe(u8, "[]const u8"),
            .data => try self.allocator.dupe(u8, "[]const u8"),
            .list => |list_info| try self.listReaderTypeString(list_info.element_type.*),
            .@"enum" => |enum_info| blk: {
                if (self.getNode(enum_info.type_id)) |node| {
                    if (node.kind == .@"enum") {
                        const name = self.getSimpleName(node);
                        break :blk try self.allocator.dupe(u8, name);
                    }
                }
                break :blk try self.allocator.dupe(u8, "u16");
            },
            .@"struct" => |struct_info| blk: {
                if (self.structTypeName(struct_info.type_id)) |name| {
                    defer self.allocator.free(name);
                    break :blk try std.fmt.allocPrint(self.allocator, "{s}.Reader", .{name});
                }
                break :blk try self.allocator.dupe(u8, "message.StructReader");
            },
            .any_pointer => try self.allocator.dupe(u8, "message.AnyPointerReader"),
            else => try self.allocator.dupe(u8, "void"),
        };
    }

    fn constValueLiteral(self: *Generator, typ: schema.Type, value: schema.Value) !?[]const u8 {
        return switch (typ) {
            .bool => if (value == .bool)
                try self.allocator.dupe(u8, if (value.bool) "true" else "false")
            else
                null,
            .int8 => if (value == .int8) try std.fmt.allocPrint(self.allocator, "@as(i8, {d})", .{value.int8}) else null,
            .uint8 => if (value == .uint8) try std.fmt.allocPrint(self.allocator, "@as(u8, {d})", .{value.uint8}) else null,
            .int16 => if (value == .int16) try std.fmt.allocPrint(self.allocator, "@as(i16, {d})", .{value.int16}) else null,
            .uint16 => if (value == .uint16) try std.fmt.allocPrint(self.allocator, "@as(u16, {d})", .{value.uint16}) else null,
            .int32 => if (value == .int32) try std.fmt.allocPrint(self.allocator, "@as(i32, {d})", .{value.int32}) else null,
            .uint32 => if (value == .uint32) try std.fmt.allocPrint(self.allocator, "@as(u32, {d})", .{value.uint32}) else null,
            .int64 => if (value == .int64) try std.fmt.allocPrint(self.allocator, "@as(i64, {d})", .{value.int64}) else null,
            .uint64 => if (value == .uint64) try std.fmt.allocPrint(self.allocator, "@as(u64, {d})", .{value.uint64}) else null,
            .float32 => if (value == .float32) blk: {
                const bits: u32 = @bitCast(value.float32);
                break :blk try std.fmt.allocPrint(self.allocator, "@bitCast(@as(u32, {d}))", .{bits});
            } else null,
            .float64 => if (value == .float64) blk: {
                const bits: u64 = @bitCast(value.float64);
                break :blk try std.fmt.allocPrint(self.allocator, "@bitCast(@as(u64, {d}))", .{bits});
            } else null,
            .@"enum" => if (value == .@"enum") blk: {
                const enum_val = value.@"enum";
                break :blk try std.fmt.allocPrint(self.allocator, "@enumFromInt(@as(u16, {d}))", .{enum_val});
            } else null,
            else => null,
        };
    }

    fn generateAnnotationUses(self: *Generator, node: *const schema.Node, writer: anytype) !void {
        const name = self.getSimpleName(node);

        if (node.annotations.len > 0) {
            try writer.print("pub const {s}_annotations = ", .{name});
            try self.writeAnnotationList(writer, node.annotations);
            try writer.writeAll(";\n\n");
        }

        switch (node.kind) {
            .@"struct" => if (node.struct_node) |struct_node| {
                var any = false;
                for (struct_node.fields) |field| {
                    if (field.annotations.len > 0) {
                        any = true;
                        break;
                    }
                }
                if (any) {
                    try writer.print(
                        "pub const {s}_field_annotations = [_]struct {{ name: []const u8, annotations: []const schema.AnnotationUse }}{{\n",
                        .{name},
                    );
                    for (struct_node.fields) |field| {
                        if (field.annotations.len == 0) continue;
                        try writer.print("    .{{ .name = \"{f}\", .annotations = ", .{std.zig.fmtString(field.name)});
                        try self.writeAnnotationList(writer, field.annotations);
                        try writer.writeAll(" },\n");
                    }
                    try writer.writeAll("};\n\n");
                }
            },
            .@"enum" => if (node.enum_node) |enum_node| {
                var any = false;
                for (enum_node.enumerants) |enumerant| {
                    if (enumerant.annotations.len > 0) {
                        any = true;
                        break;
                    }
                }
                if (any) {
                    try writer.print(
                        "pub const {s}_enumerant_annotations = [_]struct {{ name: []const u8, annotations: []const schema.AnnotationUse }}{{\n",
                        .{name},
                    );
                    for (enum_node.enumerants) |enumerant| {
                        if (enumerant.annotations.len == 0) continue;
                        try writer.print("    .{{ .name = \"{f}\", .annotations = ", .{std.zig.fmtString(enumerant.name)});
                        try self.writeAnnotationList(writer, enumerant.annotations);
                        try writer.writeAll(" },\n");
                    }
                    try writer.writeAll("};\n\n");
                }
            },
            .interface => if (node.interface_node) |interface_node| {
                var any = false;
                for (interface_node.methods) |method| {
                    if (method.annotations.len > 0) {
                        any = true;
                        break;
                    }
                }
                if (any) {
                    try writer.print(
                        "pub const {s}_method_annotations = [_]struct {{ name: []const u8, annotations: []const schema.AnnotationUse }}{{\n",
                        .{name},
                    );
                    for (interface_node.methods) |method| {
                        if (method.annotations.len == 0) continue;
                        try writer.print("    .{{ .name = \"{f}\", .annotations = ", .{std.zig.fmtString(method.name)});
                        try self.writeAnnotationList(writer, method.annotations);
                        try writer.writeAll(" },\n");
                    }
                    try writer.writeAll("};\n\n");
                }
            },
            else => {},
        }
    }

    fn writeAnnotationList(self: *Generator, writer: anytype, annotations: []const schema.AnnotationUse) !void {
        try writer.writeAll("&[_]schema.AnnotationUse{");
        for (annotations) |annotation| {
            try writer.print(".{{ .id = 0x{X}, .value = ", .{annotation.id});
            try self.writeValueLiteral(writer, annotation.value);
            try writer.writeAll(" },");
        }
        try writer.writeAll("}");
    }

    fn writeValueLiteral(self: *Generator, writer: anytype, value: schema.Value) !void {
        switch (value) {
            .void => try writer.writeAll("schema.Value{ .void = {} }"),
            .bool => |v| try writer.print("schema.Value{{ .bool = {} }}", .{v}),
            .int8 => |v| try writer.print("schema.Value{{ .int8 = @as(i8, {d}) }}", .{v}),
            .int16 => |v| try writer.print("schema.Value{{ .int16 = @as(i16, {d}) }}", .{v}),
            .int32 => |v| try writer.print("schema.Value{{ .int32 = @as(i32, {d}) }}", .{v}),
            .int64 => |v| try writer.print("schema.Value{{ .int64 = @as(i64, {d}) }}", .{v}),
            .uint8 => |v| try writer.print("schema.Value{{ .uint8 = @as(u8, {d}) }}", .{v}),
            .uint16 => |v| try writer.print("schema.Value{{ .uint16 = @as(u16, {d}) }}", .{v}),
            .uint32 => |v| try writer.print("schema.Value{{ .uint32 = @as(u32, {d}) }}", .{v}),
            .uint64 => |v| try writer.print("schema.Value{{ .uint64 = @as(u64, {d}) }}", .{v}),
            .float32 => |v| blk: {
                const bits: u32 = @bitCast(v);
                break :blk try writer.print("schema.Value{{ .float32 = @bitCast(@as(u32, {d})) }}", .{bits});
            },
            .float64 => |v| blk: {
                const bits: u64 = @bitCast(v);
                break :blk try writer.print("schema.Value{{ .float64 = @bitCast(@as(u64, {d})) }}", .{bits});
            },
            .text => |text| try writer.print("schema.Value{{ .text = \"{f}\" }}", .{std.zig.fmtString(text)}),
            .data => |data| blk: {
                try writer.writeAll("schema.Value{ .data = ");
                try self.writeByteArrayLiteral(writer, data);
                break :blk try writer.writeAll(" }");
            },
            .list => |info| blk: {
                try writer.writeAll("schema.Value{ .list = .{ .message_bytes = ");
                try self.writeByteArrayLiteral(writer, info.message_bytes);
                break :blk try writer.writeAll(" } }");
            },
            .@"enum" => |v| try writer.print("schema.Value{{ .@\"enum\" = @as(u16, {d}) }}", .{v}),
            .@"struct" => |info| blk: {
                try writer.writeAll("schema.Value{ .@\"struct\" = .{ .message_bytes = ");
                try self.writeByteArrayLiteral(writer, info.message_bytes);
                break :blk try writer.writeAll(" } }");
            },
            .interface => try writer.writeAll("schema.Value{ .interface = {} }"),
            .any_pointer => |info| blk: {
                try writer.writeAll("schema.Value{ .any_pointer = .{ .message_bytes = ");
                try self.writeByteArrayLiteral(writer, info.message_bytes);
                break :blk try writer.writeAll(" } }");
            },
        }
    }

    fn generatePointerConst(self: *Generator, name: []const u8, typ: schema.Type, value: schema.Value, writer: anytype) !void {
        const bytes = switch (value) {
            .list => |info| info.message_bytes,
            .@"struct" => |info| info.message_bytes,
            .any_pointer => |info| info.message_bytes,
            else => return,
        };

        const return_type = try self.pointerConstReturnType(typ);
        defer self.allocator.free(return_type);

        try writer.print("pub const {s} = struct {{\n", .{name});
        try writer.writeAll("    const _bytes = ");
        try self.writeByteArrayInitializer(writer, bytes);
        try writer.writeAll(";\n");
        try writer.writeAll("    const _segments = [_][]const u8{ _bytes[0..] };\n");
        try writer.writeAll(
            "    const _message = message.Message{ .allocator = std.heap.page_allocator, .segments = _segments[0..], .backing_data = null, .segments_owned = false };\n\n",
        );
        try writer.print("    pub fn get() !{s} {{\n", .{return_type});
        switch (typ) {
            .list => |list_info| {
                const elem_type = list_info.element_type.*;
                try writer.writeAll("        const root = try _message.getRootAnyPointer();\n");
                if (elem_type == .@"struct") {
                    try writer.writeAll("        const list = try root.getInlineCompositeList();\n");
                    try writer.writeAll("        return message.StructListReader{\n");
                    try writer.writeAll("            .message = &_message,\n");
                    try writer.writeAll("            .segment_id = list.segment_id,\n");
                    try writer.writeAll("            .elements_offset = list.elements_offset,\n");
                    try writer.writeAll("            .element_count = list.element_count,\n");
                    try writer.writeAll("            .data_words = list.data_words,\n");
                    try writer.writeAll("            .pointer_words = list.pointer_words,\n");
                    try writer.writeAll("        };\n");
                } else {
                    const element_size = try self.listElementSize(elem_type);
                    try writer.writeAll("        const list = try root.getList();\n");
                    try writer.print("        if (list.element_size != {}) return error.InvalidPointer;\n", .{element_size});
                    try writer.print("        return {s}{{\n", .{return_type});
                    try writer.writeAll("            .message = &_message,\n");
                    try writer.writeAll("            .segment_id = list.segment_id,\n");
                    try writer.writeAll("            .elements_offset = list.content_offset,\n");
                    try writer.writeAll("            .element_count = list.element_count,\n");
                    try writer.writeAll("        };\n");
                }
            },
            .@"struct" => |struct_info| {
                if (self.structTypeName(struct_info.type_id)) |struct_name| {
                    defer self.allocator.free(struct_name);
                    try writer.writeAll("        const value = try _message.getRootStruct();\n");
                    try writer.print("        return {s}.Reader{{ ._reader = value }};\n", .{struct_name});
                } else {
                    try writer.writeAll("        return try _message.getRootStruct();\n");
                }
            },
            .any_pointer => {
                try writer.writeAll("        return try _message.getRootAnyPointer();\n");
            },
            else => {
                try writer.writeAll("        return error.UnsupportedType;\n");
            },
        }
        try writer.writeAll("    }\n");
        try writer.writeAll("};\n\n");
    }

    fn pointerConstReturnType(self: *Generator, typ: schema.Type) ![]const u8 {
        return switch (typ) {
            .list => |list_info| try self.listReaderTypeString(list_info.element_type.*),
            .@"struct" => |struct_info| blk: {
                if (self.structTypeName(struct_info.type_id)) |name| {
                    defer self.allocator.free(name);
                    break :blk try std.fmt.allocPrint(self.allocator, "{s}.Reader", .{name});
                }
                break :blk try self.allocator.dupe(u8, "message.StructReader");
            },
            .any_pointer => try self.allocator.dupe(u8, "message.AnyPointerReader"),
            else => try self.allocator.dupe(u8, "void"),
        };
    }

    fn listReaderTypeString(self: *Generator, elem_type: schema.Type) ![]const u8 {
        return switch (elem_type) {
            .bool => try self.allocator.dupe(u8, "message.BoolListReader"),
            .int8 => try self.allocator.dupe(u8, "message.I8ListReader"),
            .uint8 => try self.allocator.dupe(u8, "message.U8ListReader"),
            .int16 => try self.allocator.dupe(u8, "message.I16ListReader"),
            .uint16 => try self.allocator.dupe(u8, "message.U16ListReader"),
            .int32 => try self.allocator.dupe(u8, "message.I32ListReader"),
            .uint32 => try self.allocator.dupe(u8, "message.U32ListReader"),
            .float32 => try self.allocator.dupe(u8, "message.F32ListReader"),
            .int64 => try self.allocator.dupe(u8, "message.I64ListReader"),
            .uint64 => try self.allocator.dupe(u8, "message.U64ListReader"),
            .float64 => try self.allocator.dupe(u8, "message.F64ListReader"),
            .text => try self.allocator.dupe(u8, "message.TextListReader"),
            .@"struct" => try self.allocator.dupe(u8, "message.StructListReader"),
            .@"enum" => try self.allocator.dupe(u8, "message.U16ListReader"),
            else => try self.allocator.dupe(u8, "message.PointerListReader"),
        };
    }

    fn listElementSize(self: *Generator, elem_type: schema.Type) !u3 {
        _ = self;
        return switch (elem_type) {
            .void => 0,
            .bool => 1,
            .int8, .uint8 => 2,
            .int16, .uint16, .@"enum" => 3,
            .int32, .uint32, .float32 => 4,
            .int64, .uint64, .float64 => 5,
            .text, .data, .list, .@"struct", .any_pointer, .interface => 6,
        };
    }

    fn structTypeName(self: *Generator, id: schema.Id) ?[]const u8 {
        const node = self.getNode(id) orelse return null;
        if (node.kind != .@"struct") return null;
        const name = self.getSimpleName(node);
        return self.allocator.dupe(u8, name) catch null;
    }

    fn writeByteArrayInitializer(self: *Generator, writer: anytype, data: []const u8) !void {
        _ = self;
        try writer.writeAll("[_]u8{");
        for (data, 0..) |byte, i| {
            if (i != 0) try writer.writeAll(", ");
            try writer.print("0x{X:0>2}", .{byte});
        }
        try writer.writeAll("}");
    }

    fn writeByteArrayLiteral(self: *Generator, writer: anytype, data: []const u8) !void {
        _ = self;
        try writer.writeAll("&[_]u8{");
        for (data, 0..) |byte, i| {
            if (i != 0) try writer.writeAll(", ");
            try writer.print("0x{X:0>2}", .{byte});
        }
        try writer.writeAll("}");
    }
};
