const std = @import("std");
const capnpc = @import("capnpc-zig-core");

const host_peer_mod = capnpc.rpc.host_peer;
const protocol = capnpc.rpc.protocol;
const peer_mod = capnpc.rpc.peer;
const cap_table = capnpc.rpc.cap_table;

const BootstrapStubHandler = struct {
    fn onCall(
        ctx: *anyopaque,
        called_peer: *peer_mod.Peer,
        call: protocol.Call,
        inbound_caps: *const cap_table.InboundCapTable,
    ) anyerror!void {
        _ = ctx;
        _ = inbound_caps;
        try called_peer.sendReturnException(call.question_id, "bootstrap stub");
    }
};

var bootstrap_stub_ctx: u8 = 0;

const FramePair = struct {
    inbound: []u8,
    outbound: []u8,

    fn deinit(self: *FramePair, allocator: std.mem.Allocator) void {
        allocator.free(self.inbound);
        allocator.free(self.outbound);
    }
};

fn printArray(writer: anytype, name: []const u8, bytes: []const u8) !void {
    try writer.print("export const {s} = new Uint8Array([", .{name});
    for (bytes, 0..) |b, i| {
        if (i != 0) try writer.writeAll(", ");
        try writer.print("0x{x:0>2}", .{b});
    }
    try writer.writeAll("]);\n");
}

fn printCase(
    writer: anytype,
    prefix: []const u8,
    inbound: []const u8,
    outbound: []const u8,
) !void {
    var in_buf: [128]u8 = undefined;
    var out_buf: [128]u8 = undefined;
    const in_name = try std.fmt.bufPrint(&in_buf, "{s}_INBOUND", .{prefix});
    const out_name = try std.fmt.bufPrint(&out_buf, "{s}_OUTBOUND", .{prefix});
    try printArray(writer, in_name, inbound);
    try printArray(writer, out_name, outbound);
    try writer.writeAll("\n");
}

fn dupBytes(allocator: std.mem.Allocator, bytes: []const u8) ![]u8 {
    const copy = try allocator.alloc(u8, bytes.len);
    std.mem.copyForwards(u8, copy, bytes);
    return copy;
}

fn runCase(allocator: std.mem.Allocator, inbound: []const u8, with_bootstrap_stub: bool) ![]u8 {
    var host = host_peer_mod.HostPeer.init(allocator);
    defer host.deinit();
    host.start(null, null);

    if (with_bootstrap_stub) {
        _ = try host.peer.setBootstrap(.{
            .ctx = &bootstrap_stub_ctx,
            .on_call = BootstrapStubHandler.onCall,
        });
    }

    try host.pushFrame(inbound);
    const out = host.popOutgoingFrame() orelse return error.MissingOutbound;
    defer host.freeFrame(out);

    return dupBytes(allocator, out);
}

fn makeCallToBootstrapFixture(allocator: std.mem.Allocator) !FramePair {
    var host = host_peer_mod.HostPeer.init(allocator);
    defer host.deinit();
    host.start(null, null);

    const export_id = try host.peer.setBootstrap(.{
        .ctx = &bootstrap_stub_ctx,
        .on_call = BootstrapStubHandler.onCall,
    });

    var call_builder = protocol.MessageBuilder.init(allocator);
    defer call_builder.deinit();
    var call = try call_builder.beginCall(2, 0x1234, 9);
    try call.setTargetImportedCap(export_id);
    try call.setEmptyCapTable();
    const inbound = try call_builder.finish();
    defer allocator.free(inbound);

    try host.pushFrame(inbound);
    const out = host.popOutgoingFrame() orelse return error.MissingOutbound;
    defer host.freeFrame(out);

    return .{
        .inbound = try dupBytes(allocator, inbound),
        .outbound = try dupBytes(allocator, out),
    };
}

pub fn main() !void {
    const allocator = std.heap.page_allocator;
    var stdout = std.fs.File.stdout().writer(&.{});
    const writer = &stdout.interface;

    var bootstrap_builder = protocol.MessageBuilder.init(allocator);
    defer bootstrap_builder.deinit();
    try bootstrap_builder.buildBootstrap(1);
    const bootstrap_inbound = try bootstrap_builder.finish();
    defer allocator.free(bootstrap_inbound);
    const bootstrap_outbound = try runCase(allocator, bootstrap_inbound, false);
    defer allocator.free(bootstrap_outbound);
    const bootstrap_success_outbound = try runCase(allocator, bootstrap_inbound, true);
    defer allocator.free(bootstrap_success_outbound);

    var call_builder = protocol.MessageBuilder.init(allocator);
    defer call_builder.deinit();
    var call = try call_builder.beginCall(2, 0x1234, 9);
    try call.setTargetImportedCap(77);
    try call.setEmptyCapTable();
    const call_inbound = try call_builder.finish();
    defer allocator.free(call_inbound);
    const call_outbound = try runCase(allocator, call_inbound, false);
    defer allocator.free(call_outbound);
    var call_bootstrap = try makeCallToBootstrapFixture(allocator);
    defer call_bootstrap.deinit(allocator);

    try writer.writeAll("// Generated by `zig build gen-rpc-fixtures`\n");
    try printCase(writer, "BOOTSTRAP_Q1", bootstrap_inbound, bootstrap_outbound);
    try printCase(writer, "BOOTSTRAP_Q1_SUCCESS", bootstrap_inbound, bootstrap_success_outbound);
    try printCase(writer, "CALL_UNKNOWN_CAP_Q2", call_inbound, call_outbound);
    try printCase(writer, "CALL_BOOTSTRAP_CAP_Q2", call_bootstrap.inbound, call_bootstrap.outbound);
}
